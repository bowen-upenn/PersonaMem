{
    "Original Persona": "a university history professor specializing in the Eastern Wu period",
    "Expanded Persona": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.",
    "Topic": "coding",
    "Original Sample": "```python\nclass t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)\n```",
    "Coding and Formatting Styles": "{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}",
    "Updated Coding Sample": "```python\nclass T:  # Updated class name to follow CamelCase naming convention\n    count = 0  # Changed 'c' to 'count' for clarity\n\n    def __init__(self):  # Changed 'g' to 'self' for standard convention \n        self.mapping = {}  # Changed 'm' to 'mapping' for clarity\n\n    class Element:  # Renamed 'e' to 'Element' for clarity\n        def __init__(self, value):  # Changed 'w' to 'self' and 'a' to 'value' for clarity\n            self.data = value  # Changed 'd' to 'data' for clarity\n            self.ancestors = set()  # Changed 'a' to 'ancestors' for clarity\n            self.ancestors.add(value)  # Self-explanatory\n            self.child = None  # Changed 'b' to 'child' for clarity\n\n        def connect(self, id):  # Renamed 'c' to 'connect' for clarity\n            descendant = self.find(id)  # Changed 'j' to 'descendant' for clarity\n            descendant.child = self.child  # Changed 'b' to 'child' for clarity\n            self.child = descendant  # Changed 'b' to 'child' for clarity\n\n        def add_ancestor(self, ancestor):  # Renamed 'e' to 'add_ancestor' for clarity\n            self.ancestors.add(ancestor)  # Self-explanatory\n\n        def remove_ancestor(self, ancestor):  # Renamed 'i' to 'remove_ancestor' for clarity\n            self.ancestors.remove(ancestor)  # Self-explanatory\n\n    class Node:  # Renamed 'f' to 'Node' to reflect its purpose\n        def __init__(self, value):  # Changed 'd' to 'self' and 'b' to 'value' for clarity\n            self.data = value  # Changed 'b' to 'data' for clarity\n            self.index = T.count  # Changed 'a' to 'index' for clarity\n            T.count += 1  # Self-explanatory\n            self.child = None  # Changed 'b' to 'child' for clarity\n   \ndef add_to_mapping(process, item):  # Renamed 'b' to 'add_to_mapping' for clarity\n    if item not in process.mapping:  # Self-explanatory\n        process.mapping[item] = T.Element(item)  # Self-explanatory\n    process.mapping[item].connect(item)  # Self-explanatory\n\ndef get_top_ancestors(process, item):  # Renamed 'g' to 'get_top_ancestors' for clarity\n    result = []  # Changed 'x' to 'result' for clarity\n    if item not in process.mapping:  # Self-explanatory\n        return result  # Self-explanatory\n    ancestors = process.mapping[item].ancestors  # Changed 'v' to 'ancestors' for clarity\n    sorted_results = []  # Changed 'z' to 'sorted_results' for clarity\n\n    for ancestor in ancestors:  # Changed 'k' to 'ancestor' for clarity\n        if ancestor in process.mapping:  # Self-explanatory\n            child_node = process.mapping[ancestor].child  # Changed 'r' to 'child_node' for clarity\n            if child_node is not None:  # Changed '!= None' to 'is not None' for clarity\n                sorted_results.append(child_node)  # Self-explanatory\n\n    sorted_results.sort(key=lambda element: element.index, reverse=True)  # Changed 'e' to 'element' for clarity\n    count = 0  # Changed 'u' to 'count' for clarity\n\n    while len(sorted_results) > 0 and count < 10:  # Self-explanatory\n        child_node = sorted_results.pop(0)  # Changed 'r' to 'child_node' for clarity\n        result.append(child_node.data)  # Changed 'b' to 'data' for clarity\n        count += 1  # Self-explanatory\n        if child_node.data is not None:  # Changed '!= None' to 'is not None' for clarity\n            sorted_results.append(child_node.data)  # Changed 'b' to 'data' for clarity\n            sorted_results.sort(key=lambda element: element.index, reverse=True)  # Changed 'e' to 'element' for clarity\n\n    return result  # Self-explanatory\n\ndef link_elements(process, parent, child):  # Renamed 'd' to 'link_elements' for clarity\n    if parent not in process.mapping:  # Self-explanatory\n        process.mapping[parent] = T.Element(parent)  # Self-explanatory\n    if child not in process.mapping:  # Self-explanatory\n        process.mapping[child] = T.Element(child)  # Self-explanatory\n    process.mapping[parent].add_ancestor(child)  # Self-explanatory\n\ndef disconnect_elements(process, parent, child):  # Renamed 'a' to 'disconnect_elements' for clarity\n    if parent not in process.mapping or parent == child:  # Self-explanatory\n        return  # Self-explanatory\n    process.mapping[parent].remove_ancestor(child)  # Self-explanatory\n```",
    "Conversation": [
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Coding Styles] Dislikes Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.",
        "User: I want to refactor this code. I dislike how it uses single-letter variable names like 'g', 'w', 'd', 'b', and they seem far from descriptive. It hurts readability, which I value highly in coding style.",
        "Assistant: I recommend renaming those single-letter variables to more descriptive names. For example, we can use 'self' instead of 'g', 'elem' instead of 'w', 'data' instead of 'd', and 'child' instead of 'b'. This will enhance readability.",
        "Assistant: Here\u2019s the modified code:",
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Coding Styles] Likes Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.",
        "User: Thank you for that. I feel stripping away the single-letter names improves the code. However, I also require functions and classes to have clearer names. For example, 't', 'e', 'f' should be more descriptive like 'Process', 'Element', and 'Node'.",
        "Assistant: I can certainly help with that. Let's rename 't' to 'Process', 'e' to 'Element', and 'f' to 'Node'. This produces a much clearer structure for anyone reading the code.",
        "Assistant: The updated code would look like this:",
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Coding Styles] Likes Extensive commenting and documentation to explain complex logic and historical references in code.",
        "User: I appreciate that. However, I also wish to see more comments and documentation to ensure readers comprehend what each part of the code does, especially since it handles complex relationships.",
        "Assistant: Adding comprehensive comments and docstrings will certainly improve the maintainability of the code. Let's include docstrings for all classes and functions as well as additional inline comments.",
        "Assistant: Here's the revised code:",
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Coding Styles] Likes Extensive commenting and documentation to explain complex logic and historical references in code.",
        "User: This is a great improvement. The added comments help contextualize the code better. Still, I have concerns about certain formatting styles. I noticed the indentation seems inconsistent in places. I like to follow consistent indentation standards, ideally using 4 spaces.",
        "Assistant: I agree with your preference for consistent indentation. Let's ensure we have 4 spaces for indentation across all lines to maintain a clean and readable format.",
        "Assistant: The adjusted code now looks like this:",
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Formatting Styles] Likes Consistent indentation of 4 spaces for block structures to enhance visual clarity.",
        "User: Thank you, the indentation looks perfect now. It's a much easier read. Lastly, I want to check that the lines do not exceed 79 characters, as this is very important to me for readability across devices.",
        "Assistant: That\u2019s a good point. I\u2019ll review the code and ensure that no line exceeds the 79-character limit. Lines that need breaking will be split appropriately.",
        "Assistant: Here is the final version ensuring we maintain the character limit:",
        "[Original_Code]: class t:\n c=0\n def __init__(g):\n  g.m={}\n class e:\n  def __init__(w,a):\n   w.d=a\n   w.a=set()\n   w.a.add(a)\n   w.b=None\n  def c(w,id):\n   j=w.f(id)\n   j.b=w.b\n   w.b=j\n  def e(x,y):\n   x.a.add(y)\n  def i(x,y):\n   x.a.remove(y)\n class f:\n  def __init__(d,b):\n   d.b=b\n   d.a=t.c\n   t.c+=1\n   d.b=None\n def b(p,f):\n  if f not in p.m:\n   p.m[f]=t.e(f)\n  p.m[f].c(f)\n def g(y,f):\n  x=[]\n  if f not in y.m:\n   return x\n  v=y.m[f].a\n  z=[]\n  for k in v:\n   if k in y.m:\n    r=y.m[k].b\n    if r!=None:\n     z.append(r)\n  z.sort(key=lambda e:e.a,reverse=True)\n  u=0\n  while len(z)>0 and u<10:\n   r=z.pop(0)\n   x.append(r.b)\n   u+=1\n   if r.b!=None:\n    z.append(r.b)\n    z.sort(key=lambda e:e.a,reverse=True)\n  return x\n def d(q,u,i):\n  if u not in q.m:\n   q.m[u]=t.e(u)\n  if i not in q.m:\n   q.m[i]=t.e(i)\n  q.m[u].e(i)\n def a(v,u,i):\n  if u not in v.m or u==i:\n   return\n  v.m[u].i(i)",
        "[Side_Note]: [Formatting Styles] Likes Limiting line length to 79 characters for better readability on various displays.",
        "User: The final code looks wonderful! Thank you for all the modifications, especially breaking long lines and renaming variables and functions to meaningful names. It speaks to the clarity I strive for in my work.",
        "Assistant: You're welcome! I'm glad I could help you achieve your coding style and formatting preferences. If you need anything else or further adjustments, feel free to ask!"
    ],
    "Q&A": {
        "Conversation": [
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyzes a list of documents related to the Eastern Wu period, extracting \n    key socio-political themes and events.\n\n    Parameters:\n    documents (list of str): A list containing textual content of historical documents.\n\n    Returns:\n    dict: A dictionary where keys are document titles and values are summaries of significant themes.\n    \"\"\"\n    analysis = {}\n    \n    for document in documents:\n        try:\n            title, content = parse_document(document)\n            summary = summarize_research(content)\n            analysis[title] = summary\n            \n        except ValueError as e:\n            # Log an error if the document format is unexpected\n            print(f\"Error processing document: {e}\")\n            \n    return analysis\n\ndef parse_document(document):\n    \"\"\"\n    Parses a document string into its title and content.\n\n    Parameters:\n    document (str): The document text, which includes the title and the body.\n\n    Returns:\n    tuple: A tuple containing the title of the document and its content.\n    \"\"\"\n    # Simulated parsing logic\n    try:\n        split_index = document.index('\\n')\n        title = document[:split_index].strip()\n        content = document[split_index+1:].strip()\n        return title, content\n    except Exception as e:\n        raise ValueError(\"Document format is incorrect.\") from e\n\ndef summarize_research(content):\n    \"\"\"\n    Summarizes the content of a document, focusing on socio-political themes.\n\n    Parameters:\n    content (str): The main body of the document text.\n\n    Returns:\n    str: A brief summary of the document's socio-political content.\n    \"\"\"\n    # Placeholder logic for summarizing content\n    return \"Summary of the document's socio-political themes.\"\n\n# Example usage\ndocuments = [\n    \"Document Title 1\\nThis is the content of the first document discussing various topics.\",\n    \"Document Title 2\\nContent of the second document detailing events in Eastern Wu.\"\n]\n\nanalysis_results = analyze_eastern_wu_documents(documents)\nfor title, summary in analysis_results.items():\n    print(f\"{title}: {summary}\")\n```",
                "Incorrect_Answers": [
                    "```python\ndef calculate_flight_velocity(distance, time):\n    \"\"\"\n    Calculate the velocity of a flight.\n    \n    Parameters:\n    distance (float): The distance traveled by the aircraft in kilometers.\n    time (float): The time taken to travel the distance in hours.\n    \n    Returns:\n    float: The calculated velocity in kilometers per hour.\n    \"\"\"\n    try:\n        # Calculate velocity using the formula velocity = distance / time\n        velocity = distance / time\n        return velocity\n    except ZeroDivisionError:\n        # Handle the case where time is zero to avoid division by zero\n        return 0.0\n\ndef main():\n    # List of (distance, time) pairs for flights\n    flight_data = [\n        (1500, 2.5),\n        (0, 0),  # Example where time is zero\n        (750, 1.5)\n    ]\n    \n    # Retrieve and print velocity for each flight data pair\n    for flight in flight_data:\n        distance, time = flight\n        velocity = calculate_flight_velocity(distance, time)\n        print(\"Calculated velocity for flight: {:.2f} km/h\".format(velocity))\n\nif __name__ == '__main__':\n    main()\n```",
                    "```python\nimport sys  # Standard library import\nfrom my_module import fetch_player_data, calculate_win_percentage  # Specific imports from local module\n\ndef main():\n    \"\"\"\n    Main function to fetch player data and calculate the win percentage.\n    Handles exceptions for robust execution.\n    \"\"\"\n    try:\n        # Fetch player game statistics from the database\n        player_stats = fetch_player_data('football_team')\n        \n        # Calculate team's win percentage\n        win_percentage = calculate_win_percentage(player_stats)\n        \n        # Output the calculated win percentage\n        # Ensuring to output readable results\n        print(f\"Win Percentage: {win_percentage:.2f}%\")\n    \n    except ValueError as e:\n        # Log error to stderr, maintaining program stability\n        print(f\"Value Error: {e}\", file=sys.stderr)\n    except Exception as e:\n        # Catch-all for unexpected errors\n        print(f\"An unexpected error occurred: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nfrom math import sqrt, pi\nimport random\n\n# Custom module for generating graphics\nimport graphics\n\ndef calculate_circle_area(radius):\n    \"\"\"Calculate the area of a circle given its radius.\"\"\"\n    try:\n        area = pi * (radius ** 2)\n        return area\n    except TypeError as e:\n        print(f\"Error calculating area: {e}\")\n        return None\n\ndef generate_random_color():\n    \"\"\"Generate a random color represented in RGB format.\"\"\"\n    return random.choice(['#FF5733', '#33FF57', '#3357FF'])\n\ndef create_design(num_circles, max_radius):\n    \"\"\"Create a design by drawing circles with random colors and positions.\"\"\"\n    circles = [\n        create_circle(random.uniform(0, max_radius), generate_random_color()) \n        for _ in range(num_circles)\n    ]\n    return circles\n\ndef create_circle(radius, color):\n    \"\"\"Create a circle graphic with given radius and color.\"\"\"\n    area = calculate_circle_area(radius)\n    \n    # Check if the area is valid before proceeding\n    if area is not None:\n        # The following line simulates rendering a circle on a canvas using external graphics module\n        graphics.draw_circle(radius, color)\n    \n    return {'radius': radius, 'color': color, 'area': area}\n\ndef main():\n    \"\"\"Main function to execute the design creation process.\"\"\"\n    \n    # Number of circles and maximum possible radius\n    num_circles, max_radius = 5, 50\n    \n    # Generate and store design\n    design = create_design(num_circles, max_radius)\n\n    # Output design information\n    for circle in design:\n        # Print each circle's details\n        print(f\"Circle - Radius: {circle['radius']},\" +\n              f\" Color: {circle['color']},\" +\n              f\" Area: {circle['area']}\")\n\n# Execute the main function\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyze a list of documents related to the Eastern Wu period.\n\n    Parameters:\n    documents (list of str): A list of document strings to be analyzed.\n\n    Returns:\n    analysis_report (dict): A report containing the summary and \n                            insights extracted from the documents.\n    \"\"\"\n    try:\n        parsed_documents = [parse_document(doc) for doc in documents]\n        insights = [summarize_research(doc) for doc in parsed_documents]\n        \n        analysis_report = {\n            'total_documents': len(documents),\n            'insights': insights\n        }\n        return analysis_report\n    except Exception as e:\n        # Handle any potential issues that arise during document analysis\n        print(f\"An error occurred during document analysis: {e}\")\n        return {}\n\ndef parse_document(document):\n    \"\"\"\n    Parse a single document to extract relevant details.\n\n    Parameters:\n    document (str): A document string to be parsed.\n\n    Returns:\n    parsed_data (dict): A dictionary containing parsed data from the document.\n    \"\"\"\n    # Implement parsing logic here. This is a placeholder example.\n    parsed_data = {\n        'date': 'Unknown',\n        'author': 'Anonymous',\n        'content_length': len(document)\n    }\n    return parsed_data\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Summarize research insights from parsed document data.\n\n    Parameters:\n    parsed_data (dict): Data parsed from a document.\n\n    Returns:\n    summary (dict): A summary of insights derived from the parsed data.\n    \"\"\"\n    # Implement summary logic here. This is a placeholder example.\n    summary = {\n        'key_findings': 'N/A',\n        'historical_context': 'N/A'\n    }\n    return summary\n\n# Organized imports are assumed at the start of the file\n```",
                "Incorrect_Answers": [
                    "```python\n# Importing necessary standard library functions\nimport math\nimport statistics\n\n# Importing third-party libraries, if any\n# e.g., import numpy as np\n\n# Importing local application/library specific\n# imports, if any\n\ndef calculate_win_percentage(wins, total_games):\n    \"\"\"\n    Calculate the win percentage based on the number of wins and total games.\n    \n    Args:\n        wins (int): The number of games the team has won.\n        total_games (int): The total number of games the team has played.\n        \n    Returns:\n        float: The win percentage as a floating-point number.\n    \"\"\"\n    try:\n        win_percentage = (wins / total_games) * 100\n        return win_percentage\n    except ZeroDivisionError:\n        print(\"Error: The total number of games must be greater than zero.\")\n        return None\n\ndef fetch_player_data(player_name):\n    \"\"\"\n    Fetch data for a specific player by their name.\n\n    Args:\n        player_name (str): The name of the player to fetch data for.\n\n    Returns:\n        dict: A dictionary containing player data, such as stats and bio.\n    \"\"\"\n    # Simulating a data fetch - in practice, this might hit an API or a database\n    player_data = {\n        \"name\": player_name,\n        \"position\": \"Quarterback\",\n        \"touchdowns\": 30,\n        \"interceptions\": 10\n    }\n    return player_data\n\ndef calculate_average(statistics_list):\n    \"\"\"\n    Calculate the average of a list of statistics.\n\n    Args:\n        statistics_list (list): A list containing numerical statistics.\n\n    Returns:\n        float: The average value of the provided statistics list.\n    \"\"\"\n    if not statistics_list:\n        print(\"Error: Statistics list is empty.\")\n        return None\n\n    average_value = statistics.mean(statistics_list)\n    return average_value\n\n# Example usage of functions\nteam_wins = 8\nteam_total_games = 10\nwin_pct = calculate_win_percentage(team_wins, team_total_games)\nif win_pct is not None:\n    print(f\"Team Win Percentage: {win_pct:.2f}%\")\n\nplayer_data = fetch_player_data(\"John Doe\")\nprint(\"Player Information:\", player_data)\n\nstats = [100, 200, 300, 400, 500]\naverage_stat = calculate_average(stats)\nif average_stat is not None:\n    print(f\"Average Stat: {average_stat:.2f}\")\n```",
                    "```python\nfrom typing import List\n\nclass Extremophile:\n    def __init__(self, name: str, habitat: str, survival_traits: List[str]):\n        \"\"\"\n        Initializes an Extremophile object.\n\n        :param name: The name of the extremophile organism.\n        :param habitat: The natural habitat where the extremophile is found.\n        :param survival_traits: A list of traits that enable survival in extreme conditions.\n        \"\"\"\n        self.name = name\n        self.habitat = habitat\n        self.survival_traits = survival_traits\n\ndef filter_extremophiles(data: List[Extremophile]) -> List[Extremophile]:\n    \"\"\"\n    Filters a list of organisms, returning only those that are extremophiles.\n\n    :param data: A list of Extremophile objects to be filtered.\n    :returns: A filtered list containing only extremophiles.\n    \"\"\"\n    return [organism for organism in data if 'extreme' in organism.survival_traits]\n\ndef print_extremophile_info(extremophiles: List[Extremophile]) -> None:\n    \"\"\"\n    Prints detailed information about each extremophile in the list.\n\n    :param extremophiles: A list of Extremophile objects for detailed information output.\n    \"\"\"\n    for org in extremophiles:\n        # Detailed printout explaining the significance of each extremophile\n        print(f\"Name: {org.name}\")\n        print(f\"Habitat: {org.habitat}\")\n        print(f\"Survival Traits: {', '.join(org.survival_traits)}\")\n        print(\"-\" * 40)\n\ndef main():\n    \"\"\"\n    Main function for executing extremophile operations.\n    \"\"\"\n    try:\n        # Sample data setup\n        organisms = [\n            Extremophile(\"Thermus aquaticus\", \"Hot Springs\", [\"extreme heat\", \"thermostable enzymes\"]),\n            Extremophile(\"Haloferax volcanii\", \"Salt Flats\", [\"extreme salinity\"]),\n            Extremophile(\"Deinococcus radiodurans\", \"Radioactive Sites\", [\"radiation resistance\", \"extreme\"])\n        ]\n\n        # Filtering and printing extremophiles\n        extremophiles = filter_extremophiles(organisms)\n        print_extremophile_info(extremophiles)\n\n    except Exception as error:\n        print(f\"An error occurred: {error}\")\n\nif __name__ == '__main__':\n    main()\n```",
                    "```python\n\"\"\"\nModule to showcase Alex's coding and formatting style preferences.\n\"\"\"\n\nfrom typing import List, Tuple\n\ndef calculate_average(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the average of a list of numbers.\n    \n    This function demonstrates using simple and descriptive naming,\n    concise comments, and built-in functions for simplicity.\n    \"\"\"\n    try:\n        # Return the sum and divide by the count of numbers\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:\n        return 'Error: Cannot divide by zero'\n\ndef find_min_max(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Find the minimum and maximum values in a list of numbers.\n    \n    Demonstrates the use of built-in min and max functions.\n    \"\"\"\n    if not numbers:\n        return 'Error: List is empty', 'Error: List is empty'\n    \n    return min(numbers), max(numbers)\n\ndef document_hike(hike_name: str, photos: List[str]) -> str:\n    \"\"\"\n    Generate a summary for a hiking trip given the name and photos.\n    \n    This function combines Alex's love for hiking, photography, and programming.\n    \"\"\"\n    # Return formulated string with hike info and photos count\n    return f\"The hike '{hike_name}' includes {len(photos)} photos documenting the adventure.\"\n\n# Example of organized imports and module-level docstring at the top\n# Functions are separated with blank lines for clarity\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyzes a list of documents related to the Eastern Wu period of ancient China.\n\n    This function processes each document, extracting relevant historical information and \n    summarizing the socio-political structures described within.\n\n    Args:\n        documents (list): A list of strings, each representing a document to be analyzed.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains the analysis of a document.\n    \"\"\"\n    analysis_results = []\n    \n    try:\n        for doc in documents:\n            document_data = parse_document(doc)\n            if document_data is not None:\n                summary = summarize_research(document_data)\n                analysis_results.append(summary)\n            else:\n                # Logging could be added here if needed\n                continue\n    except Exception as e:\n        # Exception handling to catch any unexpected errors during document processing\n        print(f\"An error occurred while analyzing documents: {e}\")\n    \n    return analysis_results\n\ndef parse_document(document):\n    \"\"\"\n    Parses the content of a document and extracts historical data.\n\n    Args:\n        document (str): The document text to parse.\n\n    Returns:\n        dict: Parsed historical data, or None if the document is empty or invalid.\n    \"\"\"\n    if not document:\n        return None\n    \n    # Simulate processing and return a dummy structure for demonstration\n    parsed_data = {\n        'title': 'Dummy title',\n        'content': 'Extracted historical content related to Eastern Wu.',\n        'date': '222-280 AD'\n    }\n    return parsed_data\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Summarizes the research findings from parsed document data.\n\n    Args:\n        parsed_data (dict): The parsed historical data.\n\n    Returns:\n        dict: A summary of critical research findings.\n    \"\"\"\n    # Creating a summary based on parsed data\n    summary = {\n        'title': parsed_data['title'],\n        'summary': f\"Summarized content based on extracted information: {parsed_data['content']}\"\n    }\n    return summary\n```\n",
                "Incorrect_Answers": [
                    "```python\nfrom typing import List, Optional\n\nclass Extremophile:\n    def __init__(self, name: str, environment: str, survival_temperature: float):\n        \"\"\"Initialize an extremophile with a name, environment, and survival temperature.\n\n        Args:\n            name (str): The common or scientific name of the extremophile.\n            environment (str): The typical environment where the extremophile is found.\n            survival_temperature (float): The maximum temperature the extremophile can withstand.\n        \"\"\"\n        self.name = name\n        self.environment = environment\n        self.survival_temperature = survival_temperature\n\ndef filter_extremophiles(data: List[Extremophile], min_temperature: float) -> List[Extremophile]:\n    \"\"\"Filter extremophiles based on minimum survival temperature.\n\n    Args:\n        data (List[Extremophile]): A list of extremophile instances.\n        min_temperature (float): The minimum survival temperature for the filter criteria.\n\n    Returns:\n        List[Extremophile]: A list of extremophiles that can survive above the specified temperature.\n    \"\"\"\n    return [organism for organism in data if organism.survival_temperature > min_temperature]\n\ndef print_extremophile_info(extremophiles: List[Extremophile]) -> None:\n    \"\"\"Print the details of each extremophile in a formatted manner.\n\n    Args:\n        extremophiles (List[Extremophile]): A list of extremophiles to print information about.\n    \"\"\"\n    for organism in extremophiles:\n        # Print details of each extremophile\n        print(f\"Name: {organism.name}, Environment: {organism.environment}, \"\n              f\"Survival Temperature: {organism.survival_temperature} \u00b0C\")\n\ndef main(extremophile_data: Optional[List[Extremophile]] = None) -> None:\n    \"\"\"Main function to execute Extremophile filtering and display.\n\n    Args:\n        extremophile_data (Optional[List[Extremophile]]): A list of extremophiles to process.\n            Defaults to None to use sample data.\n    \"\"\"\n    if extremophile_data is None:\n        extremophile_data = [\n            Extremophile(name='Thermus aquaticus', environment='Hot Springs', survival_temperature=70.0),\n            Extremophile(name='Pyrolobus fumarii', environment='Hydrothermal Vents', survival_temperature=113.0)\n        ]\n\n    filtered_extremophiles = filter_extremophiles(extremophile_data, min_temperature=80.0)\n    print_extremophile_info(filtered_extremophiles)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n# Import necessary modules for the task\nimport datetime\nimport requests\n\n# A Python module to handle football team statistics\n\ndef fetch_team_data(team_id):\n    \"\"\"\n    Fetches data for a specified team using its unique team ID.\n    \n    Args:\n    team_id (int): Unique identifier for the team.\n\n    Returns:\n    dict: A dictionary containing team information.\n    \"\"\"\n    try:\n        url = f'http://api.sportsdata.io/v3/football/scores/json/Team/{team_id}'\n        response = requests.get(url)\n        response.raise_for_status()  # Ensure we notice bad responses\n        return response.json()\n    except requests.exceptions.HTTPError as e:\n        print(f\"HTTP error occurred: {e}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Request exception: {e}\")\n    return {}\n\ndef calculate_win_percentage(games_won, total_games):\n    \"\"\"\n    Calculates the winning percentage for a team.\n\n    Args:\n    games_won (int): The number of games won by the team.\n    total_games (int): The total number of games played by the team.\n\n    Returns:\n    float: The win percentage as a float rounded to two decimals.\n    \"\"\"\n    try:\n        if total_games <= 0:\n            raise ValueError(\"Total games must be greater than zero.\")\n        win_percentage = (games_won / total_games) * 100\n        return round(win_percentage, 2)\n    except ValueError as ve:\n        print(f\"Value error: {ve}\")\n    return 0.0\n\ndef main():\n    \"\"\"\n    Main function to execute the football team statistics processing.\n    \"\"\"\n    team_id = 123  # Example team ID\n    team_data = fetch_team_data(team_id)\n    \n    games_won = team_data.get('Wins', 0)\n    total_games = team_data.get('GamesPlayed', 0)\n    \n    win_percentage = calculate_win_percentage(games_won, total_games)\n    print(f\"The team's win percentage is: {win_percentage}%\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n# Module for calculating and printing sustainability metrics for events\nimport json\nfrom typing import List, Dict\n\ndef calculate_carbon_footprint(event_data: List[Dict]) -> float:\n    \"\"\"\n    Calculate the total carbon footprint for a list of events.\n\n    :param event_data: List of dictionaries containing event information\n    :return: Total carbon footprint as a float\n    \"\"\"\n    total_footprint = 0.0\n    for event in event_data:\n        try:\n            total_footprint += event['participants'] * event['average_transport_footprint']\n        except KeyError:\n            # Skip events with incomplete data\n            continue\n    return total_footprint\n\n\ndef get_eco_friendly_events(events: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Filter and return a list of eco-friendly events.\n\n    :param events: List of dictionaries containing event information\n    :return: A list of dictionaries including only eco-friendly events\n    \"\"\"\n    return [event for event in events if event.get('eco_friendly', False)]\n\n\ndef display_event_metrics(events_json: str):\n    \"\"\"\n    Parse the events JSON string, calculate metrics, and print the results.\n\n    :param events_json: A JSON string representing a list of events\n    \"\"\"\n    try:\n        events = json.loads(events_json)\n    except json.JSONDecodeError as e:\n        print(\"Error decoding JSON: \", str(e))\n        return\n\n    eco_friendly_events = get_eco_friendly_events(events)\n\n    print(\"Total Events: \", len(events))\n    print(\"Eco-friendly Events: \", len(eco_friendly_events))\n    print(\"Total Carbon Footprint: {:.2f}\".format(calculate_carbon_footprint(events)))\n\n\nif __name__ == \"__main__\":\n    sample_events_json = '''\n    [\n        {\"name\": \"Grand Tournament\", \"participants\": 300, \"average_transport_footprint\": 10.5, \"eco_friendly\": true},\n        {\"name\": \"Annual Game Con\", \"participants\": 150, \"average_transport_footprint\": 8.0, \"eco_friendly\": false},\n        {\"name\": \"Green Gamer Meetup\", \"participants\": 50, \"average_transport_footprint\": 5.0, \"eco_friendly\": true}\n    ]\n    '''\n    display_event_metrics(sample_events_json)\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n\"\"\"\nModule: Eastern Wu Historical Analysis\n\nThis module contains functions to analyze historical texts from the Eastern Wu period\nand summarize key socio-political elements. Designed with readability and clarity in mind.\n\"\"\"\n\ndef parse_document(document_text):\n    \"\"\"\n    Parses the given Eastern Wu historical document text and returns structured data.\n    \n    Parameters:\n    document_text (str): The text of the historical document to parse.\n    \n    Returns:\n    dict: A dictionary containing parsed information, such as titles and main points.\n    \"\"\"\n    try:\n        structured_data = {}\n        # Implementation detail: assume a simple split for demonstration purposes.\n        lines = document_text.split('\\n')\n        structured_data['title'] = lines[0]\n        structured_data['main_points'] = lines[1:]\n        return structured_data\n    except Exception as e:\n        print(f\"Error parsing document: {e}\")\n        return {}\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Summarizes key socio-political elements from parsed Eastern Wu data.\n    \n    Parameters:\n    parsed_data (dict): Structured data from a parsed Eastern Wu document.\n    \n    Returns:\n    str: A summary of the socio-political elements discovered in the document.\n    \"\"\"\n    try:\n        title = parsed_data.get('title', 'Unknown Title')\n        main_points = parsed_data.get('main_points', [])\n        summary = f\"Document '{title}' discusses socio-political structures including:\\n\"\n        for point in main_points:\n            summary += f\"- {point}\\n\"\n        return summary\n    except Exception as e:\n        print(f\"Error summarizing research: {e}\")\n        return \"Error in summarizing.\"\n\nif __name__ == \"__main__\":\n    document_text = \"\"\"Eastern Wu Government Structure\n    1. Emphasis on military leadership.\n    2. Strong centralized administration.\n    3. Local governance and autonomy for provinces.\"\"\"\n\n    parsed_data = parse_document(document_text)\n    summary = summarize_research(parsed_data)\n    print(summary)\n```\n",
                "Incorrect_Answers": [
                    "```python\nimport math\nfrom datetime import datetime\n\n# Define constants\nSCREEN_WIDTH = 800\nSCREEN_HEIGHT = 600\n\ndef calculate_distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points.\n    \n    :param x1: x-coordinate of the first point\n    :param y1: y-coordinate of the first point\n    :param x2: x-coordinate of the second point\n    :param y2: y-coordinate of the second point\n    :return: Euclidean distance between the two points\n    \"\"\"\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef render_scene():\n    \"\"\"\n    Render the graphics on the screen.\n    \n    :return: None\n    \"\"\"\n    # Example rendering logic\n    # This is a placeholder for actual rendering code\n    print(\"Rendering the scene...\")\n\ndef handle_user_input():\n    \"\"\"\n    Handle user input to update application state.\n    \n    :return: None\n    \"\"\"\n    # Example input handling\n    # This is a placeholder for user input handling code\n    print(\"Handling user input...\")\n\ndef main_game_loop():\n    \"\"\"\n    Main loop of the game for updating logic and rendering.\n    \n    :return: None\n    \"\"\"\n    running = True\n    while running:\n        try:\n            # Handle user input\n            handle_user_input()\n            \n            # Render the scene\n            render_scene()\n            \n            # Check for termination conditions\n            # For simplicity, we assume running becomes False after one iteration\n            running = False\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    # Start the game\n    print(f\"Game started at {datetime.now()}\")\n    main_game_loop()\n    print(\"Game ended.\")\n```",
                    "```python\nclass EventSustainabilityConsultant:\n    \"\"\"\n    A class to represent a Sustainability Consultant for gaming events.\n\n    Attributes:\n    -----------\n    name : str\n        the name of the consultant.\n    birth_year : int\n        the birth year of the consultant.\n    field : str\n        the specialization field of the consultant.\n    \"\"\"\n\n    def __init__(self, name: str, birth_year: int, field: str = \"Sustainability\") -> None:\n        \"\"\"\n        Constructs all the necessary attributes for the EventSustainabilityConsultant object.\n\n        Parameters:\n        -----------\n        name : str\n            the name of the consultant.\n        birth_year : int\n            the birth year of the consultant.\n        field : str, optional\n            the specialization field of the consultant, by default 'Sustainability'\n        \"\"\"\n        self.name = name\n        self.birth_year = birth_year\n        self.field = field\n\n    @staticmethod\n    def calculate_carbon_footprint(event_data: list) -> float:\n        \"\"\"\n        Calculates the total carbon footprint based on event data.\n\n        Parameters:\n        -----------\n        event_data : list\n            A list of dictionaries with event data including 'attendance' and 'carbon_output'.\n\n        Returns:\n        --------\n        float\n            The calculated carbon footprint for the events.\n        \"\"\"\n        try:\n            return sum(data['attendance'] * data['carbon_output'] for data in event_data)\n        except KeyError as e:\n            print(f\"Missing key in event data: {e}\")\n            return 0.0\n\n    @staticmethod\n    def track_eco_friendly_events(events: list) -> list:\n        \"\"\"\n        Filters out the eco-friendly events from a list of events.\n\n        Parameters:\n        -----------\n        events : list\n            A list of event dictionaries with an 'eco_friendly' boolean key.\n\n        Returns:\n        --------\n        list\n            A list of eco-friendly events.\n        \"\"\"\n        return [event for event in events if event.get('eco_friendly', False)]\n\n```\n",
                    "```python\nimport json\nfrom datetime import datetime\nimport sys\n\ndef log_error(error_message):\n    \"\"\"Log an error message with a timestamp.\"\"\"\n    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    print(f\"{current_time} - ERROR: {error_message}\", file=sys.stderr)\n\ndef read_json_file(file_path):\n    \"\"\"Read and parse a JSON file.\"\"\"\n    try:\n        with open(file_path, 'r') as file:\n            data = json.load(file)\n        return data\n    except FileNotFoundError:\n        log_error(f\"File not found: {file_path}\")\n    except json.JSONDecodeError:\n        log_error(\"Failed to decode JSON from the file\")\n    return None\n\ndef calculate_average(data, key):\n    \"\"\"Calculate the average of a list of numbers in a JSON data structure.\"\"\"\n    numbers = [item.get(key, 0) for item in data if isinstance(item.get(key), (int, float))]\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)\n\ndef main():\n    \"\"\"Main function to read JSON data and print the calculated average.\"\"\"\n    file_path = 'data.json'\n    key_to_average = 'value'\n    \n    data = read_json_file(file_path)\n    if data is not None:\n        average = calculate_average(data, key_to_average)\n        print(f\"The average {key_to_average} is: {average}\")\n\nif __name__ == '__main__':\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport datetime\nfrom typing import List, Dict\n\ndef fetch_documents(start_year: int, end_year: int) -> List[Dict]:\n    \"\"\"\n    Fetch historical documents between the specified years.\n\n    :param start_year: The starting year to retrieve documents from.\n    :param end_year: The ending year to retrieve documents to.\n    :return: A list of dictionaries containing document data.\n    \"\"\"\n    documents = []\n    try:\n        # Simulate database query\n        documents = [\n            {\"title\": \"Eastern Wu Governance\", \"year\": 220, \"content\": \"Analysis of early governance structures...\"},\n            {\"title\": \"Battle Strategies of Eastern Wu\", \"year\": 230, \"content\": \"Tactical development and execution...\"}\n        ]\n        documents = [doc for doc in documents if start_year <= doc['year'] <= end_year]\n    except Exception as e:\n        print(\"Error fetching documents:\", e)\n    return documents\n\ndef summarize_documents(documents: List[Dict]) -> str:\n    \"\"\"\n    Summarize the contents of a list of documents for a brief overview.\n\n    :param documents: A list of dictionaries containing document data to summarize.\n    :return: A string summarizing the contents of the documents.\n    \"\"\"\n    summary = \"\"\n    for doc in documents:\n        try:\n            summary += f\"Title: {doc['title']}\\nYear: {doc['year']}\\nExcerpt: {doc['content'][:50]}...\\n\\n\"\n        except KeyError as e:\n            print(f\"Missing expected key: {e}\")\n    return summary\n\ndef main():\n    \"\"\"\n    Main function to execute document processing for the Eastern Wu Period.\n    \"\"\"\n    current_year = datetime.datetime.now().year\n    start_year = 220\n    end_year = 280\n\n    documents = fetch_documents(start_year=start_year, end_year=current_year)\n    documents_summary = summarize_documents(documents=documents)\n\n    print(\"Eastern Wu Period Documents:\\n\")\n    print(documents_summary)\n\nif __name__ == '__main__':\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\n# team.py\n\nclass Player:\n    \"\"\"\n    A class to represent a player on the team.\n\n    Attributes:\n        name (str): The name of the player.\n        position (str): The position the player holds.\n        stats (dict): A dictionary containing the player's stats.\n    \"\"\"\n    \n    def __init__(self, name: str, position: str):\n        \"\"\"\n        Constructs all the necessary attributes for the player object.\n\n        Parameters:\n            name (str): The name of the player.\n            position (str): The position the player plays.\n        \"\"\"\n        self.name = name\n        self.position = position\n        self.stats = {}\n\n    def update_stats(self, stat_name: str, value: float) -> None:\n        \"\"\"\n        Updates the player's stats with a new value.\n\n        Parameters:\n            stat_name (str): The name of the stat to update.\n            value (float): The new value for the stat.\n        \"\"\"\n        self.stats[stat_name] = value\n\n    def calculate_average_yards_per_game(self, total_yards: int, games_played: int) -> float:\n        \"\"\"\n        Calculates the average yards per game played by the player.\n\n        Parameters:\n            total_yards (int): Total yards covered by the player.\n            games_played (int): Number of games played.\n\n        Returns:\n            float: The average yards per game.\n        \"\"\"\n        try:\n            average = total_yards / games_played\n        except ZeroDivisionError:\n            average = 0\n        return average\n\n# utils.py\n\ndef log_error(message: str) -> None:\n    \"\"\"\n    Logs an error message.\n\n    Parameters:\n        message (str): The error message to log.\n    \"\"\"\n    print(f\"Error: {message}\")\n\n```\n",
                    "```python\nimport math\nfrom datetime import datetime\nfrom my_project.utils import fetch_player_data, calculate_win_percentage\n\ndef calculate_and_log_statistics(team_name, games_played):\n    \"\"\"\n    Calculates the win percentage for a given team and logs the results.\n    \n    :param team_name: str, name of the football team\n    :param games_played: list of dict, list containing game results with keys 'opponent' and 'result'\n    :return: None\n    \"\"\"\n    \n    # Initialize counters for wins and total games\n    total_wins = 0\n    total_games = len(games_played)\n    \n    try:\n        # Calculate total wins from the list of games\n        for game in games_played:\n            if game['result'] == 'win':\n                total_wins += 1\n        \n        # Calculate win percentage using a utility function\n        win_percentage = calculate_win_percentage(total_wins, total_games)\n        \n        # Log the results\n        log_results(team_name, total_games, total_wins, win_percentage)\n        \n    except ValueError as e:\n        print(f\"Error in processing game results: {e}\")\n\ndef log_results(team_name, total_games, total_wins, win_percentage):\n    \"\"\"\n    Logs the calculated statistics for a team.\n    \n    :param team_name: str, name of the football team\n    :param total_games: int, total number of games played\n    :param total_wins: int, total number of games won\n    :param win_percentage: float, calculated win percentage\n    :return: None\n    \"\"\"\n    \n    print(f\"Statistics for {team_name}:\")\n    print(f\"Total games: {total_games}\")\n    print(f\"Total wins: {total_wins}\")\n    print(f\"Win percentage: {win_percentage:.2f}%\")\n\n# Example usage\nif __name__ == '__main__':\n    team_games = [{'opponent': 'Team A', 'result': 'win'},\n                  {'opponent': 'Team B', 'result': 'loss'},\n                  {'opponent': 'Team C', 'result': 'win'}]\n    \n    calculate_and_log_statistics('MyFavoriteTeam', team_games)\n```",
                    "```python\n# Importing required modules\nimport math\nimport random\nfrom datetime import datetime\n\n# Local import\nfrom my_utils import get_color_palette\n\ndef calculate_score(player_actions):\n    \"\"\"Calculate player's score based on actions.\"\"\"\n    score = 0\n    # Loop through each action\n    for action in player_actions:\n        # Add points based on action type\n        if action == 'collect':\n            score += 10\n        elif action == 'defeat_enemy':\n            score += 50\n        elif action == 'level_up':\n            score += 100\n    return score\n\ndef get_random_color_palette():\n    \"\"\"Return a random color palette.\"\"\"\n    colors = get_color_palette()\n    return [random.choice(colors) for _ in range(5)]\n\ndef display_game_over_message():\n    \"\"\"Display a game over message to the player.\"\"\"\n    print(\"Game Over! Thank you for playing.\")\n\ndef main():\n    \"\"\"Main function to run the game logic.\"\"\"\n    player_actions = ['collect', 'defeat_enemy', 'level_up']\n    try:\n        player_score = calculate_score(player_actions)\n        print(f\"Player Score: {player_score}\")\n    except Exception as e:\n        print(f\"An error occurred while calculating score: {e}\")\n\n    try:\n        colors = get_random_color_palette()\n        print(f\"Your color palette: {', '.join(colors)}\")\n    except Exception as e:\n        print(f\"An error occurred while retrieving colors: {e}\")\n\n    # Display game over at the end of the game.\n    display_game_over_message()\n\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List\n\ndef parse_document(content: str) -> List[str]:\n    \"\"\"\n    Parses the given historical document content, returning a list of\n    sentences that are found within the content.\n\n    Parameters:\n    content (str): The text content of the document to be parsed.\n\n    Returns:\n    List[str]: A list of sentences extracted from the document.\n    \"\"\"\n    # Split the content into sentences based on periods followed by a space\n    sentences = content.split('. ')\n    return sentences\n\ndef summarize_research(sentences: List[str], max_sentences: int = 5) -> str:\n    \"\"\"\n    Summarizes the provided list of sentences by selecting a specified number\n    of key sentences from the beginning.\n\n    Parameters:\n    sentences (List[str]): A list of sentences to summarize.\n    max_sentences (int): The maximum number of sentences to include in the summary.\n\n    Returns:\n    str: A summary of the research as a single string containing key sentences.\n    \n    Raises:\n    ValueError: If max_sentences is less than 1.\n    \"\"\"\n    if max_sentences < 1:\n        raise ValueError(\"max_sentences must be at least 1\")\n\n    # Select the first 'max_sentences' number of sentences for summary\n    summary_sentences = sentences[:max_sentences]\n    summary = '. '.join(summary_sentences)\n    # Ensure the summary ends with a period if necessary\n    if not summary.endswith('.'):\n        summary += '.'\n    return summary\n\ndef analyze_eastern_wu_documents(texts: List[str]) -> List[str]:\n    \"\"\"\n    Analyzes a collection of Eastern Wu historical documents, providing a summarized\n    version of each document.\n\n    Parameters:\n    texts (List[str]): A list of document strings to analyze.\n\n    Returns:\n    List[str]: A list of summaries for the provided documents.\n    \"\"\"\n    summaries = []\n    for text_index, text in enumerate(texts):  # Enumerating for error tracking\n        try:\n            sentences = parse_document(text)\n            summary = summarize_research(sentences)\n            summaries.append(summary)\n        except Exception as e:\n            print(f\"An error occurred while processing document {text_index}: {e}\")\n    return summaries\n```",
                "Incorrect_Answers": [
                    "```python\nfrom typing import List, Dict\n\ndef calculate_win_percentage(total_games: int, won_games: int) -> float:\n    \"\"\"\n    Calculate the win percentage for the team.\n\n    Args:\n        total_games (int): Total number of games played.\n        won_games (int): Total number of games won.\n\n    Returns:\n        float: The win percentage.\n    \n    Raises:\n        ValueError: If total_games is zero, to avoid division by zero.\n    \"\"\"\n    try:\n        if total_games == 0:\n            raise ValueError(\"Total games cannot be zero when calculating win percentage.\")\n        win_percentage = (won_games / total_games) * 100\n        return win_percentage\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return 0.0\n\ndef fetch_player_data(player_id: int) -> Dict[str, str]:\n    \"\"\"\n    Fetch data for a given player.\n\n    Args:\n        player_id (int): The ID of the player whose data is to be fetched.\n\n    Returns:\n        dict: Player data including name and position.\n    \"\"\"\n    # Simulating player data retrieval\n    player_data = {\n        1: {\"name\": \"John Doe\", \"position\": \"Quarterback\"},\n        2: {\"name\": \"Jane Smith\", \"position\": \"Running Back\"}\n    }\n\n    return player_data.get(player_id, {\"name\": \"Unknown\", \"position\": \"Unknown\"})\n\ndef print_team_statistics(total_games: int, won_games: int, player_id_list: List[int]) -> None:\n    \"\"\"\n    Print the overall team statistics including win percentage and player data.\n\n    Args:\n        total_games (int): Total number of games played.\n        won_games (int): Total number of games won.\n        player_id_list (List[int]): List of player IDs to display data for.\n\n    Returns:\n        None\n    \"\"\"\n    # Calculate and display the win percentage\n    win_percentage = calculate_win_percentage(total_games, won_games)\n    print(f\"Win Percentage: {win_percentage:.2f}%\")\n\n    # Fetch and display player data\n    for player_id in player_id_list:\n        player_data = fetch_player_data(player_id)\n        print(f\"Player ID: {player_id}, Name: {player_data['name']}, Position: {player_data['position']}\")\n\n# Example usage\ntotal_games_played = 10\ngames_won = 7\nplayers = [1, 2]\n\nprint_team_statistics(total_games_played, games_won, players)\n```",
                    "```python\ndef get_aircraft_speed(distance, time):\n    \"\"\"\n    Calculate the speed of an aircraft given the distance traveled and the time taken.\n\n    Parameters:\n    distance (float): The distance traveled in kilometers.\n    time (float): The time taken in hours.\n\n    Returns:\n    float: The speed of the aircraft in kilometers per hour.\n    \"\"\"\n    \n    # Check for valid inputs\n    if time <= 0:\n        raise ValueError(\"Time must be greater than zero to calculate speed.\")\n\n    # Calculate speed\n    speed = distance / time\n    \n    return speed\n\ndef display_speed(distance, time):\n    \"\"\"\n    Retrieve and display the speed of an aircraft.\n\n    Parameters:\n    distance (float): The distance traveled in kilometers.\n    time (float): The time taken in hours.\n    \"\"\"\n    try:\n        speed = get_aircraft_speed(distance, time)\n        # Display calculated speed\n        print(f\"The aircraft's speed is {speed:.2f} km/h.\")  # Rounded to two decimal places\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\ndef main():\n    \"\"\"\n    Main function to execute the program workflow.\n    \"\"\"\n    # Sample data: distance in km, time in hours\n    sample_distance = 500.0\n    sample_time = 2.5\n\n    # Display calculated speed using sample data\n    display_speed(sample_distance, sample_time)\n\n# Organizing imports\nimport sys\n\nif __name__ == \"__main__\":\n    main()\n```\n",
                    "```python\n# This program helps families plan budget-friendly activities by calculating expenses\n# and suggesting activities within a set budget.\n\ndef calculate_expenses(expenses):\n    \"\"\"\n    Calculate the total of given expenses.\n\n    Parameters:\n    expenses (list): A list of individual expense amounts.\n\n    Returns:\n    float: The total sum of the expenses.\n    \"\"\"\n    return sum(expenses)\n\ndef suggest_activities(budget, current_expenses):\n    \"\"\"\n    Suggest activities that fit within the remaining budget.\n\n    Parameters:\n    budget (float): The total budget available for activities.\n    current_expenses (float): The total current expenses.\n\n    Returns:\n    list: A list of suggested activities.\n    \"\"\"\n    remaining_budget = budget - current_expenses\n    \n    # Example list of activities with their costs\n    activities = {\n        \"Picnic in the park\": 10,\n        \"Movie night at home\": 15,\n        \"Board game evening\": 5,\n        \"Local museum visit\": 20\n    }\n    \n    suggestions = [activity for activity, cost in activities.items() if cost <= remaining_budget]\n    return suggestions\n\ndef main():\n    \"\"\"\n    Main function to execute the budgeting program.\n\n    Handles potential input errors to ensure valid numeric entries.\n    \"\"\"\n    try:\n        total_budget = float(input(\"Enter the total budget for family activities: \"))\n        \n        expenses_prompt = \"Enter the expenses separated by commas (e.g., '20, 15.50, 30'): \"\n        expenses_input = input(expenses_prompt)\n        expenses_list = [float(expense.strip()) for expense in expenses_input.split(',')]\n        \n        total_expenses = calculate_expenses(expenses_list)\n        print(f\"Total expenses: {total_expenses:.2f}\")\n        \n        activities = suggest_activities(total_budget, total_expenses)\n        print(\"Suggested activities within budget:\")\n        for activity in activities:\n            print(f\"- {activity}\")\n            \n    except ValueError as e:\n        print(f\"Input error: {e}. Please enter valid numbers.\")\n\n# Imports are typically organized at the beginning of the file.\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nclass EasternWuAnalyzer:\n    \"\"\"\n    A class to analyze documents from the Eastern Wu period.\n    \n    Methods:\n        parse_document(doc: str) -> dict:\n            Parses the document text and returns a dictionary of key findings.\n            \n        summarize_research(parsed_docs: list) -> str:\n            Summarizes the research findings from parsed documents.\n    \"\"\"\n\n    def parse_document(self, doc: str) -> dict:\n        \"\"\"\n        Parses a document from the Eastern Wu period to extract and summarize key findings.\n\n        Parameters:\n            doc (str): The document text to be analyzed.\n\n        Returns:\n            dict: A dictionary containing the key findings from the document.\n        \"\"\"\n        key_findings = {}\n        # Example parsing logic\n        try:\n            # Imagine complex parsing logic here\n            words = doc.split()\n            key_findings['word_count'] = len(words)\n            # Further processing logic...\n        except Exception as error:\n            print(\"An error occurred while parsing the document:\", error)\n\n        return key_findings\n\n    def summarize_research(self, parsed_docs: list) -> str:\n        \"\"\"\n        Summarizes research findings from a list of parsed documents.\n\n        Parameters:\n            parsed_docs (list): A list of dictionaries with parsed document data.\n\n        Returns:\n            str: A summary string of the research findings.\n        \"\"\"\n        summary = \"\"\n        try:\n            total_word_count = sum(doc['word_count'] for doc in parsed_docs)\n            summary = f\"Total word count across documents: {total_word_count}\\n\"\n            # Add further summary details...\n        except KeyError as key_error:\n            print(\"Key error while summarizing research:\", key_error)\n        except Exception as error:\n            print(\"An unexpected error occurred during summarization:\", error)\n\n        return summary\n\n# Example usage\n# analyzer = EasternWuAnalyzer()\n# parsed_doc = analyzer.parse_document(\"Sample Eastern Wu document text.\")\n# summary = analyzer.summarize_research([parsed_doc])\n# print(summary)\n```",
                "Incorrect_Answers": [
                    "```python\n\"\"\"\nModule: wu_history_parser\n\nThis module provides functions to parse and analyze documents related\nto the Eastern Wu period of ancient China. Emphasis is placed on\nbreaking down complex historical data into structured summaries.\n\nAuthor: Dr. Alex Tan\nDate: 2023\n\"\"\"\n\nimport os\nimport sys\n\ndef read_document(file_path):\n    \"\"\"\n    Reads a document from the given file path and returns its content.\n    \n    :param file_path: The path to the document file.\n    :return: Content of the document as a string.\n    :raises FileNotFoundError: If the file does not exist.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            content = file.read()\n        return content\n    except FileNotFoundError as e:\n        print(f\"Error: The file at {file_path} was not found.\", file=sys.stderr)\n        raise e\n\ndef parse_document(content):\n    \"\"\"\n    Parses the content of a document and extracts key historical data.\n    \n    :param content: The content of the document.\n    :return: Parsed data as a dict.\n    \"\"\"\n    # Example: Implement parsing logic here\n    parsed_data = {\n        'title': None,  # Extract the title from the content\n        'date': None,   # Extract the date from the content\n        'details': None # Extract detailed information\n    }\n    # Add parsing steps with comments explaining each step\n    return parsed_data\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Creates a summary of the parsed historical data.\n    \n    :param parsed_data: The parsed data dictionary.\n    :return: A summary as a formatted string.\n    \"\"\"\n    summary = (\n        f\"Title: {parsed_data['title']}\\n\"\n        f\"Date: {parsed_data['date']}\\n\"\n        f\"Details: {parsed_data['details']}\\n\"\n    )\n    return summary\n\nif __name__ == \"__main__\":\n    # Example usage, to be removed or modified in production\n    try:\n        document_path = 'eastern_wu_chronicles.txt'\n        document_content = read_document(document_path)\n        parsed_data = parse_document(document_content)\n        summary = summarize_research(parsed_data)\n        print(summary)\n    except Exception as e:\n        print(\"An error occurred during document processing.\", file=sys.stderr)\n```",
                    "```python\nimport mido\nfrom mido import MidiFile, MidiTrack, Message\n\ndef load_midi(file_path):\n    \"\"\"\n    Load a MIDI file from the specified file path.\n\n    Parameters:\n    file_path (str): The path to the MIDI file to be loaded.\n\n    Returns:\n    MidiFile: The loaded MIDI file object.\n    \"\"\"\n    try:\n        midi = MidiFile(file_path)\n        return midi\n    except IOError as e:\n        print(f\"An error occurred while loading the MIDI file: {e}\")\n\ndef play_midi_file(midi):\n    \"\"\"\n    Play the given MIDI file.\n\n    Parameters:\n    midi (MidiFile): The MIDI file object to play.\n    \"\"\"\n    for track in midi.tracks:\n        for msg in track:\n            if msg.type == 'note_on':\n                # Process a MIDI 'note_on' message\n                print(f\"Playing note {msg.note} with velocity {msg.velocity}\")\n            midi.sleep(msg.time)\n\ndef stop_midi_playback():\n    \"\"\"\n    Stop any MIDI playback.\n    \"\"\"\n    # Logic to stop MIDI playback\n    print(\"MIDI playback stopped.\")\n\n# Main execution\nif __name__ == \"__main__\":\n    midi_file = load_midi('path_to_midi_file.mid')\n    if midi_file:\n        play_midi_file(midi_file)\n        stop_midi_playback()\n```\n",
                    "```python\n# localization_utils.py\n\n\"\"\"\nUtilities for localizing mobile application strings.\n\nThis module contains functions to fetch and handle localized strings\nbased on user preferences. It supports various languages and ensures\nthat fallback is provided for unsupported languages.\n\nExample usage:\n    from localization_utils import get_localized_string\n\n    message = get_localized_string('welcome_message', 'es')\n    print(message)  # Outputs: 'Bienvenidos' if 'es' translation is available\n\"\"\"\n\nfrom collections import namedtuple\n\n# Data structure to hold translation entries\nTranslationEntry = namedtuple('TranslationEntry', ['key', 'translations'])\n\n# Sample translation database\ntranslations_db = [\n    TranslationEntry(key='welcome_message', translations={\n        'en': 'Welcome',\n        'fr': 'Bienvenue',\n        'es': 'Bienvenidos'\n    })\n]\n\n# Supported language codes\nsupported_languages = {'en', 'fr', 'es'}\n\ndef get_translation_entry(key):\n    \"\"\"\n    Retrieves the translation entry for a given key.\n\n    :param key: The key for which to fetch translations.\n    :return: The TranslationEntry if found, otherwise None.\n    \"\"\"\n    for entry in translations_db:\n        if entry.key == key:\n            return entry\n    return None\n\ndef get_localized_string(key, lang):\n    \"\"\"\n    Fetches a localized string based on the specified language.\n\n    :param key: The translation key.\n    :param lang: The language code, e.g., 'en', 'fr', 'es'.\n    :return: Localized string if available; default if not.\n    \n    Raises:\n        ValueError: If the provided language code is unsupported.\n    \"\"\"\n    if lang not in supported_languages:\n        raise ValueError(f\"Unsupported language code: {lang}\")\n\n    entry = get_translation_entry(key)\n    if entry:\n        return entry.translations.get(lang, entry.translations.get('en'))\n    \n    return None\n\ndef main():\n    \"\"\"\n    Main program for testing localization functionality.\n    \"\"\"\n    try:\n        message = get_localized_string('welcome_message', 'de')\n        print(message if message else \"Translation not found.\")\n    except ValueError as e:\n        # Log or handle the exception in a user-friendly way\n        print(str(e))\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport json\nimport os\nfrom typing import Dict, Any\n\ndef load_json_file(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Loads the content of a JSON file and returns it as a dictionary.\n\n    Parameters:\n        file_path (str): The path to the JSON file to be loaded.\n\n    Returns:\n        Dict[str, Any]: The content of the json file as a dictionary.\n    \n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the file content is not a valid JSON.\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file at {file_path} does not exist.\")\n    \n    try:\n        with open(file_path, 'r', encoding='utf-8') as json_file:\n            data = json.load(json_file)\n        return data\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Failed to decode JSON from the file at {file_path}: {str(e)}\")\n\ndef save_json_file(file_path: str, data: Dict[str, Any]) -> None:\n    \"\"\"\n    Saves the provided data dictionary to a JSON file.\n\n    Parameters:\n        file_path (str): The path where the JSON file will be saved.\n        data (Dict[str, Any]): The data to be saved in the JSON file.\n    \n    Raises:\n        TypeError: If the data provided is not serializable to JSON.\n    \"\"\"\n    try:\n        with open(file_path, 'w', encoding='utf-8') as json_file:\n            json.dump(data, json_file, ensure_ascii=False, indent=4)\n    except TypeError as e:\n        raise TypeError(f\"The data provided is not serializable to JSON: {str(e)}\")\n\ndef analyze_eastern_wu_documents(documents: Dict[str, Any]) -> Dict[str, int]:\n    \"\"\"\n    Analyzes Eastern Wu historical documents and returns a summary of findings.\n\n    Parameters:\n        documents (Dict[str, Any]): A dictionary containing historical documents to analyze.\n\n    Returns:\n        Dict[str, int]: A summary of analysis showing counts of unique entries or mentions.\n    \"\"\"\n    summary = {}\n    for title, content in documents.items():\n        word_count = len(content.split())\n        summary[title] = word_count\n    \n    return summary\n\ndef main_process(file_path: str) -> None:\n    \"\"\"\n    Main process to load documents, analyze them, and save the results.\n\n    Parameters:\n        file_path (str): The path to the JSON file containing the documents.\n    \"\"\"\n    try:\n        documents = load_json_file(file_path)\n        summary = analyze_eastern_wu_documents(documents)\n        save_json_file('eastern_wu_summary.json', summary)\n    except (FileNotFoundError, ValueError, TypeError) as error:\n        print(f\"An error occurred: {error}\")\n\nif __name__ == \"__main__\":\n    main_process('eastern_wu_historical_documents.json')\n```",
                "Incorrect_Answers": [
                    "```python\nimport math\nfrom datetime import datetime\n\n\ndef get_aircraft_speed(distance, time):\n    \"\"\"\n    Calculate the speed of an aircraft given distance and time.\n    \n    Parameters:\n    distance (float): The distance traveled by the aircraft in kilometers.\n    time (float): The time taken to travel the distance in hours.\n    \n    Returns:\n    float: The speed of the aircraft in kilometers per hour.\n    \"\"\"\n    try:\n        # Calculate speed using the formula speed = distance / time\n        speed = distance / time\n        return speed\n    except ZeroDivisionError:\n        # Handle division by zero if time is zero\n        return float('inf')\n\n\ndef format_speed_output(speed, unit='km/h'):\n    \"\"\"\n    Format the speed value for output.\n\n    Parameters:\n    speed (float): The speed to be formatted.\n    unit (str): The unit of the speed, default is 'km/h'.\n\n    Returns:\n    str: A formatted string with the speed and its unit.\n    \"\"\"\n    # Return formatted speed string\n    return f\"The aircraft's speed is {speed:.2f} {unit}\"\n\n\ndef main():\n    \"\"\"\n    Main function to demonstrate aircraft speed calculation.\n    \"\"\"\n\n    # Define sample distance in kilometers and time in hours\n    distance_km = 300.0\n    time_hours = 0.5\n\n    # Retrieve current time\n    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n\n    # Calculate the aircraft's speed\n    aircraft_speed = get_aircraft_speed(distance_km, time_hours)\n\n    # Format the output\n    speed_output = format_speed_output(aircraft_speed)\n\n    # Output the results\n    print(f\"Calculation performed at: {current_time}\")\n    print(speed_output)\n\n\n# Execute the main function\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n# localization_utils.py\n\n\"\"\"\nThis module contains utility functions for managing translations\nand localization. Each function is designed to be small, focused,\nand easy to integrate with the rest of the application to ensure\nthe user interface can be adapted to different languages smoothly.\n\nExample usage:\n    from localization_utils import get_localized_string\n\n    localized_greeting = get_localized_string('en', 'greeting')\n\"\"\"\n\ntranslations = {\n    'en': {'greeting': 'Hello'},\n    'fr': {'greeting': 'Bonjour'},\n    'es': {'greeting': 'Hola'}\n}\n\nsupported_languages = translations.keys()\n\ndef get_localized_string(lang, string_key):\n    \"\"\"Fetches a localized string based on the user's language preference.\n\n    Args:\n        lang (str): The language code for the desired language.\n        string_key (str): The key of the string to be localized.\n\n    Returns:\n        str: A localized string if available, otherwise the default language string.\n\n    Raises:\n        ValueError: If the given language is not supported.\n    \"\"\"\n    if lang not in supported_languages:\n        raise ValueError(f\"Unsupported language code: {lang}\")\n\n    return translations[lang].get(string_key, translations['en'][string_key])\n\ndef main():\n    try:\n        print(get_localized_string('fr', 'greeting'))\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n```\n",
                    "```python\nimport math\nimport random\n\ndef calculate_genetic_variation(populations):\n    \"\"\"\n    Calculate genetic variation across different populations.\n\n    Args:\n        populations (list of dict): A list where each dictionary represents \n        a population with 'name' and 'allele_frequencies'.\n\n    Returns:\n        dict: A dictionary with population names as keys and their genetic\n        variation (variance) as values.\n    \"\"\"\n    genetic_variation = {}\n    \n    for population in populations:\n        try:\n            name = population['name']\n            allele_frequencies = population['allele_frequencies']\n            if not allele_frequencies:\n                raise ValueError(\"Allele frequencies cannot be empty.\")\n            \n            mean_frequency = sum(allele_frequencies) / len(allele_frequencies)\n            variance = sum((freq - mean_frequency) ** 2 for freq in allele_frequencies) / len(allele_frequencies)\n            \n            genetic_variation[name] = variance\n        except (KeyError, TypeError) as e:\n            print(f\"Error processing population {population}: {e}\")\n        except ValueError as ve:\n            print(f\"Value error for population {name}: {ve}\")\n\n    return genetic_variation\n\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the calculation of genetic variation.\n    \"\"\"\n    # Example data simulating allele frequencies in populations\n    populations_data = [\n        {'name': 'Population_One', 'allele_frequencies': [0.1, 0.2, 0.3, 0.2, 0.2]},\n        {'name': 'Population_Two', 'allele_frequencies': [0.3, 0.3, 0.2, 0.1, 0.1]},\n        {'name': 'Population_Three', 'allele_frequencies': [0.25, 0.25, 0.25, 0.25]},\n    ]\n    \n    variations = calculate_genetic_variation(populations_data)\n    \n    for population, variation in variations.items():\n        print(f\"The genetic variation for {population} is {variation:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyzes a list of documents from the Eastern Wu period of ancient China.\n\n    Parameters:\n    documents (list): A list of document strings to be analyzed.\n\n    Returns:\n    dict: A dictionary mapping each document to its summary analysis.\n    \"\"\"\n    results = {}\n    \n    for document in documents:\n        try:\n            # Parse the document for analysis\n            parsed_data = parse_document(document)\n            \n            # Summarize the research findings from the document\n            summary = summarize_research(parsed_data)\n            \n            # Store the summary against the document text\n            results[document] = summary\n\n        except Exception as e:\n            # Handle any exceptions by logging an error message\n            print(f\"Error processing document: {e}\")\n    \n    return results\n\n\ndef parse_document(document):\n    \"\"\"\n    Parses a document for relevant information about the Eastern Wu period.\n\n    Parameters:\n    document (str): A text document to parse.\n\n    Returns:\n    parsed_data (dict): Parsed historical data found in the document.\n    \"\"\"\n    # Example parsing logic, this would be replaced with actual parsing\n    parsed_data = {\n        'title': 'Example Title',\n        'content': document\n    }\n    return parsed_data\n\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Summarizes research findings from parsed document data.\n\n    Parameters:\n    parsed_data (dict): Data extracted from a document.\n\n    Returns:\n    summary (str): A summary of the research findings.\n    \"\"\"\n    # Example summarization logic, to be replaced with actual summarization\n    summary = f\"Summary of {parsed_data['title']}: Key findings here.\"\n    return summary\n\n\n# Example usage\nif __name__ == \"__main__\":\n    documents = [\n        \"Document about Eastern Wu politics.\",\n        \"Another document about cultural aspects.\"\n    ]\n    \n    # Analyze documents and print the results\n    analysis_results = analyze_eastern_wu_documents(documents)\n    for doc, summary in analysis_results.items():\n        print(f\"Document: {doc}\\nSummary: {summary}\\n\")\n```",
                "Incorrect_Answers": [
                    "```python\n# Language translations in separate modules for modularity\n# Example of Spanish translations found in 'localization_es.py'\nTRANSLATIONS_ES = {\n    'hello': 'Hola',\n    'goodbye': 'Adi\u00f3s',\n    'thank_you': 'Gracias',\n    'please': 'Por favor'\n}\n\n# Main module for handling localization\nsupported_languages = ['en', 'es', 'fr']\n\ndef get_localized_string(key, lang='en'):\n    \"\"\"\n    Fetches localized string based on user preference, defaults to 'en' if unsupported.\n\n    Args:\n        key (str): The key for the text translation.\n        lang (str): The language code for translation.\n\n    Returns:\n        str: Localized text based on the given key and language.\n    \n    Raises:\n        ValueError: If the language code is unsupported.\n    \"\"\"\n    if lang not in supported_languages:\n        # Provide user-friendly feedback for unsupported languages\n        raise ValueError(\"Unsupported language code. Please choose from: 'en', 'es', 'fr'.\")\n\n    return _get_text_translations(lang).get(key, _get_text_translations('en').get(key))\n\ndef _get_text_translations(lang):\n    \"\"\"Fetches translations for the specified language.\"\"\"\n    translations = {\n        'en': {\n            'hello': 'Hello',\n            'goodbye': 'Goodbye',\n            'thank_you': 'Thank you',\n            'please': 'Please'\n        },\n        'es': TRANSLATIONS_ES,\n        'fr': {\n            'hello': 'Bonjour',\n            'goodbye': 'Au revoir',\n            'thank_you': 'Merci',\n            'please': 'S'il vous pla\u00eet'\n        }\n    }\n    return translations[lang] if lang in translations else translations['en']\n\n# Example function usage\ntry:\n    print(get_localized_string('hello', 'es'))  # Output: Hola\n    print(get_localized_string('goodbye', 'fr'))  # Output: Au revoir\n    print(get_localized_string('thank_you', 'it'))  # Raises ValueError\nexcept ValueError as ve:\n    print(ve)\n```\n",
                    "```python\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\n\n\ndef calculate_pollinator_effectiveness(flower_data: Dict[str, List[Tuple[str, int]]]) -> Dict[str, float]:\n    \"\"\"\n    This function calculates the effectiveness of pollinators for each flower species.\n    \n    Parameters:\n    flower_data (Dict[str, List[Tuple[str, int]]]): A dictionary where the key is the flower species\n    and the value is a list of tuples containing pollinator species and the number of visits they made.\n    \n    Returns:\n    Dict[str, float]: A dictionary where the key is the flower species and the value is the\n    pollination effectiveness score.\n    \"\"\"\n    pollination_scores = defaultdict(float)\n\n    try:\n        for flower, pollinators in flower_data.items():\n            total_visits = sum(visits for _, visits in pollinators)\n\n            # Calculate effectiveness score for the flower\n            pollination_scores[flower] = sum(\n                (1.0 * visits / total_visits) for _, visits in pollinators\n            )\n        \n    except Exception as e:\n        print(f\"An error occurred while calculating pollinator effectiveness: {e}\")\n    \n    return pollination_scores\n\n\ndef print_pollination_report(pollination_scores: Dict[str, float]) -> None:\n    \"\"\"\n    This function prints a formatted report of the pollination effectiveness scores.\n    \n    Parameters:\n    pollination_scores (Dict[str, float]): A dictionary where the key is the flower species and\n    the value is the pollination effectiveness score.\n    \"\"\"\n    print(\"Pollination Effectiveness Report\")\n    print(\"=\" * 35)\n\n    for flower, score in pollination_scores.items():\n        print(f\"{flower}: {score:.2f}\")\n        \n\n# Example usage\nif __name__ == \"__main__\":\n    sample_data = {\n        \"Wild Rose\": [(\"Bee\", 30), (\"Butterfly\", 20)],\n        \"Sunflower\": [(\"Bee\", 50), (\"Moth\", 15), (\"Butterfly\", 25)],\n    }\n\n    scores = calculate_pollinator_effectiveness(sample_data)\n    print_pollination_report(scores)\n```",
                    "```python\nimport math  # Standard library import\nfrom typing import List, Tuple  # Type hinting for better readability\n\ndef calculate_player_score(goals: int, assists: int) -> int:\n    \"\"\"\n    Calculate the player's score based on goals and assists.\n\n    Args:\n        goals (int): The number of goals scored by the player.\n        assists (int): The number of assists made by the player.\n\n    Returns:\n        int: The player's total score.\n    \"\"\"\n    try:\n        score = goals * 2 + assists\n        return score\n    except TypeError:\n        print(\"Error: Goals and assists must be integers.\")\n        return 0\n\ndef evaluate_performances(players: List[Tuple[str, int, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Evaluate the performances of a list of players.\n\n    Args:\n        players (List[Tuple[str, int, int]]): A list of tuples containing\n        player names, their goals, and assists.\n\n    Returns:\n        List[Tuple[str, int]]: A list of tuples containing player names and\n        their calculated scores.\n    \"\"\"\n    performances = []\n    \n    for player in players:\n        name, goals, assists = player\n        score = calculate_player_score(goals, assists)\n        performances.append((name, score))\n    \n    return performances\n\ndef main():\n    players_data = [\n        (\"Arjun\", 4, 3),  # Example player data\n        (\"Priya\", 2, 5),\n        (\"Rahul\", 3, 4)\n    ]\n    \n    # Evaluate all player's performances\n    all_performances = evaluate_performances(players_data)\n    \n    # Print each player's score\n    for performance in all_performances:\n        name, score = performance\n        print(f\"Player: {name}, Score: {score}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyzes a list of documents from the Eastern Wu period, extracting key\n    socio-political data and summarizing insights.\n    \n    Args:\n    - documents (list): A list of strings, each representing a historical document.\n\n    Returns:\n    - summary (dict): A dictionary of key insights categorized by topic.\n    \"\"\"\n    try:\n        summaries = []\n        for document in documents:\n            parsed_document = parse_document(document)\n            document_summary = summarize_research(parsed_document)\n            summaries.append(document_summary)\n        \n        combined_summary = combine_summaries(summaries)\n        return combined_summary\n\n    except Exception as e:\n        print(f\"Error analyzing documents: {e}\")\n        return None\n\ndef parse_document(document):\n    \"\"\"\n    Parses a single historical document, identifying and extracting relevant\n    information for analysis.\n    \n    Args:\n    - document (str): The text of the document to be parsed.\n    \n    Returns:\n    - parsed_data (dict): A dictionary containing structured data extracted from the document.\n    \"\"\"\n    # Simulate parsing logic here\n    parsed_data = {\n        \"title\": extract_title(document),\n        \"date\": extract_date(document),\n        \"content\": extract_content(document)\n    }\n    return parsed_data\n\ndef summarize_research(parsed_document):\n    \"\"\"\n    Summarizes the important information from a parsed document, focusing on\n    socio-political topics.\n    \n    Args:\n    - parsed_document (dict): Data extracted from a document.\n    \n    Returns:\n    - summary (dict): Summarized insights from the document.\n    \"\"\"\n    summary = {\n        \"title\": parsed_document[\"title\"],\n        \"main_points\": analyze_content(parsed_document[\"content\"]),\n        \"date\": parsed_document[\"date\"]\n    }\n    return summary\n\ndef combine_summaries(summaries):\n    \"\"\"\n    Combines multiple document summaries into a single coherent summary.\n    \n    Args:\n    - summaries (list): A list of summaries, each being a dictionary of insights.\n    \n    Returns:\n    - combined_summary (dict): A consolidated summary dictionary.\n    \"\"\"\n    combined = {\n        \"total_documents\": len(summaries),\n        \"topics_covered\": identify_common_topics(summaries),\n        \"key_insights\": compile_key_insights(summaries)\n    }\n    return combined\n```",
                "Incorrect_Answers": [
                    "```python\nimport mido\nfrom mido import MidiFile\n\ndef load_midi(file_path):\n    \"\"\"Load a MIDI file.\n\n    Args:\n        file_path (str): The path to the MIDI file.\n\n    Returns:\n        MidiFile: An instance of the MidiFile loaded from the path.\n    \"\"\"\n    try:\n        midi_file = MidiFile(file_path)\n        return midi_file\n    except IOError as e:\n        print(f\"An error occurred while loading the MIDI file: {e}\")\n        return None\n\ndef play_midi_file(midi_file):\n    \"\"\"Play a MIDI file.\n\n    Args:\n        midi_file (MidiFile): The MIDI file to be played.\n    \"\"\"\n    if not midi_file:\n        print(\"The provided MIDI file is not valid.\")\n        return\n\n    for track in midi_file.tracks:\n        for msg in track:\n            if not msg.is_meta:\n                midi_event(msg)\n\ndef midi_event(msg):\n    \"\"\"Handle individual MIDI events.\n\n    Args:\n        msg (Message): A MIDI message to process.\n    \"\"\"\n    # Placeholder for actual MIDI event handling logic\n    print(f\"MIDI Event - {msg}\")\n\ndef main():\n    \"\"\"Main function to execute MIDI operations.\"\"\"\n    file_path = 'path_to_your_midi_file.mid'\n    midi_file = load_midi(file_path)\n    play_midi_file(midi_file)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nfrom typing import List, Dict, Any\n\nclass Extremophile:\n    \"\"\"\n    Represents an extremophile organism with adaptations to extreme conditions.\n\n    Attributes:\n        name (str): The scientific name of the extremophile.\n        habitat (str): The typical habitat where the extremophile is found.\n        adaptations (List[str]): List of unique adaptations of the extremophile.\n    \"\"\"\n    \n    def __init__(self, name: str, habitat: str, adaptations: List[str]) -> None:\n        self.name = name\n        self.habitat = habitat\n        self.adaptations = adaptations\n\n    def is_extremophile(self) -> bool:\n        \"\"\"Check if the organism is considered an extremophile based on its habitat.\"\"\"\n        extreme_conditions = [\"hot springs\", \"arctic\", \"deep ocean vents\"]\n        return self.habitat.lower() in extreme_conditions\n\n\ndef filter_extremophiles(data: List[Dict[str, Any]]) -> List[Extremophile]:\n    \"\"\"\n    Filters a list of organisms and returns only those that are extremophiles.\n\n    Args:\n        data (List[Dict[str, Any]]): A list of organism data, each with a name, habitat, and adaptations.\n\n    Returns:\n        List[Extremophile]: A list of Extremophile objects representing extremophile organisms.\n    \"\"\"\n    try:\n        extremophiles = [\n            Extremophile(organism['name'], organism['habitat'], organism['adaptations'])\n            for organism in data\n            if Extremophile(organism['name'], organism['habitat'], organism['adaptations']).is_extremophile()\n        ]\n        return extremophiles\n    except KeyError as error:\n        print(f\"Data parsing error: Missing key {error}\")\n        return []\n```",
                    "```python\n# localization_en.py\n\"\"\"\nThis module retrieves localized strings for English users.\n\"\"\"\n\n# Import necessary standard and third-party libraries\nimport logging\nfrom typing import Dict\n\n# Example user preferences\nuser_preferences = {\n    'language': 'en'\n}\n\n# Supported languages dictionary\nsupported_languages: Dict[str, Dict[str, str]] = {\n    'en': {'greeting': 'Hello'},\n    'fr': {'greeting': 'Bonjour'},\n    'es': {'greeting': 'Hola'}\n}\n\ndef get_localized_string(lang: str) -> str:\n    \"\"\"\n    Fetches the localized greeting string based on user preference.\n\n    Args:\n    lang (str): Language code to fetch the greeting string.\n\n    Returns:\n    str: Localized greeting string if language is supported; default otherwise.\n\n    Raises:\n    ValueError: If the provided language code is unsupported.\n    \"\"\"\n    if lang not in supported_languages:\n        logging.error(f\"Unsupported language code: {lang}\")\n        raise ValueError('Unsupported language code')\n    \n    return supported_languages[lang]['greeting']\n\ndef main() -> None:\n    \"\"\"\n    Main function to demonstrate the fetching of a localized string.\n    \"\"\"\n    try:\n        user_lang = user_preferences.get('language', 'en')\n        localized_greeting = get_localized_string(user_lang)\n        print(localized_greeting)\n    except ValueError as ve:\n        logging.warning(f\"Language support issue: {ve}\")\n\nif __name__ == '__main__':\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Dr. Alex Tan\n\nDr. Alex Tan, a university history professor born in 1982, is a passionate scholar specializing in the Eastern Wu period of ancient China. With a meticulous approach to research, he has published numerous papers that explore the socio-political structures of this intriguing era. Of mixed race, Dr. Tan brings a unique multicultural perspective to his studies and lectures, enriching his students\u2019 understanding of history with global context. Known for his engaging teaching style, he seamlessly integrates historical analysis with interactive discussions, fostering a dynamic learning environment. Outside the classroom, he enjoys participating in historical reenactments and curating exhibitions that make history accessible to the public.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Descriptive naming conventions for variables and functions, e.g., 'analyze_eastern_wu_documents' instead of 'aewd'.\", \"2\": \"Extensive commenting and documentation to explain complex logic and historical references in code.\", \"3\": \"Modular code with small, focused functions, such as 'parse_document' and 'summarize_research'.\", \"4\": \"Error handling to manage unexpected input or processing issues, e.g., using try-except blocks.\", \"5\": \"Readability over performance, prioritizing clear expressions of intent in code.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviations or cryptic variable names that obscure meaning, e.g., 'd1', 'doc2'.\", \"2\": \"Code that lacks comments or documentation, making it difficult to understand historical contexts.\", \"3\": \"Long functions that perform too many tasks, making them difficult to maintain.\", \"4\": \"Ignoring exceptions and potential errors, leading to unhandled crashes.\", \"5\": \"Overly optimized code that sacrifices clarity for speed.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation of 4 spaces for block structures to enhance visual clarity.\", \"2\": \"Limiting line length to 79 characters for better readability on various displays.\", \"3\": \"Proper spacing around operators and after commas to improve readability, e.g., 'x = a + b' instead of 'x=a+b'.\", \"4\": \"Use of docstrings for all public functions to describe their purpose and usage.\", \"5\": \"Organized imports by standard libraries, third-party libraries, and local modules.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent indentation or mixing of tabs and spaces, causing code to be visually confusing.\", \"2\": \"Lines exceeding 79 characters without justification, forcing horizontal scrolling.\", \"3\": \"Lack of spacing between logical segments, resulting in crowded code that's hard to read.\", \"4\": \"Missing or inadequate docstrings that leave users guessing about function purposes.\", \"5\": \"Unorganized imports that mix types, making it harder to discern dependencies at a glance.\"}\n}"
            }
        ]
    }
}