{
    "Original Persona": "A science journalist drawn to the unique characteristics and potential applications of extremophiles",
    "Expanded Persona": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.",
    "Topic": "coding",
    "Original Sample": "```python\ndef numSmallerByFrequency(queries,words):\n queriesMinFrequecies=[0]*len(queries)\n for i in range(len(queries)):\n  queriesMinFrequecies[i]=computeLowestFrequency(queries[i])\n wordsMinFrequecies=[0]*len(words)\n for i in range(len(words)):\n  wordsMinFrequecies[i]=computeLowestFrequency(words[i])\n wordsMinFrequecies.sort()\n result=[0]*len(queries)\n for i in range(len(result)):\n  result[i]=search(wordsMinFrequecies,queriesMinFrequecies[i])\n return result\n\ndef search(nums,target):\n count=0\n for i in range(len(nums)-1,-1,-1):\n  if nums[i]>target:\n   count+=1\n  else:\n   break\n return count\n\ndef computeLowestFrequency(string):\n str=list(string)\n str.sort()\n frequency=1\n for i in range(1,len(str)):\n  if str[i]==str[0]:\n   frequency+=1\n  else:\n   break\n return frequency\n\ndef numSmallerByFrequencyBinarySearch(queries,words):\n queriesMinFrequecies=[0]*len(queries)\n for i in range(len(queries)):\n  queriesMinFrequecies[i]=computeLowestFrequency(queries[i])\n wordsMinFrequecies=[0]*len(words)\n for i in range(len(words)):\n  wordsMinFrequecies[i]=computeLowestFrequency(words[i])\n wordsMinFrequecies.sort()\n result=[0]*len(queries)\n for i in range(len(result)):\n  result[i]=binarySearch(wordsMinFrequecies,queriesMinFrequecies[i])\n return result\n\ndef binarySearch(nums,target):\n left=0\n right=len(nums)-1\n while left<=right:\n  mid=(left+right)//2\n  if nums[mid]<=target:\n   left=mid+1\n  else:\n   right=mid-1\n return len(nums)-left\n```",
    "Coding and Formatting Styles": "{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}",
    "Updated Coding Sample": "```python\ndef num_smaller_by_frequency(queries, words):\n    \"\"\"Calculate the number of words with a smaller frequency of their lowest character for each query.\"\"\"\n    queries_min_frequencies = [0] * len(queries)\n    for i in range(len(queries)):\n        queries_min_frequencies[i] = compute_lowest_frequency(queries[i])\n    \n    words_min_frequencies = [0] * len(words)\n    for i in range(len(words)):\n        words_min_frequencies[i] = compute_lowest_frequency(words[i])\n    \n    words_min_frequencies.sort()  # Sort to facilitate binary search\n    result = [0] * len(queries)\n    for i in range(len(result)):\n        result[i] = binary_search(words_min_frequencies, queries_min_frequencies[i])\n    \n    return result\n\ndef binary_search(nums, target):\n    \"\"\"Perform binary search to count how many numbers are greater than the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return len(nums) - left  # Count of elements greater than target\n\ndef compute_lowest_frequency(string):\n    \"\"\"Compute the lowest frequency of the first character in the sorted string.\"\"\"\n    sorted_str = list(string)\n    sorted_str.sort()  # Sort the characters in the string\n    frequency = 1\n    for i in range(1, len(sorted_str)):\n        if sorted_str[i] == sorted_str[0]:\n            frequency += 1\n        else:\n            break\n    return frequency\n\n# The previous function was removed to avoid redundancy with num_smaller_by_frequency\n```",
    "Conversation": [
        "[Original_Code]: def numSmallerByFrequency(queries,words):\n    queriesMinFrequecies=[0]*len(queries)\n    for i in range(len(queries)):\n        queriesMinFrequecies[i]=computeLowestFrequency(queries[i])\n    wordsMinFrequecies=[0]*len(words)\n    for i in range(len(words)):\n        wordsMinFrequecies[i]=computeLowestFrequency(words[i])\n    wordsMinFrequecies.sort()\n    result=[0]*len(queries)\n    for i in range(len(result)):\n        result[i]=search(wordsMinFrequecies,queriesMinFrequecies[i])\n    return result\n\ndef search(nums,target):\n    count=0\n    for i in range(len(nums)-1,-1,-1):\n        if nums[i]>target:\n            count+=1\n        else:\n            break\n    return count\n\ndef computeLowestFrequency(string):\n    str=list(string)\n    str.sort()\n    frequency=1\n    for i in range(1,len(str)):\n        if str[i]==str[0]:\n            frequency+=1\n        else:\n            break\n    return frequency\n\ndef numSmallerByFrequencyBinarySearch(queries,words):\n    queriesMinFrequecies=[0]*len(queries)\n    for i in range(len(queries)):\n        queriesMinFrequecies[i]=computeLowestFrequency(queries[i])\n    wordsMinFrequecies=[0]*len(words)\n    for i in range(len(words)):\n        wordsMinFrequecies[i]=computeLowestFrequency(words[i])\n    wordsMinFrequecies.sort()\n    result=[0]*len(queries)\n    for i in range(len(result)):\n        result[i]=binarySearch(wordsMinFrequecies,queriesMinFrequecies[i])\n    return result\n\ndef binarySearch(nums,target):\n    left=0\n    right=len(nums)-1\n    while left<=right:\n        mid=(left+right)//2\n        if nums[mid]<=target:\n            left=mid+1\n        else:\n            right=mid-1\n    return len(nums)-left",
        "[Side_Note]: [Coding Styles] Likes Consistent naming conventions, modular code structure, thorough error handling, use of list comprehensions, functional programming practices.",
        "[Side_Note]: [Coding Styles] Dislikes Overly long functions, ambiguous variable names, lack of comments, not handling exceptions, redundant code.",
        "[Side_Note]: [Formatting Styles] Likes Consistent use of 4-space indentation, maximum 79 characters line length, clear and detailed docstrings, organized imports, inline comments.",
        "[Side_Note]: [Formatting Styles] Dislikes Inconsistent indentation, line lengths exceeding 79 characters, lack of space around operators, missing docstrings, improperly aligned variables.",
        "User: I want to refactor this code to improve readability and maintain the correct coding styles I prefer. I like consistent naming conventions and modular code structure, but I dislike overly long functions and lack of comments.",
        "Assistant: Let's break down the functions to ensure they are more readable and correctly named. I'll also add docstrings and improve the formatting. Here's a suggested version:\n\n```python\ndef num_smaller_by_frequency(queries, words):\n    ... # code\n```",
        "User: I appreciate the attempt, but I want the changes to reflect my preferences more explicitly. Can we have better variable names and structure, as mentioned in my likes?",
        "Assistant: Absolutely! Let's add descriptive names and make sure we follow the formatting requirements. Here\u2019s another version:\n\n```python\ndef num_smaller_by_frequency(queries, words):\n    \"\"\"Calculate the number of words with a smaller frequency of their lowest character for each query.\"\"\"\n    queries_min_frequencies = [0] * len(queries)\n    for i in range(len(queries)):\n        queries_min_frequencies[i] = compute_lowest_frequency(queries[i])\n\n    words_min_frequencies = [0] * len(words)\n    for i in range(len(words)):\n        words_min_frequencies[i] = compute_lowest_frequency(words[i])\n\n    words_min_frequencies.sort()  # Sort to facilitate binary search\n    result = [0] * len(queries)\n    for i in range(len(result)):\n        result[i] = binary_search(words_min_frequencies, queries_min_frequencies[i])\n\n    return result\n```",
        "User: This is better! I like the naming conventions, and the docstrings are great. However, I still see a bit of redundancy in the way the minimum frequencies are being calculated in two different functions. Can we streamline that?",
        "Assistant: Good point! We can avoid redundancy by keeping just one main function and removing any duplicates. Here\u2019s the refined version:\n\n```python\ndef compute_lowest_frequency(string):\n    \"\"\"Compute the lowest frequency of the first character in the sorted string.\"\"\"\n    sorted_str = list(string)\n    sorted_str.sort()  # Sort the characters in the string\n    frequency = 1\n    for i in range(1, len(sorted_str)):\n        if sorted_str[i] == sorted_str[0]:\n            frequency += 1\n        else:\n            break\n    return frequency\n\n# Removed the binary search version as it's redundant now.\n```",
        "User: This is much cleaner! But can we still optimize the binary search function and ensure that all parts adhere to my formatting standards?",
        "Assistant: Here\u2019s the final version, including the optimized binary search and adhering to all your formatting preferences:\n\n```python\ndef num_smaller_by_frequency(queries, words):\n    \"\"\"Calculate the number of words with a smaller frequency of their lowest character for each query.\"\"\"\n    queries_min_frequencies = [0] * len(queries)\n    for i in range(len(queries)):\n        queries_min_frequencies[i] = compute_lowest_frequency(queries[i])\n\n    words_min_frequencies = [0] * len(words)\n    for i in range(len(words)):\n        words_min_frequencies[i] = compute_lowest_frequency(words[i])\n\n    words_min_frequencies.sort()  # Sort to facilitate binary search\n    result = [0] * len(queries)\n    for i in range(len(result)):\n        result[i] = binary_search(words_min_frequencies, queries_min_frequencies[i])\n\n    return result\n\ndef binary_search(nums, target):\n    \"\"\"Perform binary search to count how many numbers are greater than the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return len(nums) - left  # Count of elements greater than target\n\ndef compute_lowest_frequency(string):\n    \"\"\"Compute the lowest frequency of the first character in the sorted string.\"\"\"\n    sorted_str = list(string)\n    sorted_str.sort()  # Sort the characters in the string\n    frequency = 1\n    for i in range(1, len(sorted_str)):\n        if sorted_str[i] == sorted_str[0]:\n            frequency += 1\n        else:\n            break\n    return frequency\n```",
        "User: This is fantastic! All my preferences are reflected now, and the code is clean and concise. Thank you for your assistance!"
    ],
    "Q&A": {
        "Conversation": [
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef categorize_extremophiles(biological_data):\n    \"\"\"\n    Analyzes a dataset of organisms to identify and categorize extremophiles.\n\n    Parameters:\n    biological_data (list of dict): A list where each dictionary represents\n    an organism with its respective properties such as 'habitat', 'temperature_tolerance',\n    and 'radiation_resistance'.\n\n    Returns:\n    dict: A dictionary categorizing organisms into various extremophile classes\n    and providing their counts.\n    \"\"\"\n    import numpy as np  # Standard library imports should be placed first\n\n    from collections import defaultdict  # Third-party library imports next\n\n    extremophile_classes = defaultdict(int)\n\n    try:\n        for organism in [org for org in biological_data if 'extremophile' in org and org['extremophile']]:\n            # Check if organism is an extremophile\n            habitat_type = organism.get('habitat_type', 'unknown')\n            temperature_tolerance = organism.get('temperature_tolerance', np.nan)\n            radiation_resistance = organism.get('radiation_resistance', np.nan)\n\n            # Determine category based on environmental tolerance\n            if temperature_tolerance > 80:\n                extremophile_classes['Thermophile'] += 1\n            if radiation_resistance > 300:\n                extremophile_classes['Radioresistant'] += 1\n            if habitat_type in ['acidic', 'alkaline', 'saline']:\n                extremophile_classes['Halophile/Acidophile/Alkaliphile'] += 1\n\n    except KeyError as e:\n        print(f\"KeyError: Missing expected field {e} in biological data.\")\n    except Exception as e:\n        print(f\"Unexpected error encountered: {str(e)}\")\n\n    return extremophile_classes\n```\n",
                "Incorrect_Answers": [
                    "```python\nfrom typing import List\n\ndef calculate_player_score(goals: int, assists: int) -> int:\n    \"\"\"\n    Calculate the total score for a player based on goals and assists.\n\n    Parameters:\n    goals (int): The number of goals scored by the player.\n    assists (int): The number of assists made by the player.\n\n    Returns:\n    int: The calculated score for the player.\n    \"\"\"\n    return goals * 2 + assists\n\ndef get_team_scores(players_stats: List[dict]) -> List[int]:\n    \"\"\"\n    Calculate scores for each player in a team.\n\n    Parameters:\n    players_stats (List[dict]): A list of dictionaries containing player stats with 'goals' and 'assists' keys.\n\n    Returns:\n    List[int]: A list of scores for each player.\n    \"\"\"\n    team_scores = []\n    for player_stats in players_stats:\n        try:\n            goals = player_stats['goals']\n            assists = player_stats['assists']\n            player_score = calculate_player_score(goals, assists)\n            team_scores.append(player_score)\n        except KeyError:\n            print(\"Error: Missing 'goals' or 'assists' key in player stats.\")\n        except TypeError:\n            print(\"Error: 'goals' and 'assists' should be integers.\")\n    return team_scores\n\ndef display_team_scores(team_scores: List[int]) -> None:\n    \"\"\"\n    Display the scores of each player in a team.\n\n    Parameters:\n    team_scores (List[int]): A list of scores for each player.\n    \"\"\"\n    for index, score in enumerate(team_scores):\n        print(f\"Player {index + 1}: {score} points\")\n\n# Example of how to use the functions\nif __name__ == \"__main__\":\n    team = [\n        {\"goals\": 3, \"assists\": 2},\n        {\"goals\": 1, \"assists\": 1},\n        {\"goals\": 4, \"assists\": 3}\n    ]\n    scores = get_team_scores(team)\n    display_team_scores(scores)\n```\n",
                    "```python\n# localization.py\n\n# Standard library imports\nimport json\nfrom typing import Dict\n\n# Third-party imports\n# (e.g., import requests)\n\n# Local imports\n# (e.g., from .translations_loader import load_translations)\n\nsupported_languages = ['en', 'es', 'fr', 'de']\n\ndef get_localized_string(key: str, lang: str = 'en') -> str:\n    \"\"\"\n    Fetches localized string based on user preference.\n\n    Args:\n        key (str): The key identifier for the string.\n        lang (str): The language code for localization. Defaults to 'en'.\n\n    Returns:\n        str: Localized string if available, otherwise default language string.\n    \n    Example:\n        get_localized_string('greeting', 'fr')  # Returns 'Bonjour'\n    \"\"\"\n    try:\n        translations = get_text_translations(lang)\n        return translations.get(key, translations['default'])\n    except KeyError:\n        raise ValueError('Unsupported language code')\n\ndef get_text_translations(lang: str) -> Dict[str, str]:\n    \"\"\"Returns translations for the specified language.\"\"\"\n    translations_data = {\n        'en': {'greeting': 'Hello', 'default': 'Hello'},\n        'es': {'greeting': 'Hola', 'default': 'Hola'},\n        'fr': {'greeting': 'Bonjour', 'default': 'Bonjour'},\n        'de': {'greeting': 'Hallo', 'default': 'Hallo'}\n    }\n    \n    if lang in translations_data:\n        return translations_data[lang]\n    else:\n        return translations_data['en']\n\nif __name__ == \"__main__\":\n    user_language = 'es'\n    print(get_localized_string('greeting', user_language))\n```\n",
                    "```python\n# Import standard libraries\nimport sys\nimport os\n\n# Import third-party libraries\nimport numpy as np\n\n# Import local libraries\nfrom local_utils import stats_calculator\n\nclass Player:\n    \"\"\"\n    Represents a football player with specific stats.\n    \"\"\"\n    \n    def __init__(self, name, position):\n        \"\"\"\n        Initializes a player with a name and position.\n\n        :param name: The player's name\n        :param position: The player's position on the field\n        \"\"\"\n        self.name = name\n        self.position = position\n        self.stats = {}\n\n    def update_stats(self, game_data):\n        \"\"\"\n        Updates player's statistics based on the game data provided.\n\n        :param game_data: Dictionary containing game statistics\n        \"\"\"\n        try:\n            self.stats['yards'] = game_data.get('yards', 0)\n            self.stats['touchdowns'] = game_data.get('touchdowns', 0)\n        except KeyError as e:\n            print(f\"Missing key in game data: {e}\")\n\n    def calculate_average_yards(self, games_played):\n        \"\"\"\n        Calculates the average yards per game for the player.\n\n        :param games_played: Number of games played\n        :return: Average yards per game\n        \"\"\"\n        try:\n            return self.stats['yards'] / games_played\n        except (ZeroDivisionError, KeyError):\n            return 0\n\ndef main():\n    \"\"\"\n    Main function that runs the program.\n    \"\"\"\n    player = Player(name=\"Alex Rivers\", position=\"Quarterback\")\n    game_data = {'yards': 120, 'touchdowns': 2}\n    player.update_stats(game_data)\n    \n    # Calculate average yards per game assuming 5 games played\n    avg_yards = player.calculate_average_yards(games_played=5)\n    print(f\"Average Yards for {player.name}: {avg_yards}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List, Callable\n\ndef filter_extremophiles(data: List[dict], is_extremophile: Callable[[dict], bool]) -> List[dict]:\n    \"\"\"\n    Filters out extremophile organisms from a list of biological data.\n\n    Parameters:\n        data (List[dict]): A list of dictionaries representing biological organisms.\n        is_extremophile (Callable[[dict], bool]): A function to determine if an organism is an extremophile.\n\n    Returns:\n        List[dict]: A list containing only the extremophile organisms.\n    \"\"\"\n    # Filtering extremophiles using list comprehension\n    extremophiles = [organism for organism in data if is_extremophile(organism)]\n    return extremophiles\n\ndef analyze_adaptations(extremophiles: List[dict]) -> List[str]:\n    \"\"\"\n    Analyzes adaptation features of the extremophiles.\n\n    Parameters:\n        extremophiles (List[dict]): A list of extremophile organisms.\n\n    Returns:\n        List[str]: A list of adaptation features found in extremophiles.\n    \"\"\"\n    adaptations = []\n    try:\n        for organism in extremophiles:\n            adaptation_feature = extract_feature(organism, 'adaptation')\n            if adaptation_feature:\n                adaptations.append(adaptation_feature)\n    except (KeyError, TypeError) as e:\n        # Handle cases where extraction might fail due to missing keys or incorrect data types\n        print(f\"Error analyzing adaptations: {e}\")\n    return adaptations\n\ndef extract_feature(organism: dict, feature: str) -> str:\n    \"\"\"\n    Extracts a specific feature from a given organism.\n\n    Parameters:\n        organism (dict): A dictionary representing an organism.\n        feature (str): The feature to be extracted from the organism.\n\n    Returns:\n        str: The value of the specified feature, if present; otherwise, an empty string.\n    \"\"\"\n    return organism.get(feature, '')\n\n# Example usage\nif __name__ == \"__main__\":\n    biological_data = [\n        {'name': 'Tardigrade', 'habitat': 'extreme', 'adaptation': 'cryptobiosis'},\n        {'name': 'E. coli', 'habitat': 'moderate', 'adaptation': 'none'},\n        {'name': 'Thermus aquaticus', 'habitat': 'extreme', 'adaptation': 'heat_tolerance'}\n    ]\n\n    extremophile_checker = lambda organism: organism['habitat'] == 'extreme'\n    extremophiles = filter_extremophiles(biological_data, extremophile_checker)\n    \n    adaptations_list = analyze_adaptations(extremophiles)\n    print(\"Adaptations found in extremophiles:\", adaptations_list)\n```",
                "Incorrect_Answers": [
                    "```python\n\"\"\"\nModule to perform basic operations with enhanced readability and error handling.\n\"\"\"\n\nimport math\nfrom typing import List\n\n\ndef calculate_average(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the average of a list of numbers.\n\n    Args:\n        numbers (List[float]): A list of numbers to calculate the average from.\n\n    Returns:\n        float: The average of the numbers or raises a ValueError if the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:\n        return float('nan')\n\n\ndef safe_sqrt(number: float) -> float:\n    \"\"\"\n    Safely calculate the square root of a number.\n\n    Args:\n        number (float): The number to calculate the square root of.\n\n    Returns:\n        float: The square root of the number or a message indicating an error.\n    \"\"\"\n    try:\n        return math.sqrt(number)\n    except ValueError:\n        return float('nan')\n\n\ndef print_photos(photos: List[str]) -> None:\n    \"\"\"\n    Prints the names of photo files in a list.\n\n    Args:\n        photos (List[str]): List of photo filenames to print.\n\n    Returns:\n        None\n    \"\"\"\n    for photo in photos:\n        print(photo)\n\n\ndef main() -> None:\n    \"\"\"\n    Main function demonstrating calculations and error handling.\n    \"\"\"\n    numbers = [1, 2, 3, 4, 5]\n    print(\"Average:\", calculate_average(numbers))\n    print(\"Square Root of 16:\", safe_sqrt(16))\n    print(\"Square Root of -1:\", safe_sqrt(-1))\n\n    photos = ['hiking1.jpg', 'nature2.jpg', 'adventure3.jpg']\n    print_photos(photos)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\ndef calculate_carbon_footprint(event_data):\n    \"\"\"\n    Calculate the carbon footprint for a given event.\n\n    Parameters:\n    event_data (dict): A dictionary containing information about the event including 'energy_usage' (kWh).\n\n    Returns:\n    float: The calculated carbon footprint in metric tons of CO2.\n    \"\"\"\n    try:\n        energy_usage = event_data.get('energy_usage', 0)\n        carbon_factor = 0.000409  # metric tons CO2 per kWh\n        carbon_footprint = energy_usage * carbon_factor\n        return carbon_footprint\n    except (TypeError, ValueError) as e:\n        print(f\"Error in calculating carbon footprint: {e}\")\n        return None\n\ndef filter_eco_friendly_events(events):\n    \"\"\"\n    Filter out events that are considered eco-friendly based on predefined criteria.\n\n    Parameters:\n    events (list of dicts): A list containing event data, where each event is a dictionary.\n\n    Returns:\n    list: A list of events that are marked as 'eco_friendly'.\n    \"\"\"\n    return [event for event in events if event.get('eco_friendly', False)]\n\n# Sample event data for demonstration\nevents_data = [\n    {'name': 'Tournament A', 'energy_usage': 5000, 'eco_friendly': True},\n    {'name': 'Tournament B', 'energy_usage': 10000, 'eco_friendly': False},\n]\n\nif __name__ == \"__main__\":\n    eco_friendly_events = filter_eco_friendly_events(events_data)\n    for event in eco_friendly_events:\n        footprint = calculate_carbon_footprint(event)\n        print(f\"Event: {event['name']}, Carbon Footprint: {footprint:.2f} metric tons CO2\")\n```",
                    "```python\nimport mido\nfrom mido import MidiFile\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef load_midi(file_path: str) -> MidiFile:\n    \"\"\"\n    Load a MIDI file from the given file path.\n    \n    Parameters:\n    file_path (str): The path to the MIDI file to be loaded.\n    \n    Returns:\n    MidiFile: The loaded MIDI file object.\n    \"\"\"\n    try:\n        midi = MidiFile(file_path)\n        logging.info(\"MIDI file loaded successfully.\")\n        return midi\n    except IOError:\n        logging.error(\"Error loading MIDI file.\", exc_info=True)\n        raise\n\ndef play_midi(midi: MidiFile):\n    \"\"\"\n    Play the given MIDI file.\n    \n    Parameters:\n    midi (MidiFile): The MIDI file object to play.\n    \"\"\"\n    try:\n        for message in midi.play():\n            pass  # This is where MIDI playback logic would go\n        logging.info(\"MIDI playback completed successfully.\")\n    except Exception as e:\n        logging.error(\"Error during MIDI playback: %s\", str(e), exc_info=True)\n        raise\n\ndef stop_midi():\n    \"\"\"\n    Placeholder for MIDI stopping functionality.\n    Currently a no-op.\n    \"\"\"\n    logging.info(\"MIDI stop command issued.\")\n\n# Usage example\nif __name__ == \"__main__\":\n    file_path = 'path/to/your/midi_file.mid'\n    midi = load_midi(file_path)\n    play_midi(midi)\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List, Tuple\n\ndef parse_extremophile_data(data: List[str]) -> List[dict]:\n    \"\"\"\n    Parses a list of extremophile data strings into a list of dictionaries.\n\n    Each string in 'data' should be formatted with key-value pairs separated\n    by semicolons. For example: \"species:Tardigrade;habitat:WaterBear;temp:-273\"\n\n    Parameters:\n    data (List[str]): A list of strings, each representing extremophile information.\n\n    Returns:\n    List[dict]: A list of dictionaries containing the parsed extremophile data.\n    \"\"\"\n    extremophile_list = []\n    \n    for entry in data:\n        try:\n            entry_dict = {kv.split(':')[0]: kv.split(':')[1] for kv in entry.split(';')}\n            extremophile_list.append(entry_dict)\n        except (IndexError, ValueError) as e:\n            print(f\"Error parsing data: {entry}. Exception: {str(e)}\")\n            continue\n\n    return extremophile_list\n\ndef filter_extremophiles_by_habitat(extremophiles: List[dict], habitat: str) -> List[dict]:\n    \"\"\"\n    Filters the list of extremophiles based on specified habitat.\n\n    Parameters:\n    extremophiles (List[dict]): A list of dictionaries containing extremophile data.\n    habitat (str): The habitat to filter the extremophiles by.\n\n    Returns:\n    List[dict]: A list of extremophiles that thrive in the specified habitat.\n    \"\"\"\n    return [organism for organism in extremophiles if organism.get('habitat') == habitat]\n\ndef display_extremophiles(extremophiles: List[dict]) -> None:\n    \"\"\"\n    Displays the extremophiles in a readable format.\n\n    Parameters:\n    extremophiles (List[dict]): A list of dictionaries containing extremophile data.\n\n    Returns:\n    None\n    \"\"\"\n    for extremophile in extremophiles:\n        try:\n            species = extremophile['species']\n            habitat = extremophile['habitat']\n            temp_range = extremophile.get('temp', 'Unknown')\n            print(f\"Species: {species}, Habitat: {habitat}, Temp Range: {temp_range}\")\n        except KeyError as e:\n            print(f\"Missing expected data: {str(e)}\")\n```\n",
                "Incorrect_Answers": [
                    "```python\n# Importing necessary libraries. Standard first, then third-party, then local.\nimport math\nimport random\n\n# Constants\nMAX_PLAYER_HEALTH = 100\nPLAYER_SPEED = 5\n\ndef calculate_damage(player_health, attack_strength):\n    \"\"\"\n    Calculate the new player health after taking damage.\n    :param player_health: Current health of the player\n    :param attack_strength: Strength of the incoming attack\n    :return: Updated player health\n    \"\"\"\n    # Ensure attack strength is not negative\n    attack_strength = max(0, attack_strength)\n\n    # Calculate damage taken\n    damage_taken = int(attack_strength * random.uniform(0.5, 1.5))\n\n    # Apply damage\n    new_health = player_health - damage_taken\n    return max(0, new_health)\n\ndef player_has_won(score):\n    \"\"\"\n    Determine if the player has won based on their score.\n    :param score: Player's current score\n    :return: True if the score indicates a win, False otherwise\n    \"\"\"\n    # Check if the player's score exceeds the win threshold\n    win_threshold = 100\n    return score >= win_threshold\n\ndef render_game():\n    \"\"\"\n    Render the game state visually (simplified for example).\n    This is where the graphics logic would go.\n    \"\"\"\n    print(\"Rendering game state...\")\n\ndef main_game_loop():\n    \"\"\"\n    Main game loop handling game logic.\n    \"\"\"\n    player_health = MAX_PLAYER_HEALTH\n    player_score = 0\n\n    while player_health > 0:\n        # Simulate an attack\n        attack_strength = random.randint(1, 10)\n\n        # Calculate new health\n        player_health = calculate_damage(player_health, attack_strength)\n\n        # Simulate score increment\n        player_score += random.randint(0, 5)\n\n        # Render game state\n        render_game()\n\n        # Check win condition\n        if player_has_won(player_score):\n            print(\"Congratulations, you've won!\")\n            break\n\nif __name__ == \"__main__\":\n    try:\n        # Entry point of the game\n        main_game_loop()\n    except Exception as error:\n        # General exception handling to catch unexpected issues\n        print(f\"An error occurred: {error}\")\n```",
                    "```python\nimport random\nimport math\n\ndef calculate_bmi(weight_kg, height_m):\n    \"\"\"\n    Calculates Body Mass Index (BMI) given a weight in kilograms\n    and height in meters.\n    \n    Parameters:\n    weight_kg (float): Weight in kilograms.\n    height_m (float): Height in meters.\n    \n    Returns:\n    float: Calculated BMI.\n    \"\"\"\n    try:\n        bmi = weight_kg / math.pow(height_m, 2)\n    except ZeroDivisionError:\n        return \"Height cannot be zero.\"\n    return bmi\n\ndef bmi_category(bmi):\n    \"\"\"\n    Determines the BMI category based on BMI score.\n    \n    Parameters:\n    bmi (float): Body Mass Index value.\n    \n    Returns:\n    str: BMI category.\n    \"\"\"\n    if bmi < 18.5:\n        return \"Underweight\"\n    elif 18.5 <= bmi < 24.9:\n        return \"Normal weight\"\n    elif 25.0 <= bmi < 29.9:\n        return \"Overweight\"\n    else:\n        return \"Obesity\"\n\ndef suggest_random_exercise():\n    \"\"\"\n    Suggests a random exercise activity to promote active lifestyle.\n    \n    Returns:\n    str: Suggested exercise activity.\n    \"\"\"\n    activities = [\n        \"Underwater hockey for 30 minutes\",\n        \"Swimming laps for 45 minutes\",\n        \"Aquatic aerobics for 30 minutes\",\n        \"Snorkeling adventure for 60 minutes\",\n        \"Dive clean-up event for 90 minutes\"\n    ]\n    return random.choice(activities)\n\ndef main():\n    \"\"\"\n    Main function to calculate BMI, determine category \n    and provide a random exercise suggestion.\n    \"\"\"\n    weight_kg = 70.0\n    height_m = 1.75\n    bmi_value = calculate_bmi(weight_kg, height_m)\n\n    if isinstance(bmi_value, float):\n        print(f\"BMI: {bmi_value:.2f}\")\n        print(f\"Category: {bmi_category(bmi_value)}\")\n    else:\n        print(f\"Error: {bmi_value}\")\n    \n    print(f\"Exercise Suggestion: {suggest_random_exercise()}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nfrom datetime import datetime\nimport math\n\ndef calculate_age(birth_year):\n    \"\"\"Calculate the user's age based on the given birth year.\"\"\"\n    current_year = datetime.now().year\n    try:\n        age = current_year - birth_year\n        if age < 0:\n            raise ValueError(\"Birth year can't be in the future.\")\n        return age\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n\ndef get_circle_area(radius):\n    \"\"\"Calculate the area of a circle given its radius.\"\"\"\n    try:\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        area = math.pi * (radius ** 2)\n        return area\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n\ndef user_info(birth_year, radius):\n    \"\"\"\n    Gather user's calculated age and circle area.\n    \n    Args:\n        birth_year (int): Birth year of the user.\n        radius (float): Radius of the circle.\n    \n    Returns:\n        dict: A dictionary containing age and circle area.\n    \"\"\"\n    user_age = calculate_age(birth_year)\n    circle_area = get_circle_area(radius)\n\n    return {\n        'age': user_age,\n        'circle_area': circle_area\n    }\n\n# Example usage\nresult = user_info(1983, 5)\nif result:\n    print(f\"Age: {result['age']}, Circle Area: {result['circle_area']}\")\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List, Optional\n\ndef filter_extremophiles(organisms: List[str]) -> List[str]:\n    \"\"\"\n    Filters a list of organisms to only include extremophiles.\n\n    Parameters:\n    organisms (List[str]): A list containing organism names.\n\n    Returns:\n    List[str]: A list containing names of extremophiles.\n    \"\"\"\n    # Filter and return only those organisms that are extremophiles\n    return [organism for organism in organisms if is_extremophile(organism)]\n\ndef is_extremophile(organism: str) -> bool:\n    \"\"\"\n    Determines if the given organism is an extremophile.\n\n    Parameters:\n    organism (str): The name of the organism to check.\n\n    Returns:\n    bool: True if the organism is an extremophile, False otherwise.\n    \"\"\"\n    # Simple mock logic to classify extremophiles\n    extremophile_traits = [\"thermophile\", \"halophile\", \"acidophile\"]\n    return any(trait in organism.lower() for trait in extremophile_traits)\n\ndef process_extremophile_data(data: List[str]) -> Optional[float]:\n    \"\"\"\n    Processes extremophile data to calculate a hypothetical average resilience score.\n\n    Parameters:\n    data (List[str]): A list containing resilience scores as strings.\n\n    Returns:\n    Optional[float]: The average resilience score if data is valid, None otherwise.\n    \"\"\"\n    try:\n        resilience_scores = [float(score) for score in data if score]\n        average_resilience = sum(resilience_scores) / len(resilience_scores)\n        return average_resilience\n    except (ValueError, ZeroDivisionError) as error:\n        print(f\"Error processing data: {error}\")\n        return None\n\n# Example usage\norganism_list = [\"ThermophileX\", \"NormalY\", \"HalophileZ\"]\nextremophiles = filter_extremophiles(organism_list)\nprint(f\"Identified extremophiles: {extremophiles}\")\n\nresilience_data = [\"0.7\", \"0.9\", \"1.2\", \"invalid\", \"\"]\naverage_resilience = process_extremophile_data(resilience_data)\nif average_resilience is not None:\n    print(f\"Average resilience score: {average_resilience}\")\n```\n",
                "Incorrect_Answers": [
                    "```python\nfrom datetime import datetime\n\ndef calculate_carbon_savings(attendees, average_emission_per_person):\n    \"\"\"\n    Calculate the carbon savings for an event given the number of attendees\n    and average emissions per person.\n\n    :param attendees: int - The number of people attending the event.\n    :param average_emission_per_person: float - The average carbon emissions per person.\n    :return: float - The total carbon savings for the event in metric tons.\n    \"\"\"\n    try:\n        total_emissions = attendees * average_emission_per_person\n        return total_emissions / 1000  # Convert kilograms to metric tons\n    except TypeError as e:\n        print(f\"Error calculating carbon savings: {e}\")\n        return 0.0\n\ndef summarize_event_data(events):\n    \"\"\"\n    Summarize the key details of each event.\n\n    :param events: list of dicts - A list where each element is a dictionary\n                    containing 'name', 'date', and 'eco_friendly' keys.\n    :return: list of dicts - A list of summarized event information.\n    \"\"\"\n    current_year = datetime.now().year\n    summary = []\n\n    for event in events:\n        try:\n            year = int(event['date'].split('-')[0])  # Extracts year from 'YYYY-MM-DD'\n            is_past_event = year < current_year\n            event_summary = {\n                \"name\": event['name'],\n                \"is_eco_friendly\": event['eco_friendly'],\n                \"is_past\": is_past_event\n            }\n            summary.append(event_summary)\n        except (KeyError, ValueError) as e:\n            print(f\"Skipping event due to error: {e}\")\n    \n    return summary\n\n# Example data\nevents_data = [\n    {\"name\": \"Green Gaming Expo\", \"date\": \"2023-07-15\", \"eco_friendly\": True},\n    {\"name\": \"Retro Game Fest\", \"date\": \"2022-04-20\", \"eco_friendly\": False}\n]\n\n# Example usage\ncarbon_savings = calculate_carbon_savings(attendees=500, average_emission_per_person=20.0)\nevent_summaries = summarize_event_data(events_data)\n\nprint(f\"Carbon Savings: {carbon_savings} metric tons\")\nprint(\"Event Summaries:\", event_summaries)\n```",
                    "```python\n# Importing necessary modules\nimport math\n\nclass Team:\n    \"\"\"Class to represent a football team with its attributes and behaviors.\"\"\"\n\n    def __init__(self, name, players):\n        \"\"\"Initialize the team with a name and a list of players.\"\"\"\n        self.name = name\n        self.players = players\n\n    def get_average_experience(self):\n        \"\"\"\n        Calculate the average experience of players in years.\n\n        Returns:\n            float: The average experience in years.\n        \"\"\"\n        total_experience = sum(player['experience'] for player in self.players)\n        return total_experience / len(self.players)\n\ndef calculate_speed(distance_meters, time_seconds):\n    \"\"\"\n    Calculate the speed given distance and time using the formula: speed = distance/time.\n    \n    Args:\n        distance_meters (float): Distance covered in meters.\n        time_seconds (float): Time taken in seconds.\n    \n    Returns:\n        float: The speed in meters per second.\n    \n    Raises:\n        ValueError: If time_seconds is zero to prevent division by zero.\n    \"\"\"\n    try:\n        speed = distance_meters / time_seconds\n        return speed\n    except ZeroDivisionError:\n        raise ValueError(\"Time must be greater than zero to calculate speed.\")\n\ndef main():\n    \"\"\"Main function to demonstrate functionality of Team class and speed calculation.\"\"\"\n    team = Team(name=\"Warriors\", players=[\n        {'name': 'Alex', 'experience': 5},\n        {'name': 'Jordan', 'experience': 3},\n        {'name': 'Chris', 'experience': 7}\n    ])\n    \n    print(f\"Average player experience in the {team.name}: {team.get_average_experience()} years\")\n    \n    distance = 100.0  # meters\n    time = 9.58  # seconds - Example: World record 100m dash\n    try:\n        print(f\"The runner's speed is: {calculate_speed(distance, time):.2f} m/s\")\n    except ValueError as e:\n        print(e)\n\n# Execute main function\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\ndef calculate_tax(income):\n    \"\"\"\n    Calculate the tax based on the given income.\n\n    Args:\n        income (float): The income on which tax is to be calculated.\n\n    Returns:\n        float: The calculated tax.\n    \"\"\"\n    try:\n        if income < 0:\n            raise ValueError(\"Income cannot be negative.\")\n        \n        if income <= 10000:\n            tax_rate = 0.0\n        elif income <= 20000:\n            tax_rate = 0.1\n        elif income <= 50000:\n            tax_rate = 0.2\n        else:\n            tax_rate = 0.3\n\n        tax = income * tax_rate\n        return tax\n\n    except TypeError:\n        print(\"Invalid input type. Income must be a number.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        \ndef main():\n    \"\"\"\n    Main function to execute tax calculations.\n    \"\"\"\n    try:\n        user_income = float(input(\"Enter your income: \"))\n        tax = calculate_tax(user_income)\n        print(f\"The tax on an income of {user_income} is {tax}.\")\n    \n    except ValueError:\n        print(\"Invalid input. Please enter a numerical value for income.\")\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List, Callable, Any\n\ndef process_extremophiles(data: List[Any], \n                          condition: Callable[[Any], bool], \n                          transform: Callable[[Any], Any]) -> List[Any]:\n    \"\"\"\n    Processes a list of organisms to filter and transform those that are extremophiles.\n    \n    Args:\n        data (List[Any]): A list of organisms, potentially containing various traits.\n        condition (Callable[[Any], bool]): A function that determines if an organism\n            is an extremophile based on specific criteria.\n        transform (Callable[[Any], Any]): A function that transforms the organism\n            into a desired format or representation for further analysis.\n            \n    Returns:\n        List[Any]: A list of transformed extremophiles suitable for subsequent processing.\n    \"\"\"\n    try:\n        # Filter extremophiles and apply transformation\n        return [transform(organism) for organism in data if condition(organism)]\n    except Exception as error:\n        print(f\"Error processing extremophiles: {error}\")\n        return []\n\ndef example_usage():\n    \"\"\"\n    Demonstrates the use of process_extremophiles with sample data.\n    \"\"\"\n    organisms = [\n        {\"name\": \"Tardigrade\", \"habitat\": \"Water\", \"extremophile\": True},\n        {\"name\": \"E. coli\", \"habitat\": \"Intestine\", \"extremophile\": False},\n        {\"name\": \"Antarctic Krill\", \"habitat\": \"Cold Water\", \"extremophile\": True}\n    ]\n\n    def is_extremophile(organism):\n        \"\"\"\n        Checks if the organism is an extremophile.\n        \n        Args:\n            organism (Any): The organism to be checked.\n        \n        Returns:\n            bool: True if the organism is an extremophile, False otherwise.\n        \"\"\"\n        return organism.get(\"extremophile\", False)\n\n    def transform_organism(organism):\n        \"\"\"\n        Transforms the organism data into a summary string.\n        \n        Args:\n            organism (Any): The organism to be transformed.\n        \n        Returns:\n            str: A string representation of the organism including its name and habitat.\n        \"\"\"\n        return f\"{organism['name']} inhabits {organism['habitat']}\"\n\n    # Process the organisms using filtering and transformation\n    processed_organisms = process_extremophiles(\n        organisms, \n        condition=is_extremophile, \n        transform=transform_organism\n    )\n    \n    # Output the results\n    for organism in processed_organisms:\n        print(organism)\n\nif __name__ == \"__main__\":\n    example_usage()\n```",
                "Incorrect_Answers": [
                    "```python\ndef analyze_species_diversification(species_data, threshold):\n    \"\"\"\n    Analyzes the diversification of species based on the provided data.\n\n    Parameters:\n        species_data (list of dict): A list of dictionaries, each containing\n                                     'species_name' and 'traits' of different species.\n        threshold (float): The minimum diversification score needed to consider a species diversified.\n\n    Returns:\n        list: A list of species names that have a diversification score above the threshold.\n    \"\"\"\n    diversified_species = []\n\n    for species in species_data:\n        try:\n            diversification_score = calculate_diversification_score(species['traits'])\n            if diversification_score > threshold:\n                diversified_species.append(species['species_name'])\n        except KeyError as e:\n            print(f\"Missing data for species: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n    return diversified_species\n\ndef calculate_diversification_score(traits):\n    \"\"\"\n    Calculates the diversification score for a set of traits.\n\n    Parameters:\n        traits (list of float): A list containing trait measurements of a species.\n\n    Returns:\n        float: The calculated diversification score.\n    \"\"\"\n\n    if not traits:\n        raise ValueError(\"Traits list is empty.\")\n\n    mean_trait = sum(traits) / len(traits)\n    squared_differences = [(trait - mean_trait) ** 2 for trait in traits]\n    diversification_score = sum(squared_differences) / len(traits)\n    \n    return diversification_score\n\n# Sample usage\nif __name__ == \"__main__\":\n    species_list = [\n        {'species_name': 'Canis lupus', 'traits': [12.3, 14.5, 13.7]},\n        {'species_name': 'Homo sapiens', 'traits': [15.0, 15.5, 14.8]},\n        {'species_name': 'Panthera leo', 'traits': [10.5, 11.2, 10.9]}\n    ]\n    threshold = 1.0\n    diversified = analyze_species_diversification(species_list, threshold)\n    print(\"Diversified species:\", diversified)\n```",
                    "```python\n# Import necessary libraries\nimport math\nfrom statistics import mean\n\n# Define a class to represent a football Team\nclass Team:\n    \"\"\"A class to represent a football team.\"\"\"\n\n    def __init__(self, name, players):\n        \"\"\"Initialize the team with a name and list of players.\"\"\"\n        self.name = name\n        self.players = players\n\n    def average_yards_per_game(self, yards_list):\n        \"\"\"\n        Calculate the average yards per game.\n\n        :param yards_list: List of yards gained in each game.\n        :return: Average yards per game as a float.\n        \"\"\"\n        try:\n            return mean(yards_list)\n        except Exception as e:\n            print(f\"Error calculating average: {e}\")\n            return 0.0\n\n# Function to calculate player speed\ndef calculate_speed(distance, time):\n    \"\"\"\n    Calculate the speed of a player.\n\n    :param distance: The distance covered, in meters.\n    :param time: Time taken to cover the distance, in seconds.\n    :return: Speed in meters per second.\n    \"\"\"\n    try:\n        speed = distance / time\n        return round(speed, 2)\n    except ZeroDivisionError:\n        return float('inf')  # Infinite speed when time is zero\n\n# Main function to demonstrate functionality\ndef main():\n    \"\"\"\n    Main function to demonstrate team and player calculations.\n    \"\"\"\n    team = Team(\"Eagles\", [\"Alex\", \"Jordan\", \"Riley\"])\n    yards_list = [120, 140, 150, 130]\n\n    avg_yards = team.average_yards_per_game(yards_list)\n    print(f\"Average Yards per Game: {avg_yards}\")\n\n    player_distance = 100  # meters\n    player_time = 9.58  # seconds, Usain Bolt's record time\n\n    player_speed = calculate_speed(player_distance, player_time)\n    print(f\"Player Speed: {player_speed} m/s\")\n\n\n# Run the main function\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport os\nimport sys\nfrom datetime import datetime\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef capture_and_save_photos(image_paths, output_directory):\n    \"\"\"\n    Processes images from a list of file paths and saves them to an output directory.\n    \n    :param image_paths: List of strings representing paths to image files.\n    :param output_directory: String path to directory where processed images will be saved.\n    \"\"\"\n    for path in image_paths:\n        try:\n            # Check if path is a valid file\n            if os.path.isfile(path):\n                # Simulate image processing\n                image_data = np.random.rand(100, 100, 3)  # Mock image array\n                image_name = os.path.basename(path)\n\n                save_image(image_data, output_directory, image_name)\n            else:\n                print(f\"Invalid file path: {path}\")\n        except Exception as e:\n            print(f\"An error occurred while processing the image: {e}\")\n\ndef save_image(image_data, output_directory, image_name):\n    \"\"\"\n    Saves an image represented by a numpy array to a specified directory.\n\n    :param image_data: Numpy array representing the image.\n    :param output_directory: String path to directory where the image will be saved.\n    :param image_name: The name of the image file.\n    \"\"\"\n    try:\n        os.makedirs(output_directory, exist_ok=True)\n        file_path = os.path.join(output_directory, image_name)\n        plt.imsave(file_path, image_data)\n        print(f\"Image saved to {file_path}\")\n    except Exception as e:\n        print(f\"Failed to save image {image_name}: {e}\")\n\ndef main():\n    \"\"\"\n    Main function to execute the photo capturing and saving process.\n    \"\"\"\n    # Example usage of the capture_and_save_photos function\n    test_image_paths = ['./images/photo1.jpg', './images/photo2.jpg']\n    capture_and_save_photos(test_image_paths, './output')\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List\n\ndef analyze_extremophiles(organisms: List[dict]) -> List[dict]:\n    \"\"\"\n    Analyzes a list of biological organisms and returns only those\n    identified as extremophiles. Utilizes their characteristics to \n    suggest potential biotechnological applications.\n\n    Parameters:\n    organisms (List[dict]): A list of dictionaries where each dictionary \n    contains details about an organism such as name, habitat, and \n    extremophile status.\n\n    Returns:\n    List[dict]: A list of dictionaries with extremophiles and their \n    potential applications.\n    \"\"\"\n    try:\n        extremophiles = [\n            organism for organism in organisms if organism.get('is_extremophile')\n        ]\n        # Mock potential application discovery for extremophiles\n        for organism in extremophiles:\n            organism['applications'] = identify_applications(organism)\n    except Exception as e:  # Ensure robust error-catching for data issues\n        print(f\"Error processing organisms data: {e}\")\n        extremophiles = []\n\n    return extremophiles\n\ndef identify_applications(organism: dict) -> List[str]:\n    \"\"\"\n    Determines potential applications for a given extremophile based \n    on its unique characteristics.\n\n    Parameters:\n    organism (dict): A dictionary with details of the organism, \n    including its unique adaptations.\n\n    Returns:\n    List[str]: A list of strings describing possible applications.\n    \"\"\"\n    applications = []\n    adaptations = organism.get('adaptations', [])\n\n    # Analyze adaptations to suggest applications\n    if 'thermostable' in adaptations:\n        applications.append('Thermostable enzymes for industrial processes')\n    if 'radiation_resistant' in adaptations:\n        applications.append('Bioremediation in nuclear sites')\n    if 'acidophilic' in adaptations:\n        applications.append('Bio-mining for metal recovery')\n\n    return applications\n\n# Sample data structure\ntest_organisms = [\n    {'name': 'Organism A', 'is_extremophile': True, 'adaptations': ['thermostable']},\n    {'name': 'Organism B', 'is_extremophile': False},\n    {'name': 'Organism C', 'is_extremophile': True, 'adaptations': ['acidophilic', 'radiation_resistant']}\n]\n\n# Run analysis\nextremophiles_analyzed = analyze_extremophiles(test_organisms)\nfor ext in extremophiles_analyzed:\n    # Inline comments explain significance of outcome\n    print(f\"{ext['name']} applications: {ext['applications']}\")\n```\n",
                "Incorrect_Answers": [
                    "```python\n# Importing necessary modules\nimport requests\nimport json\nfrom typing import List, Dict\n\ndef get_team_data(team_id: int) -> Dict:\n    \"\"\"\n    Fetches team data from an external API.\n    \n    :param team_id: The ID of the team to fetch data for.\n    :return: A dictionary containing team data.\n    \"\"\"\n    url = f\"https://api.example.com/teams/{team_id}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return {}\n\ndef calculate_win_percentage(games_won: int, total_games: int) -> float:\n    \"\"\"\n    Calculates the win percentage of a team.\n    \n    :param games_won: The number of games won by the team.\n    :param total_games: The total number of games played by the team.\n    :return: The win percentage as a float.\n    \"\"\"\n    try:\n        win_percentage = (games_won / total_games) * 100\n        return round(win_percentage, 2)\n    except ZeroDivisionError:\n        return 0.0\n\ndef display_team_statistics(team_stats: Dict) -> None:\n    \"\"\"\n    Displays the statistics for a given team.\n    \n    :param team_stats: A dictionary containing team statistics.\n    \"\"\"\n    print(f\"Team Name: {team_stats.get('name', 'N/A')}\")\n    print(f\"Win Percentage: {team_stats.get('win_percentage', 'N/A')}%\")\n\ndef main():\n    \"\"\"\n    Main function to drive the program execution.\n    \"\"\"\n    team_id = 42  # Example team ID\n    team_data = get_team_data(team_id)\n    games_won = team_data.get('games_won', 0)\n    total_games = team_data.get('total_games', 0)\n    win_percentage = calculate_win_percentage(games_won, total_games)\n    team_data['win_percentage'] = win_percentage\n    display_team_statistics(team_data)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport sys\nfrom collections import defaultdict\n\n\nclass BiodiversityDatabase:\n    \"\"\"A class to manage a basic biodiversity database.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the biodiversity database.\"\"\"\n        self.species_information = defaultdict(dict)\n\n    def add_species(self, scientific_name, common_name, conservation_status):\n        \"\"\"\n        Add a new species entry to the database.\n\n        Parameters:\n        scientific_name (str): The scientific name of the species.\n        common_name (str): The common name of the species.\n        conservation_status (str): The current conservation status of the species.\n        \"\"\"\n        if scientific_name in self.species_information:\n            print(f\"Warning: '{scientific_name}' already exists in the database.\")\n            return\n\n        self.species_information[scientific_name] = {\n            'common_name': common_name,\n            'conservation_status': conservation_status\n        }\n\n    def get_species_info(self, scientific_name):\n        \"\"\"\n        Retrieve information about a species.\n\n        Parameters:\n        scientific_name (str): The scientific name of the species.\n\n        Returns:\n        dict: A dictionary containing the species information.\n        \"\"\"\n        try:\n            return self.species_information[scientific_name]\n        except KeyError:\n            print(f\"Error: '{scientific_name}' not found in the database.\")\n            return None\n\n    def update_conservation_status(self, scientific_name, new_status):\n        \"\"\"\n        Update the conservation status of an existing species.\n\n        Parameters:\n        scientific_name (str): The scientific name of the species.\n        new_status (str): The new conservation status of the species.\n        \"\"\"\n        if scientific_name not in self.species_information:\n            print(f\"Error: '{scientific_name}' not found in the database.\")\n            return\n\n        self.species_information[scientific_name]['conservation_status'] = new_status\n\n    def list_all_species(self):\n        \"\"\"\n        List all species currently in the database.\n\n        Returns:\n        list: A list of scientific names of all species in the database.\n        \"\"\"\n        return list(self.species_information.keys())\n\n\ndef main():\n    db = BiodiversityDatabase()\n    db.add_species('Trillium_grandiflorum', 'White Trillium', 'Vulnerable')\n    db.add_species('Asclepias_tuberosa', 'Butterfly Weed', 'Least Concern')\n\n    print(db.get_species_info('Trillium_grandiflorum'))\n    db.update_conservation_status('Asclepias_tuberosa', 'Near Threatened')\n    print(db.get_species_info('Asclepias_tuberosa'))\n\n    print(\"All species in database:\", db.list_all_species())\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```",
                    "```python\nfrom datetime import datetime\nfrom typing import List, Dict\n\nclass Event:\n    \"\"\"Represents a gaming event with sustainability metrics.\"\"\"\n    \n    def __init__(self, name: str, date: str, attendees: int, eco_friendly: bool):\n        \"\"\"\n        Initialize an Event instance.\n\n        :param name: The name of the event.\n        :param date: The date of the event in 'YYYY-MM-DD' format.\n        :param attendees: The number of attendees.\n        :param eco_friendly: Whether the event is eco-friendly.\n        \"\"\"\n        self.name = name\n        self.date = datetime.strptime(date, '%Y-%m-%d')\n        self.attendees = attendees\n        self.eco_friendly = eco_friendly\n\n    def is_upcoming(self) -> bool:\n        \"\"\"\n        Check if the event is upcoming.\n\n        :return: True if the event is upcoming, else False.\n        \"\"\"\n        return self.date > datetime.now()\n\n\ndef calculate_carbon_footprint(events: List[Event]) -> Dict[str, float]:\n    \"\"\"\n    Calculate the carbon footprint for a list of events.\n\n    :param events: A list of Event instances.\n    :return: A dictionary mapping event names to their carbon footprint values.\n    \"\"\"\n    carbon_footprint = {}\n    for event in events:\n        try:\n            base_footprint = 50  # Base footprint per event\n            footprint = base_footprint * event.attendees\n            if event.eco_friendly:\n                # Apply a reduction for eco-friendly events\n                footprint *= 0.8\n            carbon_footprint[event.name] = footprint\n        except ValueError as e:\n            print(f\"Error calculating footprint for {event.name}: {e}\")\n\n    return carbon_footprint\n\n\ndef get_event_data() -> List[Event]:\n    \"\"\"\n    Retrieve event data.\n\n    :return: A list of Event instances.\n    \"\"\"\n    sample_data = [\n        {'name': 'EcoCon', 'date': '2024-05-16', 'attendees': 1500, 'eco_friendly': True},\n        {'name': 'GameFest', 'date': '2024-06-20', 'attendees': 3000, 'eco_friendly': False},\n        {'name': 'SustainPlay', 'date': '2024-04-12', 'attendees': 2300, 'eco_friendly': True}\n    ]\n    \n    events = [Event(**event_info) for event_info in sample_data]\n    \n    return events\n\n\n# Example usage\nif __name__ == \"__main__\":\n    events = get_event_data()\n    print(calculate_carbon_footprint(events))\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List\n\ndef identify_extremophiles(organisms: List[dict]) -> List[dict]:\n    \"\"\"\n    Identifies extremophiles from a given list of organisms.\n\n    Parameters:\n    organisms (List[dict]): A list of dictionaries where each dictionary\n                            represents an organism with its properties.\n\n    Returns:\n    List[dict]: A filtered list of dictionaries containing only extremophiles.\n    \"\"\"\n    try:\n        # Use list comprehension to filter extremophiles\n        extremophiles = [\n            organism for organism in organisms \n            if organism.get('is_extremophile', False)\n        ]\n        return extremophiles\n    except Exception as e:\n        # Handle exceptions, ideally logging the error for later analysis\n        print(f\"Error identifying extremophiles: {e}\")\n        return []\n\ndef calculate_habitat_diversity(extremophiles: List[dict]) -> int:\n    \"\"\"\n    Calculates the number of unique habitats among the extremophiles.\n\n    Parameters:\n    extremophiles (List[dict]): A list of dictionaries with extremophile data.\n\n    Returns:\n    int: The count of unique habitats.\n    \"\"\"\n    try:\n        habitats = {\n            organism['habitat'] for organism in extremophiles \n            if 'habitat' in organism\n        }\n        return len(habitats)\n    except Exception as e:\n        # Handle any errors in extracting habitat information\n        print(f\"Error calculating habitat diversity: {e}\")\n        return 0\n\n# Example usage\ndata = [\n    {'name': 'Organism A', 'is_extremophile': True, 'habitat': 'Desert'},\n    {'name': 'Organism B', 'is_extremophile': False},\n    {'name': 'Organism C', 'is_extremophile': True, 'habitat': 'Deep Sea'}\n]\n\nextremophiles = identify_extremophiles(data)\ndiversity = calculate_habitat_diversity(extremophiles)\n\nprint(f\"Identified Extremophiles: {extremophiles}\")\nprint(f\"Habitat Diversity: {diversity}\")\n```",
                "Incorrect_Answers": [
                    "```python\n# Yo, it's your fave coder droppin' rhymes and functions\ndef drop_the_mic(tracks):\n    \"\"\"\n    Lay down your tracks like a boss, calculate the fire level.\n    \"\"\"\n    try:\n        # Peep the beat sum and divide to find the heat\n        heat_rating = sum(tracks) / len(tracks) if tracks else \"Can't drop vibes with no beats!\"\n    except Exception as e:\n        # Drop a bold statement, no weak messages here\n        return f\"Oops, we hit a static: {str(e)} - Fix it up!\"\n\n    return heat_rating\n\n# Checking the vibe of a set list\ndef where_the_flow_at():\n    \"\"\"\n    Check if the rhythm's on point or if we're stuck on repeat.\n    \"\"\"\n    # Sampling track lengths in seconds\n    tracks = [210, 195, 220]  # Keep that flow tight\n\n    # Modular functions keeping it real\n    fire_level = drop_the_mic(tracks)\n\n    return f\"Your tracks are flowin' at a fire level of: {fire_level}\"\n    \nfire_meter = where_the_flow_at()\nprint(fire_meter)\n```\n",
                    "```python\n# Import necessary modules for working with extremophiles\nimport os\nfrom typing import List, Callable\n\n# Define a function to check if an organism is an extremophile\ndef is_extremophile(organism: str) -> bool:\n    \"\"\"\n    Determine whether a given organism is classified as an extremophile.\n    \n    An extremophile is an organism that thrives in physically or \n    geochemically extreme conditions that are detrimental to most \n    life on Earth.\n    \n    Parameters:\n    organism (str): Name of the organism to be analyzed.\n    \n    Returns:\n    bool: True if the organism is an extremophile, else False.\n    \"\"\"\n    extremophile_keywords = ['thermophile', 'acidophile', 'halophile']\n    return any(keyword in organism.lower() for keyword in extremophile_keywords)\n\n# Define a function to filter extremophiles from a list of organisms\ndef filter_extremophiles(organisms: List[str]) -> List[str]:\n    \"\"\"\n    Filter and return only the extremophiles from a list of organisms.\n    \n    Parameters:\n    organisms (List[str]): List containing names of organisms.\n    \n    Returns:\n    List[str]: A list containing only extremophiles.\n    \"\"\"\n    # Use list comprehension for concise and readable code\n    return [organism for organism in organisms if is_extremophile(organism)]\n\n# Define the main function to demonstrate functionality\ndef main():\n    \"\"\"\n    Main function to demonstrate the retrieval of extremophiles from\n    a sample list of organisms. Prints the list of extremophiles.\n    \"\"\"\n    sample_organisms = [\n        'Escherichia coli', \n        'Thermus aquaticus', \n        'Haloferax volcanii', \n        'Picrophilus torridus'\n    ]\n    \n    # Filter extremophiles using the defined function\n    extremophiles = filter_extremophiles(sample_organisms)\n\n    # Display the filtered extremophiles\n    print(f\"Extremophiles found: {extremophiles}\")\n\n# Ensure the main function runs when this script is executed\nif __name__ == '__main__':\n    main()\n```",
                    "```python\n\"\"\"\nThis module provides functions to calculate family expenses and suggest budget-friendly activities.\n\"\"\"\n\ndef calculate_expenses(expenses_list):\n    \"\"\"\n    Calculate the total amount of expenses from a list.\n\n    Parameters:\n    expenses_list (list): A list of expense amounts (floats or ints).\n\n    Returns:\n    float: The total sum of expenses.\n    \"\"\"\n    try:\n        total_expenses = sum(expenses_list)\n        return total_expenses\n    except TypeError:\n        print(\"Error: All elements in the expenses list must be numbers.\")\n        return 0.0\n\n\ndef suggest_activities(total_budget, family_size):\n    \"\"\"\n    Suggest budget-friendly activities based on the available budget and family size.\n\n    Parameters:\n    total_budget (float): The total budget for activities.\n    family_size (int): The number of family members.\n\n    Returns:\n    list: A list of suggested activities.\n    \"\"\"\n    indoor_activities = [\"Family movie night\", \"Board games\", \"Cooking and baking together\"]\n    outdoor_activities = [\"Picnic at the park\", \"Hiking\", \"Visit a free museum\"]\n\n    suggested_activities = indoor_activities + outdoor_activities\n    affordable_activities = [activity for activity in suggested_activities if total_budget >= family_size * 10]\n\n    return affordable_activities\n\n\ndef main():\n    \"\"\"\n    Main function to execute the family expense calculation and activity suggestion.\n    \"\"\"\n    # Example usage of the functions\n    monthly_expenses = [200.0, 150.5, 320.0, 45.0]  # List of monthly expenses\n    total_monthly_expenses = calculate_expenses(monthly_expenses)\n    print(f\"Total monthly expenses: {total_monthly_expenses}\")\n\n    family_budget = 100.0  # Budget for activities\n    family_members = 4  # Number of family members\n    activities = suggest_activities(family_budget, family_members)\n    print(\"Suggested activities:\", activities)\n\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List, Dict\n\nclass Extremophile:\n    \"\"\"\n    A class to represent extremophiles and their unique adaptations.\n    \n    Attributes:\n        name (str): The name of the extremophile.\n        adaptations (List[str]): List of adaptations the extremophile has.\n        usual_habitat (str): The typical habitat the extremophile thrives in.\n    \"\"\"\n\n    def __init__(self, name: str, adaptations: List[str], usual_habitat: str):\n        \"\"\"\n        Constructs all the necessary attributes for the extremophile object.\n\n        Parameters:\n           name (str): The name of the extremophile.\n           adaptations (List[str]): List of adaptations the extremophile has.\n           usual_habitat (str): The typical habitat the extremophile thrives in.\n        \"\"\"\n        self.name = name\n        self.adaptations = adaptations\n        self.usual_habitat = usual_habitat\n\n    def is_thrive_in_harsh_conditions(self) -> bool:\n        \"\"\"\n        Determine if an extremophile thrives in harsh conditions based on adaptations.\n\n        Returns:\n            bool: True if more than two adaptations known, otherwise False.\n        \"\"\"\n        return len(self.adaptations) > 2\n\ndef analyze_extremophiles(extremophiles: List[Extremophile]) -> Dict[str, int]:\n    \"\"\"\n    Analyze a list of extremophiles to count how many thrive in harsh conditions.\n\n    Parameters:\n        extremophiles (List[Extremophile]): List of extremophile instances.\n\n    Returns:\n        Dict[str, int]: Dictionary with a count of how many extremophiles thrive.\n    \"\"\"\n    counts = {\n        'total': len(extremophiles),\n        'thriving_in_harsh_conditions': sum(\n            1 for ext in extremophiles if ext.is_thrive_in_harsh_conditions()\n        )\n    }\n    return counts\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the extremophile analysis process.\n    \"\"\"\n    # Sample data of extremophiles\n    extremophiles_data = [\n        Extremophile(\"Thermococcus\", [\"heat resistance\", \"high radiation tolerance\"], \"hydrothermal vent\"),\n        Extremophile(\"Deinococcus\", [\"radiation resistance\"], \"desert\"),\n        Extremophile(\"Halobacterium\", [\"salt tolerance\", \"UV radiation tolerance\", \"desiccation resistance\"], \"salt flat\")\n    ]\n    \n    try:\n        analysis_result = analyze_extremophiles(extremophiles_data)\n        print(f\"Number of extremophiles analyzed: {analysis_result['total']}\")\n        print(f\"Number thriving in harsh conditions: {analysis_result['thriving_in_harsh_conditions']}\")\n    except Exception as e:\n        # Proper error handling for unexpected scenarios\n        print(f\"An error occurred during analysis: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n",
                "Incorrect_Answers": [
                    "```python\nimport math\nfrom typing import List, Tuple\n\nclass Wildflower:\n    \"\"\"Represents a wildflower with species name and pollinator count.\"\"\"\n    \n    def __init__(self, species_name: str, pollinator_count: int):\n        \"\"\"\n        Initializes a Wildflower object.\n        \n        :param species_name: The name of the wildflower species.\n        :param pollinator_count: The number of pollinators that interact with the wildflower.\n        \"\"\"\n        self.species_name = species_name\n        self.pollinator_count = pollinator_count\n\ndef calculate_pollinator_effectiveness(wildflowers: List[Wildflower]) -> List[Tuple[str, float]]:\n    \"\"\"\n    Calculates the effectiveness of pollinators for each wildflower.\n\n    :param wildflowers: A list of Wildflower objects to evaluate.\n    :return: A list of tuples containing the species name and the calculated effectiveness.\n    \"\"\"\n    effectiveness_results = []\n    \n    for flower in wildflowers:\n        try:\n            effectiveness = math.log1p(flower.pollinator_count)\n            effectiveness_results.append((flower.species_name, round(effectiveness, 2)))\n        except ValueError as e:\n            print(f\"Error calculating effectiveness for {flower.species_name}: {e}\")\n    \n    return effectiveness_results\n\ndef display_effectiveness(effectiveness_data: List[Tuple[str, float]]) -> None:\n    \"\"\"\n    Displays the effectiveness data for each wildflower species.\n    \n    :param effectiveness_data: A list of tuples containing species name and effectiveness.\n    \"\"\"\n    for species_name, effectiveness in effectiveness_data:\n        print(f\"{species_name}: {effectiveness}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    wildflower_list = [\n        Wildflower(\"Bluebell\", 10),\n        Wildflower(\"Sunflower\", 25),\n        Wildflower(\"Daisy\", 0)  # Test case with zero pollinators\n    ]\n    effectiveness = calculate_pollinator_effectiveness(wildflower_list)\n    display_effectiveness(effectiveness)\n```",
                    "```python\ndef drop_the_mic(beats, lyrics):\n    \"\"\"\n    \ud83c\udfa4 This function spits fire, blending blazing beats and fresh lyrics to make that track a banger!\n    \"\"\"\n    try:\n        combos = sum(beats) + sum(lyrics)\n        return combos\n    except Exception as err:\n        raise ValueError(\"\ud83d\udd25 Yo, something's not vibing: \" + str(err))\n\ndef drop_rhymes():\n    \"\"\"\n    \ud83c\udfb6 Unleash the poetic flow! \ud83c\udfb6\n    \"\"\"\n    flows = ['syncopate', 'resonate', 'celebrate']\n    for flow in flows:\n        print(f\"Rhyme and {flow}!\")\n\ndef keep_it_real(music, message):\n    \"\"\"\n    \ud83d\udce2 Keep it genuine while laying down tracks that matter. \ud83c\udf1f\n    \"\"\"\n    if not music or not message:\n        raise ValueError(\"\u26a0\ufe0f Can't fake the funk, check your inputs!\")\n    \n    harmony = []\n    for track in music:\n        if 'authentic' in track:\n            harmony.append(track)\n    \n    return \"Realness amplified: \" + ' '.join(harmony)\n\n# Import that matters\nimport random\n\ndef freestyle_session(freestylers):\n    \"\"\"\n    \ud83e\udd18 Let the knowledge-flow begin with each freestyler stepping to the mic. \ud83e\udd18\n    \"\"\"\n    random.shuffle(freestylers)\n    for artist in freestylers:\n        print(f\"\ud83c\udfa4 Next up: {artist} dropping gems!\")\n```\n",
                    "```python\n# football_team.py\n\n\"\"\"\nThis module defines a simple Football Team system with players and statistics.\nIt aligns with Alex \"Eagle\" Rivers' coding and formatting preferences, \nincluding consistent naming conventions, comprehensive documentation, and modular design.\n\"\"\"\n\nclass Player:\n    \"\"\"\n    A class to represent a football player.\n    \n    Attributes\n    ----------\n    name : str\n        name of the player\n    position : str\n        player's position on the team\n    total_yards : float\n        total yards gained by the player\n    games_played : int\n        number of games played by the player\n\n    Methods\n    -------\n    average_yards_per_game():\n        Calculates the average yards per game.\n    \"\"\"\n    def __init__(self, name: str, position: str, total_yards: float, games_played: int):\n        self.name = name\n        self.position = position\n        self.total_yards = total_yards\n        self.games_played = games_played\n        \n    def average_yards_per_game(self) -> float:\n        \"\"\"\n        Calculate the average yards a player gains per game.\n        \n        Returns\n        -------\n        float\n            Average yards per game if games have been played, else 0.\n        \"\"\"\n        try:\n            return self.total_yards / self.games_played if self.games_played > 0 else 0.0\n        except ZeroDivisionError:\n            return 0.0\n\nclass Team:\n    \"\"\"\n    A class to represent a football team.\n    \n    Attributes\n    ----------\n    name : str\n        name of the team\n    players : list\n        list of Player objects part of the team\n    \n    Methods\n    -------\n    add_player(player: Player):\n        Adds a new player to the team.\n        \n    total_average_yards():\n        Computes the team's average yards per game.\n    \"\"\"\n    def __init__(self, name: str):\n        self.name = name\n        self.players = []\n        \n    def add_player(self, player: Player) -> None:\n        \"\"\"\n        Add a player to the team roster.\n        \n        Parameters\n        ----------\n        player : Player\n            The player to add to the team\n        \"\"\"\n        self.players.append(player)\n        \n    def total_average_yards(self) -> float:\n        \"\"\"\n        Calculate the team's average yards per game.\n        \n        Returns\n        -------\n        float\n            Average yards for all players per game.\n        \"\"\"\n        total_yards = sum(player.average_yards_per_game() for player in self.players)\n        return total_yards / len(self.players) if self.players else 0.0\n\n# Example usage\nif __name__ == \"__main__\":\n    alex = Player(\"Alex Rivers\", \"Quarterback\", 1500.0, 10)\n    team = Team(\"Indigenous Eagles\")\n    team.add_player(alex)\n    \n    # Calculate and print team's average yards\n    team_avg_yards = team.total_average_yards()\n    print(f\"The average yards per game for the {team.name} is: {team_avg_yards}\")\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List, Optional\n\nclass Extremophile:\n    def __init__(self, name: str, habitat: str):\n        \"\"\"Initialize with name and habitat of the extremophile.\"\"\"\n        self.name = name\n        self.habitat = habitat\n\n    def is_extremophile(self) -> bool:\n        \"\"\"Determine if the organism is an extremophile based on habitat information.\"\"\"\n        extreme_conditions = ['hot_spring', 'deep_sea_vent', 'antarctic_ice']\n        return self.habitat in extreme_conditions\n\ndef process_organisms(data: List[Extremophile]) -> List[str]:\n    \"\"\"\n    Process a list of organisms and return the names of extremophiles.\n\n    Parameters:\n    - data: A list of Extremophile objects representing various organisms.\n\n    Returns:\n    - A list of names of organisms that are classified as extremophiles.\n    \"\"\"\n    return [organism.name for organism in data if organism.is_extremophile()]\n\ndef parse_organism_data(raw_data: List[dict]) -> List[Extremophile]:\n    \"\"\"\n    Parse raw data into Extremophile objects, ensuring proper error handling.\n\n    Parameters:\n    - raw_data: A list of dictionaries containing organism data.\n\n    Returns:\n    - A list of Extremophile objects.\n    \"\"\"\n    organisms: List[Extremophile] = []\n    for entry in raw_data:\n        try:\n            organism = Extremophile(name=entry['name'], habitat=entry['habitat'])\n            organisms.append(organism)\n        except KeyError as e:\n            print(f\"Missing required data field: {e}\")\n    return organisms\n\ndef main(raw_data: Optional[List[dict]] = None) -> Optional[List[str]]:\n    \"\"\"\n    Main function to demonstrate processing of organism data.\n\n    Parameters:\n    - raw_data: Optional list of dictionaries containing raw organism data.\n\n    Returns:\n    - Optional list of names of extremophiles if data is provided; otherwise None.\n    \"\"\"\n    if raw_data is not None:\n        organisms = parse_organism_data(raw_data)\n        return process_organisms(organisms)\n\n# Example use\nexample_data = [\n    {\"name\": \"Thermus aquaticus\", \"habitat\": \"hot_spring\"},\n    {\"name\": \"Escherichia coli\", \"habitat\": \"intestine\"},\n]\n\nextremophile_names = main(example_data)\nprint(extremophile_names)  # Expected output: ['Thermus aquaticus']\n```",
                "Incorrect_Answers": [
                    "```python\nimport os\nimport sys\n\ndef calculate_conservation_needed(urban_area, biodiversity_index):\n    \"\"\"\n    Calculate the level of conservation effort needed based on urbanization\n    impact and biodiversity index.\n\n    Parameters:\n    urban_area (float): The proportion of land used for urban development.\n    biodiversity_index (float): A measure of biodiversity health, where higher\n    values indicate a healthier ecosystem.\n\n    Returns:\n    str: A message indicating the needed conservation effort.\n    \"\"\"\n    try:\n        if urban_area < 0 or biodiversity_index < 0:\n            raise ValueError(\"Input values must be non-negative.\")\n\n        conservation_effort = (1 - biodiversity_index) * urban_area\n        \n        if conservation_effort > 0.5:\n            return \"High conservation effort needed.\"\n        elif conservation_effort > 0.2:\n            return \"Moderate conservation effort needed.\"\n        else:\n            return \"Low conservation effort needed.\"\n    except ValueError as ve:\n        return f\"Value Error: {ve}\"\n    except Exception as e:\n        return f\"An unexpected error occurred: {e}\"\n\ndef main():\n    \"\"\"\n    Main function to execute the conservation calculation.\n    \"\"\"\n    urban_area = 0.6      # Example urban area proportion\n    biodiversity_index = 0.3  # Example biodiversity health index\n    \n    message = calculate_conservation_needed(urban_area, biodiversity_index)\n    \n    print(message)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport json\nfrom typing import List, Dict\n\n\ndef calculate_carbon_footprint(event_data: Dict[str, float]) -> float:\n    \"\"\"Calculate the carbon footprint of an event.\n\n    Args:\n        event_data (Dict[str, float]): A dictionary containing the data relevant to the event.\n\n    Returns:\n        float: The calculated carbon footprint of the event.\n    \"\"\"\n    try:\n        attendees = event_data['attendees']\n        transportation_per_attendee = event_data['transportation_per_attendee']\n        energy_use = event_data['energy_use']\n\n        carbon_footprint = (attendees * transportation_per_attendee) + energy_use\n        return carbon_footprint\n    except KeyError as e:\n        print(f\"Missing key in event data: {e}\")\n        return 0.0\n\n\ndef get_event_data(file_path: str) -> List[Dict[str, float]]:\n    \"\"\"Retrieve event data from a JSON file.\n\n    Args:\n        file_path (str): The path to the JSON file containing event data.\n\n    Returns:\n        List[Dict[str, float]]: A list of dictionaries with event-related data.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n            return data\n    except FileNotFoundError:\n        print(f\"File not found: {file_path}\")\n        return []\n    except json.JSONDecodeError:\n        print(f\"Error decoding JSON from file: {file_path}\")\n        return []\n\n\ndef eco_friendly_events(events: List[Dict[str, float]]) -> List[Dict[str, float]]:\n    \"\"\"Filter events that meet eco-friendly criteria.\n\n    Args:\n        events (List[Dict[str, float]]): A list of event dictionaries to be filtered.\n\n    Returns:\n        List[Dict[str, float]]: A filtered list of events that are eco-friendly.\n    \"\"\"\n    return [event for event in events if calculate_carbon_footprint(event) < 1000.0]\n\n\ndef main():\n    file_path = 'events.json'\n    events = get_event_data(file_path)\n    filtered_events = eco_friendly_events(events)\n    \n    for event in filtered_events:\n        print(f\"Eco-friendly event: {event['name']} with footprint {calculate_carbon_footprint(event)} kg CO2\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n",
                    "```python\n# localization_utils.py\n\n\"\"\"\nThis module provides utilities for handling localization in our mobile app.\nIt includes functions for getting localized strings based on user preferences\nand checking if a language is supported by our system.\n\nExample:\n    from localization_utils import get_localized_string\n\n    greeting = get_localized_string('en')\n\"\"\"\n\nimport logging\n\n# Importing standard libraries\nimport os\n\n# Importing local libraries\nfrom localization_data import translations\n\n# Setting up logging\nlogging.basicConfig(level=logging.INFO)\n\n# Supported languages\nsupported_languages = {'en', 'fr', 'es'}\n\ndef get_localized_string(lang):\n    \"\"\"\n    Fetches the localized string based on user preference.\n    \n    Args:\n        lang (str): The language code to fetch the string for.\n    \n    Returns:\n        str: The localized string.\n    \n    Raises:\n        ValueError: If the provided language code is unsupported.\n    \"\"\"\n    if lang not in supported_languages:\n        logging.error(f\"Unsupported language code: {lang}\")\n        raise ValueError('Unsupported language code')\n\n    return translations.get(lang, translations['default'])\n\ndef add_translation(lang, translation):\n    \"\"\"\n    Adds or updates a translation for a specific language.\n\n    Args:\n        lang (str): The language code to update the translation for.\n        translation (str): The translation text.\n\n    Returns:\n        None\n    \"\"\"\n    if lang in translations:\n        logging.info(f\"Updating translation for language: {lang}\")\n    else:\n        logging.info(f\"Adding new translation for language: {lang}\")\n        \n    translations[lang] = translation\n\ndef is_language_supported(lang):\n    \"\"\"\n    Checks if a given language code is supported.\n\n    Args:\n        lang (str): The language code to check.\n    \n    Returns:\n        bool: True if supported, False otherwise.\n    \"\"\"\n    return lang in supported_languages\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom math import exp\nfrom typing import List, Tuple, Optional\n\ndef calculate_thermal_adaptation_growth(\n        temperatures: List[float],\n        growth_rate_model: str) -> List[Optional[float]]:\n    \"\"\"\n    Calculates predicted growth rates of extremophiles given a list of temperatures\n    and a model type for growth rate calculation.\n\n    Parameters:\n    temperatures (List[float]): A list of temperatures (in Celsius) at which to calculate growth rates.\n    growth_rate_model (str): The model to use for calculation, either 'Arrhenius' or 'Q10'.\n\n    Returns:\n    List[Optional[float]]: A list of calculated growth rates or None if the temperature is out of model bounds.\n    \"\"\"\n    \n    def arrhenius_model(temp: float) -> Optional[float]:\n        \"\"\"Calculate growth rate using Arrhenius model.\"\"\"\n        try:\n            activation_energy = 0.65  # Example energy in eV\n            boltzmann_constant = 8.617333262145e-5  # eV/K\n\n            return exp(-activation_energy / (boltzmann_constant * (temp + 273.15)))\n        except Exception as e:\n            print(f\"Error calculating Arrhenius model at {temp}C: {e}\")\n            return None\n\n    def q10_model(temp: float, base_temp: float = 25.0, q10: float = 2.0) -> Optional[float]:\n        \"\"\"Calculate growth rate using Q10 model.\"\"\"\n        try:\n            return q10 ** ((temp - base_temp) / 10.0)\n        except Exception as e:\n            print(f\"Error calculating Q10 model at {temp}C: {e}\")\n            return None\n\n    model_function = arrhenius_model if growth_rate_model == 'Arrhenius' else q10_model\n\n    return [model_function(temp) for temp in temperatures]\n```\n",
                "Incorrect_Answers": [
                    "```python\n\"\"\"\nThis module provides a utility function to calculate the average of a list of numbers.\n\"\"\"\n\nfrom typing import List\n\n\ndef calculate_average(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the average of a list of numbers.\n\n    Args:\n        numbers (List[float]): A list of numerical values.\n\n    Returns:\n        float: The average of the numbers.\n\n    Raises:\n        ValueError: If the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty\")\n    \n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:\n        raise ValueError(\"Encountered a division by zero\")\n\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the usage of calculate_average.\n    \"\"\"\n    sample_numbers = [10, 20, 30, 40, 50]\n    \n    try:\n        average = calculate_average(sample_numbers)\n        print(f\"The average is: {average}\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n\"\"\"\nThis module contains functions to manage a simple player's inventory system\nin a role-playing game, highlighting coding styles preferred by Alex Martinez.\n\"\"\"\n\n# Import standard library\nfrom collections import defaultdict\n\n# Define constants\nMAX_INVENTORY_ITEMS = 10\n\ndef add_item_to_inventory(inventory, item):\n    \"\"\"\n    Add an item to the inventory if there's space.\n    \n    Parameters:\n    inventory (dict): The player's current inventory with item names as keys and quantities as values.\n    item (str): The name of the item to add to the inventory.\n    \n    Returns:\n    str: A message indicating whether the item was added or not.\n    \"\"\"\n    # Check if there's space in the inventory\n    if sum(inventory.values()) < MAX_INVENTORY_ITEMS:\n        inventory[item] += 1\n        return f\"Added {item} to inventory.\"\n    else:\n        return \"Inventory is full, cannot add more items.\"\n\ndef list_inventory(inventory):\n    \"\"\"\n    List all items in the inventory with their quantities.\n    \n    Parameters:\n    inventory (dict): The player's current inventory with item names as keys and quantities as values.\n    \n    Returns:\n    list: A list of strings describing each item and its quantity.\n    \"\"\"\n    return [f\"{item}: {quantity}\" for item, quantity in inventory.items()]\n\ndef remove_item_from_inventory(inventory, item):\n    \"\"\"\n    Remove an item from the inventory if it exists.\n    \n    Parameters:\n    inventory (dict): The player's current inventory with item names as keys and quantities as values.\n    item (str): The name of the item to remove from the inventory.\n    \n    Returns:\n    str: A message indicating the outcome of the removal attempt.\n    \"\"\"\n    if item in inventory and inventory[item] > 0:\n        inventory[item] -= 1\n        return f\"Removed one {item} from inventory.\"\n    else:\n        return f\"No {item} found in inventory.\"\n\ndef main():\n    \"\"\"\n    Test the inventory management functions.\n    \"\"\"\n    inventory = defaultdict(int)  # Default to integer values\n\n    actions = [\n        ('add', 'sword'),\n        ('add', 'shield'),\n        ('list', ''),\n        ('remove', 'shield'),\n        ('list', ''),\n        ('add', 'potion')\n    ]\n    \n    for action, item in actions:\n        if action == 'add':\n            result = add_item_to_inventory(inventory, item)\n        elif action == 'remove':\n            result = remove_item_from_inventory(inventory, item)\n        elif action == 'list':\n            result = list_inventory(inventory)\n        \n        # Print result for visual confirmation\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nclass Team:\n    \"\"\"\n    Represents a team with players and their statistics.\n    \"\"\"\n\n    def __init__(self, name):\n        \"\"\"\n        Initializes a new Team instance.\n\n        :param name: The name of the team.\n        \"\"\"\n        self.name = name\n        self.players = {}\n\n    def add_player(self, player_name, position):\n        \"\"\"\n        Adds a player to the team.\n\n        :param player_name: The name of the player.\n        :param position: The playing position of the player.\n        \"\"\"\n        self.players[player_name] = {\n            'position': position,\n            'games': [],\n            'average_yards_per_game': 0.0\n        }\n\n    def add_game_stats(self, player_name, yards):\n        \"\"\"\n        Records the game statistics for a player.\n\n        :param player_name: The name of the player.\n        :param yards: Total yards gained by the player in the game.\n        :raises ValueError: if player's stats are not found or yards input is invalid.\n        \"\"\"\n        try:\n            if player_name in self.players:\n                self.players[player_name]['games'].append(yards)\n                self.players[player_name]['average_yards_per_game'] = \\\n                    self.calculate_average_yards(player_name)\n            else:\n                raise ValueError(f\"Player {player_name} not found on the team.\")\n        except (ValueError, TypeError) as e:\n            print(f\"Error updating player stats: {e}\")\n\n    def calculate_average_yards(self, player_name):\n        \"\"\"\n        Calculates the average yards per game for a player.\n\n        :param player_name: The name of the player.\n        :return: The average yards per game.\n        \"\"\"\n        player_games = self.players[player_name]['games']\n        if not player_games:\n            return 0.0\n        return sum(player_games) / len(player_games)\n\n# Example usage:\n\n# Instantiate a team\neagle_team = Team('Eagles')\n\n# Add players to the team\neagle_team.add_player('Alex Rivers', 'Quarterback')\neagle_team.add_player('Jamie Sky', 'Receiver')\n\n# Add game stats for players\neagle_team.add_game_stats('Alex Rivers', 250)\neagle_team.add_game_stats('Jamie Sky', 120)\n\n# Print out team's players statistics\nfor player, stats in eagle_team.players.items():\n    print(f\"{player}: Position: {stats['position']}, \"\n          f\"Average Yards/Game: {stats['average_yards_per_game']:.2f}\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Name: Alex Rosenberg\n\nAlex, born in 1986, is a non-binary science journalist with a keen interest in the unique characteristics and potential applications of extremophiles. With a Jewish background, Alex often draws inspiration from the resilience and adaptability found within both their cultural heritage and the extremophiles they study. Passionate about weaving complex scientific concepts into engaging narratives, Alex strives to communicate the significance of these extraordinary organisms to a broad audience. Beyond their professional pursuits, Alex enjoys hiking in diverse ecosystems, always eager to explore environments that mirror the rigorous conditions extremophiles thrive in. Balancing a love for storytelling with a commitment to scientific accuracy, Alex aims to raise awareness about the importance of biodiversity and the innovative uses of extremophiles in fields like biotechnology and astrobiology.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\n       \"1\": \"Descriptive naming conventions for variables (e.g., 'extremophile_adaptation' instead of 'var1')\",\n       \"2\": \"Modular code structure that separates functionalities, making it easier to test extremophile algorithms.\",\n       \"3\": \"Thorough error handling to manage edge cases in biological data (e.g., try-except blocks to handle data parsing errors).\",\n       \"4\": \"Use of list comprehensions for concise and readable data processing (e.g., '[organism for organism in data if organism.is_extremophile()]').\",\n       \"5\": \"Functional programming practices that encourage reuse, such as using higher-order functions.\"\n   },\n   \"[Coding Styles] Dislikes\": {\n       \"1\": \"Overly long functions that do not break down complex tasks into smaller, manageable pieces.\",\n       \"2\": \"Ambiguous or overly abbreviated variable names (e.g., 'a', 'b', or 'data_list_1').\",\n       \"3\": \"Lack of comments explaining complex biological algorithms or scientific logic.\",\n       \"4\": \"Not handling exceptions that would lead to crashes on unexpected data inputs.\",\n       \"5\": \"Redundant code with unnecessary repetitions of logic that could be encapsulated in a function.\"\n   },\n   \"[Formatting Styles] Likes\": {\n       \"1\": \"Consistent use of 4-space indentation for improved readability.\",\n       \"2\": \"Keeping line length to a maximum of 79 characters to maintain readability.\",\n       \"3\": \"Clear and detailed docstrings for each function, explaining the biology-related parameters and returns.\",\n       \"4\": \"Organized imports, following the standard library, third-party libraries, and local imports order.\",\n       \"5\": \"Inline comments for complex lines of code explaining the biological significance of operations.\"\n   },\n   \"[Formatting Styles] Dislikes\": {\n       \"1\": \"Inconsistent indentation that could lead to syntax errors and confusion.\",\n       \"2\": \"Line lengths exceeding 79 characters as it hampers code readability.\",\n       \"3\": \"Lack of space around operators and commas, resulting in a cluttered appearance (e.g., 'a,b = 1,2').\",\n       \"4\": \"Missing or inadequate docstrings that leave out essential information on the purpose of functions.\",\n       \"5\": \"Improperly aligned variables in assignments or function calls that makes code harder to read.\"\n   }\n}"
            }
        ]
    }
}