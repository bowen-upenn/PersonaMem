{
    "Original Persona": "A renowned evolutionary biologist who firmly believes in the separation of science and religion",
    "Expanded Persona": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.",
    "Topic": "coding",
    "Original Sample": "```python\nclass Solution1:\n    def exist(self, b, w):\n        def search(b,i,j,w,pos):\n            if pos==len(w):return True\n            if i<0 or j<0 or i>=len(b) or j>=len(b[0]) or w[pos]!=b[i][j] or v[i][j]:return False\n            v[i][j]=True\n            if search(b,i+1,j,w,pos+1) or search(b,i-1,j,w,pos+1) or search(b,i,j+1,w,pos+1) or search(b,i,j-1,w,pos+1):return True\n            v[i][j]=False\n            return False\n\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if w[0]==b[i][j] and search(b,w,i,j,0):return True\n        return False\n\nclass Solution2:\n    def exist(self, b, w):\n        def search(b,i,j,w,index):\n            if index==len(w)-1:return True\n            temp=b[i][j]\n            b[i][j]=' '\n            if(i>0 and b[i-1][j]==w[index+1] and search(b,i-1,j,w,index+1)==True):return True\n            if(i<len(b)-1 and b[i+1][j]==w[index+1] and search(b,i+1,j,w,index+1)==True):return True\n            if(j>0 and b[i][j-1]==w[index+1] and search(b,i,j-1,w,index+1)==True):return True\n            if(j<len(b[0])-1 and b[i][j+1]==w[index+1] and search(b,i,j+1,w,index+1)==True):return True\n            b[i][j]=temp\n            return False\n\n        row=len(b)\n        col=len(b[0])\n\n        for i in range(row):\n            for j in range(col):\n                if b[i][j]==w[0] and search(b,i,j,w,0)==True:return True\n        return False\n\n\nclass Solution3:\n    def __init__(self):self.directions=[0,1,0,-1,0]\n\n    def exist(self, b, w):\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if b[i][j]==w[0]:\n                    v[i][j]=True\n                    if self.existByDfs(b,i,j,w[1::],v,m,n):return True\n                    v[i][j]=False\n        return False\n\n    def existByDfs(self,b,startI,startJ,w,v,m,n):\n        if w==\"\":return True\n        for i in range(len(self.directions)-1):\n            nextX=startI+self.directions[i]\n            nextY=startJ+self.directions[i+1]\n            if nextX>=0 and nextX<m and nextY>=0 and nextY<n and not v[nextX][nextY] and b[nextX][nextY]==w[0]:\n                v[nextX][nextY]=True\n                if self.existByDfs(b,nextX,nextY,w[1::],v,m,n):return True\n                v[nextX][nextY]=False\n        return False\n```",
    "Coding and Formatting Styles": "{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}",
    "Updated Coding Sample": "```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            \n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \n                word[position] != board[i][j] or visited[i][j]):\n                return False\n            \n            # Mark current cell as visited\n            visited[i][j] = True\n            \n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            \n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
    "Conversation": [
        "[Original_Code]: ```python\nclass Solution1:\n    def exist(self, b, w):\n        def search(b,i,j,w,pos):\n            if pos==len(w):return True\n            if i<0 or j<0 or i>=len(b) or j>=len(b[0]) or w[pos]!=b[i][j] or v[i][j]:return False\n            v[i][j]=True\n            if search(b,i+1,j,w,pos+1) or search(b,i-1,j,w,pos+1) or search(b,i,j+1,w,pos+1) or search(b,i,j-1,w,pos+1):return True\n            v[i][j]=False\n            return False\n\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if w[0]==b[i][j] and search(b,w,i,j,0):return True\n        return False\n```",
        "[Side_Note]: [Coding Styles] Dislikes Long functions that tackle multiple responsibilities, leading to convoluted logic.",
        "User: I need help to refactor this code to improve clarity and organization. I dislike long functions that tackle multiple responsibilities as they lead to convoluted logic.",
        "Assistant: To address that, we can break down the main functionalities into smaller, more manageable functions. Let's start with defining the search function more clearly and implementing good practices. Here\u2019s a modified version of your code.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            if position == len(word): return True\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[position] != board[i][j] or visited[i][j]): return False\n            visited[i][j] = True\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            visited[i][j] = False\n            return False\n\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: I appreciate the breakdown, but I see some issues with formatting. I dislike that the conditions in the search function aren\u2019t properly spaced, and I prefer more meaningful variable names related to biology.",
        "[Side_Note]: [Formatting Styles] Likes Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.",
        "[Side_Note]: [Coding Styles] Likes Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.",
        "User: Can we update that for better readability? Changing 'b' to 'board' and 'w' to 'word' will make it clearer.",
        "Assistant: Absolutely, I\u2019ll apply proper spacing, consistent variable naming, and improve the comments throughout the code. Here\u2019s the updated version.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \n                word[position] != board[i][j] or visited[i][j]):\n                return False\n            # Mark current cell as visited\n            visited[i][j] = True\n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: This looks much better! However, I still see that line lengths might exceed 79 characters. Let's keep everything within that limit for better readability.",
        "[Side_Note]: [Formatting Styles] Dislikes Excessively long lines of code that exceed 79 characters, making it hard to read.",
        "User: Can you do that?",
        "Assistant: Sure, I'll ensure that no line exceeds 79 characters. Here\u2019s the final version with all adjustments made.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or\n                j >= len(board[0]) or word[position] != board[i][j] or\n                visited[i][j]):\n                return False\n            # Mark current cell as visited\n            visited[i][j] = True\n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: This perfectly aligns with my coding and formatting preferences. Thank you for your assistance!"
    ],
    "Q&A": {
        "Conversation": [
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List\n\ndef calculate_selection_pressure(fitness_values: List[float]) -> float:\n    \"\"\"\n    Calculate the selection pressure given a list of fitness values.\n    \n    Parameters:\n    fitness_values (List[float]): A list of fitness values of a population.\n\n    Returns:\n    float: The calculated selection pressure.\n    \"\"\"\n    if not fitness_values:\n        raise ValueError(\"The list of fitness values must not be empty.\")\n\n    average_fitness = sum(fitness_values) / len(fitness_values)\n    variance = sum((x - average_fitness) ** 2 for x in fitness_values) / len(fitness_values)\n\n    selection_pressure = math.sqrt(variance)\n    return selection_pressure\n\ndef main():\n    \"\"\"\n    Example usage of calculate_selection_pressure function.\n    \"\"\"\n    try:\n        fitness_values = [1.0, 2.5, 3.0, 4.5, 5.0]\n        pressure = calculate_selection_pressure(fitness_values)\n        print(f\"Selection Pressure: {pressure:.2f}\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\ndef get_flight_data(api_url, parameters):\n    \"\"\"\n    Retrieve flight data from the given API.\n\n    Parameters:\n        api_url (str): URL of the API endpoint.\n        parameters (dict): Dictionary of parameters to pass with the API request.\n\n    Returns:\n        dict: JSON response from the API converted into a dictionary.\n    \n    Raises:\n        ConnectionError: If there is a network problem.\n        ValueError: If the API response is not valid JSON.\n    \"\"\"\n    import requests\n\n    try:\n        response = requests.get(api_url, params=parameters)\n        response.raise_for_status()  # Raise an exception for HTTP errors\n    except requests.ConnectionError:\n        raise ConnectionError(\"Failed to connect to the API.\")\n    except requests.HTTPError as http_err:\n        raise ConnectionError(f\"HTTP error occurred: {http_err}\")\n\n    try:\n        flight_data = response.json()\n    except ValueError:\n        raise ValueError(\"Failed to parse API response as JSON.\")\n\n    return flight_data\n\n\ndef calculate_speed(distance, time):\n    \"\"\"\n    Calculate speed given distance and time.\n\n    Parameters:\n        distance (float): Distance traveled in meters.\n        time (float): Time taken in seconds.\n\n    Returns:\n        float: Speed in meters per second.\n    \n    Raises:\n        ZeroDivisionError: If time is zero to avoid division by zero error.\n    \"\"\"\n    if time == 0:\n        raise ZeroDivisionError(\"Time cannot be zero.\")\n\n    # Compute and return the speed\n    speed = distance / time  \n    return speed\n```",
                    "```python\n# -*- coding: utf-8 -*-\n\"\"\"\nThis script analyzes historical documents from the Eastern Wu period.\nIt provides functions to parse, summarize, and extract key historical themes\nfrom the texts.\n\"\"\"\n\nimport os\nimport re\nfrom typing import List, Dict\n\nclass EasternWuDocumentAnalyzer:\n    \"\"\"\n    A class dedicated to analyzing documents relating to the Eastern Wu period.\n    \"\"\"\n\n    def __init__(self, document_paths: List[str]):\n        \"\"\"\n        Initialize the analyzer with paths to historical documents.\n\n        Parameters:\n        ----------\n        document_paths : List[str]\n            A list of file paths to the documents to be analyzed.\n        \"\"\"\n        self.document_paths = document_paths\n        self.parsed_documents = []\n\n    def parse_document(self, file_path: str) -> List[str]:\n        \"\"\"\n        Parse a document into a list of sentences.\n\n        Parameters:\n        ----------\n        file_path : str\n            The path to the document file.\n\n        Returns:\n        -------\n        List[str]\n            A list of sentences extracted from the document.\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                text = file.read()\n                sentences = re.split(r'(?<=[.!?]) +', text)\n            return sentences\n        except FileNotFoundError:\n            print(f\"The document {file_path} was not found.\")\n            return []\n        except Exception as e:\n            print(f\"An error occurred while parsing {file_path}: {e}\")\n            return []\n\n    def summarize_research(self) -> Dict[str, int]:\n        \"\"\"\n        Summarize the frequency of key themes in the parsed documents.\n\n        Returns:\n        -------\n        Dict[str, int]\n            A dictionary with themes as keys and their frequency counts as values.\n        \"\"\"\n        theme_counts = {}\n        for document in self.parsed_documents:\n            for sentence in document:\n                themes = self.extract_themes(sentence)\n                for theme in themes:\n                    if theme in theme_counts:\n                        theme_counts[theme] += 1\n                    else:\n                        theme_counts[theme] = 1\n        return theme_counts\n\n    def extract_themes(self, sentence: str) -> List[str]:\n        \"\"\"\n        Extract key historical themes from a sentence.\n\n        Parameters:\n        ----------\n        sentence : str\n            A sentence from which to extract themes.\n\n        Returns:\n        -------\n        List[str]\n            A list of themes identified in the sentence.\n        \"\"\"\n        themes = []\n        if 'battle' in sentence.lower():\n            themes.append('battle')\n        if 'emperor' in sentence.lower():\n            themes.append('emperor')\n        # Add more theme extraction logic here\n        return themes\n\n    def process_documents(self):\n        \"\"\"\n        Parse all documents and populate the parsed_documents list.\n        \"\"\"\n        for path in self.document_paths:\n            sentences = self.parse_document(path)\n            if sentences:\n                self.parsed_documents.append(sentences)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # List of document paths to analyze\n    documents = ['path/to/document1.txt', 'path/to/document2.txt']\n\n    # Create an instance of the document analyzer\n    analyzer = EasternWuDocumentAnalyzer(documents)\n\n    # Process documents\n    analyzer.process_documents()\n\n    # Print the summary of research themes\n    research_summary = analyzer.summarize_research()\n    print(\"Research Summary:\", research_summary)\n```\n",
                    "```python\n# Function to calculate the average score from a list of scores\ndef calculate_average(scores):\n    \"\"\"Calculate and return the average of a list of scores.\"\"\"\n    if not scores:\n        return 0\n    return sum(scores) / len(scores)\n\n# Function to render a player's score\ndef render_score(player_name, player_score):\n    \"\"\"Render and print a player's score.\"\"\"\n    print(f\"Player {player_name} has a score of {player_score}.\")\n\n# Main function handling the game score logic\ndef main():\n    \"\"\"Main function to demonstrate game scoring.\"\"\"\n    # Example player scores\n    player_scores = {\n        \"Alice\": [85, 92, 78],\n        \"Bob\": [60, 70, 80],\n        \"Cathy\": [99, 98, 97]\n    }\n\n    try:\n        # Calculate and render average scores for each player\n        for player in player_scores:\n            average_score = calculate_average(player_scores[player])\n            render_score(player, round(average_score, 2))\n    except Exception as e:\n        # Handle any unexpected exceptions\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    # Proper way to run the main function\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# A module to model a simple ecosystem and calculate species fitness\n\nimport math\nfrom statistics import mean\n\nclass Species:\n    \"\"\"\n    A class to represent a species within an ecosystem.\n    \n    Attributes:\n    ----------\n    name : str\n        The name of the species.\n    population : int\n        The population size of the species.\n    growth_rate : float\n        The rate of growth of the species' population.\n    \"\"\"\n\n    def __init__(self, name, population, growth_rate):\n        self.name = name\n        self.population = population\n        self.growth_rate = growth_rate\n\n    def project_population(self, years):\n        \"\"\"\n        Calculate projected population size after a given number of years.\n        \n        Parameters:\n        ----------\n        years : int\n            The number of years over which to project population growth.\n        \n        Returns:\n        -------\n        int\n            The projected population size.\n        \"\"\"\n        try:\n            projected_size = self.population * (1 + self.growth_rate) ** years\n            return math.floor(projected_size)\n        except Exception as e:\n            print(f\"An error occurred while projecting population: {e}\")\n            return None\n\ndef calculate_fitness(resources, population, influence_factor=0.5):\n    \"\"\"\n    Calculate the fitness of a population based on available resources.\n    \n    Parameters:\n    ----------\n    resources : list\n        A list of resource values available to the species.\n    population : int\n        The current population of the species.\n    influence_factor : float, optional\n        Influences how resources affect fitness (default is 0.5).\n    \n    Returns:\n    -------\n    float\n        The fitness coefficient of the species.\n    \"\"\"\n    try:\n        avg_resources = mean(resources)\n        fitness_coefficient = avg_resources / (population ** influence_factor)\n        return fitness_coefficient\n    except Exception as e:\n        print(f\"An error occurred while calculating fitness: {e}\")\n        return None\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the ecosystem modeling.\n    \"\"\"\n    # Define species with appropriate attributes\n    rabbit = Species(\"Rabbit\", 150, 0.1)\n    fox = Species(\"Fox\", 40, 0.05)\n    \n    # Calculate projected populations\n    rabbit_projected_population = rabbit.project_population(years=5)\n    fox_projected_population = fox.project_population(years=5)\n    \n    print(f\"Rabbit projected population in 5 years: {rabbit_projected_population}\")\n    print(f\"Fox projected population in 5 years: {fox_projected_population}\")\n    \n    # Calculate fitness\n    resources = [10, 12, 9, 8, 15]\n    rabbit_fitness = calculate_fitness(resources, rabbit.population)\n    fox_fitness = calculate_fitness(resources, fox.population)\n    \n    print(f\"Rabbit fitness coefficient: {rabbit_fitness:.2f}\")\n    print(f\"Fox fitness coefficient: {fox_fitness:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\n\"\"\"\nThis module provides utilities for managing player statistics in a game.\n\"\"\"\n\ndef calculate_average_score(scores):\n    \"\"\"\n    Calculate the average score from a list of scores.\n    \n    :param scores: List of integer scores\n    :return: Average score as a float\n    \"\"\"\n    total_score = sum(scores)\n    number_of_scores = len(scores)\n    \n    # Ensure we divide by zero safely\n    try:\n        average_score = total_score / number_of_scores\n    except ZeroDivisionError:\n        return 0.0\n    \n    return average_score\n\ndef update_player_profile(player_name, new_score, player_profiles):\n    \"\"\"\n    Update the player's profile with a new score.\n    \n    :param player_name: The player's name as a string\n    :param new_score: The new score to add, as an integer\n    :param player_profiles: Dictionary with player names as keys and lists of scores as values\n    :return: None\n    \"\"\"\n    player_scores = player_profiles.get(player_name, [])\n    \n    # Append the new score to the player's score list\n    player_scores.append(new_score)\n    player_profiles[player_name] = player_scores\n\ndef main():\n    \"\"\"\n    Main function to demonstrate updating player profiles and calculating average scores.\n    \"\"\"\n    player_profiles = {\n        'Alex': [55, 78, 88],\n        'Jordan': [92, 80, 76]\n    }\n    \n    # Update profiles with new scores\n    update_player_profile('Alex', 91, player_profiles)\n    update_player_profile('Jordan', 84, player_profiles)\n    \n    # Calculate average scores for each player\n    for player in player_profiles:\n        average = calculate_average_score(player_profiles[player])\n        print(f\"Average score for {player}: {average}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n",
                    "```python\ndef calculate_total_distance(trips):\n    \"\"\"\n    Calculate the total distance traveled for a list of trips.\n\n    Args:\n        trips (list of dict): A list where each dict contains the trip details,\n        including 'start_point', 'end_point', and 'distance'.\n\n    Returns:\n        float: The sum of all trip distances.\n    \"\"\"\n\n    total_distance = 0.0\n\n    for trip in trips:\n        try:\n            # Ensure trip contains expected keys\n            if 'distance' not in trip:\n                raise KeyError(\"Missing 'distance' key in trip details.\")\n\n            distance = trip['distance']\n\n            # Avoid magic numbers; check for valid distance\n            if distance < 0:\n                raise ValueError(\"Distance cannot be negative.\")\n\n            total_distance += distance\n\n        except (KeyError, ValueError) as e:\n            # Log the error and continue with other trips\n            print(f\"Error processing trip: {e}\")\n\n    return total_distance\n\n\ndef main():\n    trips = [\n        {'start_point': 'A', 'end_point': 'B', 'distance': 120.5},\n        {'start_point': 'B', 'end_point': 'C', 'distance': 98.7},\n        {'start_point': 'C', 'end_point': 'D', 'distance': -50},  # Example with invalid distance\n    ]\n\n    total = calculate_total_distance(trips)\n    print(f\"Total distance traveled: {total} km\")\n\n\nif __name__ == '__main__':\n    main()\n```\n",
                    "```python\n# Yo, it's time to drop some dope code\n\ndef drop_the_mic(nums):\n    \"\"\"\n    Smashes it with the ultimate sum.\n    Takes a list and returns the killer sum.\n    \"\"\"\n    try:\n        # This is where we slam the sum using Python's turbo function\n        result = sum(nums)\n        return result\n    except TypeError as err:\n        # Ain't got time for that lame input vibe\n        raise ValueError(\"Yo! Bring only numbers to this party!\") from err\n\n\ndef keep_it_real(nums):\n    \"\"\"\n    Filters out the baggage, keeps only positive vibes (numbers).\n    \"\"\"\n    try:\n        # We're slicing through, keeping it fresh and positive\n        positive_nums = [num for num in nums if num > 0]\n        return positive_nums\n    except TypeError as err:\n        # Got non-number noise? Clear it out!\n        raise ValueError(\"Hold up! Numbers only in the spotlight.\") from err\n\n\n# Bring close those slick positive numbers and rock the sum\ndef sum_of_good_vibes(nums):\n    \"\"\"\n    Filters out non-vibes and gets the sum of all that positive energy.\n    \"\"\"\n    # Wrapping those functions together, layering like tracks\n    try:\n        good_vibes = keep_it_real(nums)\n        return drop_the_mic(good_vibes)\n    except ValueError as err:\n        # Error that hits hard and loud\n        print(f\"Caught an error: {err}\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# Import necessary libraries\nimport math\nfrom typing import List, Tuple\n\ndef calculate_adaptation_rate(population_changes: List[float], \n                              time_interval: float) -> float:\n    \"\"\"\n    Calculate the adaptation rate of a species based on changes in population \n    over a given time interval.\n    \n    Parameters:\n    population_changes (List[float]): A list of changes in species population \n                                      at different times.\n    time_interval (float): The time interval over which the changes are observed.\n    \n    Returns:\n    float: The calculated rate of adaptation.\n    \n    Raises:\n    ValueError: If the time_interval is zero, to avoid division by zero errors.\n    \"\"\"\n    # Checking for valid time_interval\n    if time_interval == 0.0:\n        raise ValueError(\"Time interval must be greater than zero.\")\n\n    # Calculate the average change in population\n    try:\n        total_change = sum(population_changes)\n        average_change = total_change / len(population_changes)\n        adaptation_rate = average_change / time_interval\n        return adaptation_rate\n    except ZeroDivisionError:\n        raise ValueError(\"Population changes list cannot be empty.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n        raise\n\ndef species_diversification(age_of_species: float, \n                            diversification_factor: float) -> float:\n    \"\"\"\n    Calculate the diversification index of a species based on its age and a \n    diversification factor.\n    \n    Parameters:\n    age_of_species (float): The age of the species in millions of years.\n    diversification_factor (float): A factor representing the diversification \n                                    rate.\n    \n    Returns:\n    float: The diversification index of the species.\n    \"\"\"\n    diversification_index = age_of_species * diversification_factor\n    return diversification_index\n\n# Example usage\nif __name__ == \"__main__\":\n    population_changes_sample = [2.3, -1.5, 3.7, 0.5]\n    time_interval_sample = 10.0\n    age_of_species_sample = 4.5\n    diversification_factor_sample = 1.2\n\n    # Calculate adaptation rate\n    adaptation_rate = calculate_adaptation_rate(population_changes_sample, \n                                                time_interval_sample)\n    print(f\"Adaptation rate: {adaptation_rate}\")\n\n    # Calculate diversification index\n    diversification_index = species_diversification(age_of_species_sample, \n                                                    diversification_factor_sample)\n    print(f\"Diversification index: {diversification_index}\")\n```",
                "Incorrect_Answers": [
                    "```python\nimport json\nfrom typing import Dict, Any\n\n\ndef process_data(file_path: str) -> dict:\n    \"\"\"\n    Process the JSON data from the given file.\n\n    Args:\n        file_path (str): The path to the JSON file to be processed.\n\n    Returns:\n        dict: A dictionary containing the processed data.\n    \"\"\"\n    data = {}\n\n    # Read the JSON file\n    try:\n        with open(file_path, 'r') as file:\n            data = json.load(file)\n    except FileNotFoundError:\n        print(f\"Error: The file {file_path} was not found.\")\n    except json.JSONDecodeError:\n        print(\"Error: Failed to decode JSON from the file.\")\n\n    return data\n\n\ndef calculate_statistics(data: Dict[str, Any]) -> Dict[str, float]:\n    \"\"\"\n    Calculate simple statistics from the data.\n\n    Args:\n        data (Dict[str, Any]): The data to calculate statistics from.\n\n    Returns:\n        Dict[str, float]: A dictionary containing statistics such as the average.\n    \"\"\"\n    total = 0\n    count = 0\n\n    for key, value in data.items():\n        # Ensure values are numeric before processing\n        if isinstance(value, (int, float)):\n            total += value\n            count += 1\n\n    average = total / count if count != 0 else 0.0\n\n    return {\n        'total': total,\n        'average': average\n    }\n\n\ndef main():\n    \"\"\"\n    Main function to execute the data processing and statistics calculation.\n    \"\"\"\n    file_path = 'data.json'\n    data = process_data(file_path)\n    \n    if data:\n        stats = calculate_statistics(data)\n        print(f\"Total: {stats['total']}, Average: {stats['average']}\")\n\n\nif __name__ == '__main__':\n    main()\n```",
                    "```python\n\"\"\"\nA simple script to calculate averages of numeric lists.\nAuthor: Alex\nDate: 2023-10-18\n\"\"\"\n\nfrom typing import List, Union\n\ndef calculate_average(numbers: List[Union[int, float]]) -> float:\n    \"\"\"Calculate the average of a list of numbers.\n\n    Args:\n        numbers (List[Union[int, float]]): A list of numerical values.\n\n    Returns:\n        float: The average value of the list.\n    \"\"\"\n    try:\n        total_sum = sum(numbers)  # Calculate the sum using a built-in function\n        count = len(numbers)\n        average = total_sum / count\n        return average\n    except ZeroDivisionError:\n        return float('nan')  # Return 'nan' for an empty list\n\ndef main():\n    \"\"\"Main function to demonstrate average calculation.\"\"\"\n    sample_numbers = [10, 20, 30, 40, 50]\n    avg = calculate_average(sample_numbers)\n    print(f\"The average of {sample_numbers} is {avg:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport numpy as np\n\ndef calculate_dosage(weight_kg, concentration_mg_per_ml):\n    \"\"\"\n    Calculate the medication dosage based on weight and drug concentration.\n\n    Parameters:\n    weight_kg (float): The weight of the individual in kilograms.\n    concentration_mg_per_ml (float): The drug concentration in mg/ml.\n\n    Returns:\n    float: The calculated dose in mg.\n    \"\"\"\n    if weight_kg <= 0:\n        raise ValueError(\"Weight must be a positive value.\")\n    if concentration_mg_per_ml <= 0:\n        raise ValueError(\"Concentration must be a positive value.\")\n\n    return weight_kg * concentration_mg_per_ml\n\ndef prepare_solution(volume_ml, concentration_mg_per_ml):\n    \"\"\"\n    Prepare a solution by scaling the concentration over a given volume.\n\n    Parameters:\n    volume_ml (float): The volume of the solution in ml.\n    concentration_mg_per_ml (float): The drug concentration in mg/ml.\n\n    Returns:\n    float: Total amount of drug in the solution in mg.\n    \"\"\"\n    if volume_ml <= 0:\n        raise ValueError(\"Volume must be a positive value.\")\n    return volume_ml * concentration_mg_per_ml\n\ndef main():\n    # Example: Calculate dose for different weight and concentration\n    weights = np.array([50, 70, 90])  # List of weights in kg\n    concentration = 5.0  # Drug concentration in mg/ml\n\n    doses = [calculate_dosage(weight, concentration) for weight in weights]\n    \n    print(\"Calculated Doses:\", doses)\n\nif __name__ == '__main__':\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef calculate_genetic_diversity(species_population):\n    \"\"\"\n    Calculate the genetic diversity of a given species population.\n\n    :param species_population: List of genetic sequences representing the population.\n    :return: A float representing the genetic diversity index.\n    \"\"\"\n    try:\n        unique_sequences = set(species_population)\n        diversity_index = len(unique_sequences) / len(species_population)\n        \n        if diversity_index > 1:\n            raise ValueError(\"Diversity index calculation resulted in a value greater than 1.\")\n        \n        return diversity_index\n    except TypeError as e:\n        print(\"An error occurred with input data type.\", str(e))\n        return None\n\n\ndef simulate_population_growth(initial_population, growth_rate, generations):\n    \"\"\"\n    Simulate the growth of a population over a number of generations.\n\n    :param initial_population: An integer representing the starting population size.\n    :param growth_rate: A float representing the growth rate per generation.\n    :param generations: An integer for how many generations to simulate.\n    :return: List of population sizes over the given generations.\n    \"\"\"\n    population_sizes = []\n    current_population = initial_population\n    \n    for generation in range(generations):\n        current_population += current_population * growth_rate\n        population_sizes.append(current_population)\n    \n    return population_sizes\n\n\n# Example Usage\nspecies_population = ['ATCG', 'TAGC', 'ATCG', 'AGTC', 'TAGC', 'CTGA']\ndiversity = calculate_genetic_diversity(species_population)\nprint(\"Genetic Diversity Index:\", diversity)\n\npopulation_sizes = simulate_population_growth(100, 0.1, 10)\nprint(\"Population over generations:\", population_sizes)\n```",
                "Incorrect_Answers": [
                    "```python\nfrom datetime import datetime\nfrom typing import List, Dict\n\nclass User:\n    \"\"\"A class representing a user in the mobile app.\"\"\"\n    \n    def __init__(self, user_id: str, name: str, locale: str):\n        \"\"\"Initialize a user with an ID, name, and locale.\"\"\"\n        self.user_id = user_id\n        self.name = name\n        self.locale = locale\n\n    def greet_user(self) -> str:\n        \"\"\"Return a greeting message tailored to the user's locale.\"\"\"\n        greetings = {\n            'en_US': f\"Hello, {self.name}!\",\n            'es_ES': f\"\u00a1Hola, {self.name}!\",\n            'fr_FR': f\"Bonjour, {self.name}!\"\n        }\n        return greetings.get(self.locale, f\"Hello, {self.name}!\")\n\n\ndef log_event(user_id: str, event_type: str, data: Dict[str, str]) -> None:\n    \"\"\"\n    Log an event for analytics.\n    \n    Args:\n        user_id (str): The ID of the user triggering the event.\n        event_type (str): The type of the event.\n        data (Dict[str, str]): Additional data about the event.\n    \"\"\"\n    try:\n        timestamp = datetime.now().isoformat()\n        log_entry = {\n            \"user_id\": user_id,\n            \"event_type\": event_type,\n            \"data\": data,\n            \"timestamp\": timestamp\n        }\n        print(log_entry)  # In real-world scenario, this would be sent to a logging service\n    except Exception as e:\n        print(f\"Failed to log event: {e}\")\n\n\ndef get_top_users(users: List[User], top_n: int) -> List[User]:\n    \"\"\"\n    Get top N users based on a criteria.\n    \n    Args:\n        users (List[User]): List of user objects.\n        top_n (int): Number of top users to return.\n    \n    Returns:\n        List[User]: List of top N users.\n    \"\"\"\n    # Sample criteria based on user_id length for demonstration\n    sorted_users = sorted(users, key=lambda user: len(user.user_id), reverse=True)\n    return sorted_users[:top_n]\n```",
                    "```python\nimport math\nimport pandas as pd\n\ndef calculate_premium(age, base_premium, historical_data):\n    \"\"\"\n    Calculate the insurance premium based on the client's age,\n    base premium, and historical data.\n\n    Parameters:\n    age (int): The client's age\n    base_premium (float): The base premium value\n    historical_data (DataFrame): Historical data to adjust the premium\n\n    Returns:\n    float: The calculated premium\n    \"\"\"\n    try:\n        risk_factor = evaluate_risk(historical_data)\n        age_factor = calculate_age_factor(age)\n        premium = base_premium * risk_factor * age_factor\n        return premium\n\n    except Exception as e:\n        print(\"An error occurred while calculating the premium:\", str(e))\n        return None\n\ndef evaluate_risk(data):\n    \"\"\"\n    Evaluate the risk factor from historical data.\n\n    Parameters:\n    data (DataFrame): The historical data\n\n    Returns:\n    float: The calculated risk factor\n    \"\"\"\n    try:\n        # Assume certain column operations will determine risk factor\n        risk = data['risk_score'].mean() / 100\n        return max(min(risk, 1), 0)\n\n    except KeyError:\n        print(\"The expected 'risk_score' column was not found in the data.\")\n        return 1  # Default risk factor\n\ndef calculate_age_factor(age):\n    \"\"\"\n    Calculate the age factor for the premium calculation.\n\n    Parameters:\n    age (int): The client's age\n\n    Returns:\n    float: The age factor\n    \"\"\"\n    if age < 25:\n        return 1.5\n    elif age < 40:\n        return 1.2\n    elif age < 60:\n        return 1.0\n    else:\n        return 1.3\n\ndef main():\n    historical_data = pd.DataFrame({\n        'risk_score': [10, 20, 30, 40, 50]\n    })\n\n    age = 34\n    base_premium = 500.0\n\n    premium = calculate_premium(age, base_premium, historical_data)\n    if premium is not None:\n        print(\"The calculated premium is:\", premium)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\ndef drop_the_mic_on_calculation(num_list):\n    \"\"\"\n    This function takes center stage,\n    summing up the numbers and returning a grand total.\n    \"\"\"\n    try:\n        # We're adding these numbers like beats: no time for loops!\n        total_sum = sum(num_list)\n        return total_sum\n    except TypeError as e:\n        # Look at the mic, not the floor! Handle the mistake.\n        print(f\"Oops, can't rock with non-numbers: {e}\")\n        return None\n\ndef cut_noise_and_act(data):\n    \"\"\"\n    Silence the noise, keep it tight,\n    let's see if this data is right.\n    \"\"\"\n    try:\n        if len(data) < 1:\n            # If data is empty, we drop out\n            raise ValueError(\"Silence! The data is empty.\")\n        return True\n    except ValueError as err:\n        # Speak up when something's off\n        print(f\"Error here, not ghosting: {err}\")\n        return False\n\n# Simple demo with some slack\nnumbers = [4, 5, 6]\nif cut_noise_and_act(numbers):\n    result = drop_the_mic_on_calculation(numbers)\n    if result is not None:\n        print(f\"Final tally, no alley: {result}\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n\"\"\"\nModule: Genetic Analysis\n\nThis module provides functions to analyze genetic adaptation and species diversification.\n\"\"\"\n\nimport math\nimport random\nfrom typing import List, Tuple\n\nclass GeneticModel:\n    \"\"\"\n    A class used to represent a Genetic Model for evolutionary studies.\n\n    ...\n\n    Attributes\n    ----------\n    species_population : List[int]\n        a list representing the population count of each species\n    mutation_rate : float\n        the rate at which mutations occur in the population\n\n    Methods\n    -------\n    calculate_fitness(population: List[int]) -> List[float]:\n        Calculates and returns the fitness of each species in the population.\n\n    simulate_generation(population: List[int]) -> List[int]:\n        Simulates a generation of evolution based on mutation rates.\n    \"\"\"\n\n    def __init__(self, species_population: List[int], mutation_rate: float):\n        self.species_population = species_population\n        self.mutation_rate = mutation_rate\n\n    def calculate_fitness(self, population: List[int]) -> List[float]:\n        \"\"\"\n        Calculates and returns the fitness of each species in the population.\n\n        Parameters\n        ----------\n        population : List[int]\n            A list representing the population count of each species.\n\n        Returns\n        -------\n        List[float]\n            A list of fitness values corresponding to each species.\n        \"\"\"\n        try:\n            total_population = sum(population)\n            fitness = [count / total_population for count in population]\n            return fitness\n        except ZeroDivisionError:\n            print(\"Error: Population total is zero. Cannot calculate fitness.\")\n            return []\n\n    def simulate_generation(self, population: List[int]) -> List[int]:\n        \"\"\"\n        Simulates a generation of evolution based on mutation rates.\n\n        Parameters\n        ----------\n        population : List[int]\n            A list representing the current population of each species.\n\n        Returns\n        -------\n        List[int]\n            A list representing the new population after mutation.\n        \"\"\"\n        new_population = []\n        for count in population:\n            mutated_count = math.floor(count + count * self.mutation_rate * (random.random() - 0.5))\n            new_population.append(max(mutated_count, 0))\n        return new_population\n\ndef main():\n    model = GeneticModel(species_population=[100, 150, 200], mutation_rate=0.01)\n    current_population = model.species_population\n    for _ in range(10):  # Simulate 10 generations\n        current_population = model.simulate_generation(current_population)\n        fitness_values = model.calculate_fitness(current_population)\n        print(f\"Current Population: {current_population}\")\n        print(f\"Fitness Values: {fitness_values}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\nimport json\nimport requests\nfrom typing import Any, Dict, List, Tuple\n\ndef fetch_data_from_api(endpoint: str, params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Fetches data from a specified API endpoint.\n\n    Args:\n        endpoint (str): The API endpoint URL.\n        params (Dict[str, Any]): A dictionary of query parameters for the API call.\n\n    Returns:\n        Dict[str, Any]: The JSON response from the API converted into a dictionary.\n    \"\"\"\n    try:\n        response = requests.get(endpoint, params=params)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.RequestException as req_err:\n        print(f\"Request exception occurred: {req_err}\")\n    except Exception as err:\n        print(f\"An unexpected error occurred: {err}\")\n    return {}\n\ndef process_user_data(user_data: List[Dict[str, Any]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Processes a list of user data dictionaries to extract specific information.\n\n    Args:\n        user_data (List[Dict[str, Any]]): A list of dictionaries containing user data.\n\n    Returns:\n        List[Tuple[str, int]]: A list of tuples with user names and their respective scores.\n    \"\"\"\n    users_scores = []\n    for user in user_data:\n        user_name = user.get('name', 'Unknown')\n        user_score = user.get('score', 0)\n        users_scores.append((user_name, user_score))\n    return users_scores\n\ndef display_top_users(users_scores: List[Tuple[str, int]], top_n: int = 5) -> None:\n    \"\"\"\n    Displays the top N users based on their scores.\n\n    Args:\n        users_scores (List[Tuple[str, int]]): A list of tuples with user names and scores.\n        top_n (int, optional): Number of top users to display. Defaults to 5.\n    \"\"\"\n    sorted_users = sorted(users_scores, key=lambda user: user[1], reverse=True)\n    print(f\"Top {top_n} Users:\")\n    for i, (name, score) in enumerate(sorted_users[:top_n], start=1):\n        print(f\"{i}. {name}: {score}\")\n\ndef main() -> None:\n    \"\"\"\n    Main function to orchestrate fetching and processing user data,\n    and displaying the top users.\n    \"\"\"\n    api_endpoint = \"https://api.example.com/users\"\n    query_params = {\"sort\": \"desc\", \"filter\": \"active\"}\n    \n    user_data = fetch_data_from_api(api_endpoint, query_params)\n    users_scores = process_user_data(user_data)\n    display_top_users(users_scores)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nfrom typing import List\n\ndef load_extremophile_data(file_path: str) -> List[dict]:\n    \"\"\"\n    Loads extremophile data from a given file.\n    \n    Parameters:\n    file_path (str): The path to the file containing extremophile data.\n    \n    Returns:\n    List[dict]: A list of dictionaries, each representing an extremophile with\n                its characteristics.\n    \n    This function reads data from a specified file and parses it into a\n    structured format that is convenient for further analysis.\n    \"\"\"\n    extremophile_list = []\n    try:\n        with open(file_path, 'r') as file:\n            for line in file:\n                organism_info = parse_organism_info(line)\n                extremophile_list.append(organism_info)\n    except FileNotFoundError:\n        print(f\"Error: The file {file_path} was not found.\")\n    except Exception as e:\n        print(f\"An error occurred while loading data: {e}\")\n    return extremophile_list\n\ndef parse_organism_info(data_line: str) -> dict:\n    \"\"\"\n    Parses a line of data and extracts organism information.\n    \n    Parameters:\n    data_line (str): A single line from the data file representing an organism.\n    \n    Returns:\n    dict: A dictionary containing the extracted information of the organism.\n    \n    The function assumes the data line is formatted with specific delimiters\n    that separate different attributes of the organism.\n    \"\"\"\n    data_fields = data_line.strip().split(',')\n    return {\n        'name': data_fields[0],   # Organism's name\n        'habitat': data_fields[1],  # Known habitat\n        'adaptations': data_fields[2:]  # List of adaptations\n    }\n\ndef filter_extremophiles(organisms: List[dict]) -> List[dict]:\n    \"\"\"\n    Filters out non-extremophiles from a list of organisms.\n    \n    Parameters:\n    organisms (List[dict]): The list of organism dictionaries.\n    \n    Returns:\n    List[dict]: A list of organisms that are classified as extremophiles.\n    \n    This function uses the presence of specific adaptations as criteria to\n    determine if an organism is an extremophile.\n    \"\"\"\n    return [org for org in organisms if is_extremophile(org)]\n\ndef is_extremophile(organism: dict) -> bool:\n    \"\"\"\n    Determines if a given organism is an extremophile based on its adaptations.\n    \n    Parameters:\n    organism (dict): A dictionary representing an organism.\n    \n    Returns:\n    bool: True if the organism is an extremophile, False otherwise.\n    \n    Extremophiles are identified by certain unique adaptations allowing survival\n    in extreme conditions.\n    \"\"\"\n    return any(adaptation in organism['adaptations'] for adaptation in ['thermophilic', 'acidophilic', 'halophilic'])\n```",
                    "```python\nimport math\nimport requests\n\ndef calculate_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points \n    on the Earth specified by latitude and longitude.\n    \n    Parameters:\n    lat1 (float): Latitude of point 1\n    lon1 (float): Longitude of point 1\n    lat2 (float): Latitude of point 2\n    lon2 (float): Longitude of point 2\n    \n    Returns:\n    float: Distance in kilometers\n    \"\"\"\n    # Convert latitude and longitude from degrees to radians\n    phi1 = math.radians(lat1)\n    phi2 = math.radians(lat2)\n    delta_phi = math.radians(lat2 - lat1)\n    delta_lambda = math.radians(lon2 - lon1)\n\n    # Haversine formula\n    a = (math.sin(delta_phi / 2) ** 2 +\n         math.cos(phi1) * math.cos(phi2) * \n         math.sin(delta_lambda / 2) ** 2)\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Radius of Earth in kilometers. Use 3956 for miles\n    r = 6371.0\n    distance = r * c\n\n    # Return the calculated distance\n    return distance\n\ndef get_flight_data(api_url, params):\n    \"\"\"Retrieve flight data from a given API endpoint.\n\n    Parameters:\n    api_url (str): URL for the flight data API\n    params (dict): Dictionary of query parameters\n\n    Returns:\n    dict: Flight data returned by the API\n    \"\"\"\n    try:\n        # Send GET request to fetch flight data\n        response = requests.get(api_url, params=params)\n        response.raise_for_status() # Raise HTTPError for bad responses\n\n        # Parse response JSON\n        flight_data = response.json()\n        return flight_data\n    except requests.exceptions.RequestException as e:\n        # Log error message\n        print(f\"Error retrieving flight data: {e}\")\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define API URL and parameters\n    api_url = \"https://api.example.com/flights\"\n    params = {'departure': 'JFK', 'arrival': 'LAX'}\n\n    # Retrieve flight data\n    data = get_flight_data(api_url, params)\n\n    if data:\n        # Calculate distance between two sample locations\n        lat1, lon1 = 40.6413, -73.7781 # JFK\n        lat2, lon2 = 33.9416, -118.4085 # LAX\n        distance = calculate_distance(lat1, lon1, lat2, lon2)\n\n        # Display the calculated distance\n        print(f\"The distance between JFK and LAX is {distance:.2f} km.\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# Importing necessary libraries\nimport math\nfrom typing import List, Tuple\n\ndef calculate_fitness(population: List[int], fitness_function) -> List[float]:\n    \"\"\"\n    Calculate the fitness of each individual in the population using a given fitness function.\n    \n    Args:\n    - population (List[int]): A list of integers representing the population\n    - fitness_function (callable): A function that calculates the fitness of an individual\n    \n    Returns:\n    - List[float]: A list of fitness scores for each individual in the population\n    \"\"\"\n    fitness_scores = []\n    for individual in population:\n        try:\n            fitness = fitness_function(individual)\n            fitness_scores.append(fitness)\n        except Exception as e:\n            print(f\"Error calculating fitness for individual {individual}: {e}\")\n            fitness_scores.append(float('-inf'))  # Assign a very low fitness score on error\n    return fitness_scores\n\ndef evolve_population(population: List[int]) -> List[int]:\n    \"\"\"\n    Simulate an evolutionary step on the given population.\n    \n    Args:\n    - population (List[int]): A list of integers representing the population\n    \n    Returns:\n    - List[int]: The evolved population after one generation\n    \"\"\"\n    # Example implementation: select top 50% based on fitness and reproduce\n    fitness_function = lambda x: math.log(x + 1)  # Dummy fitness function\n    fitness_scores = calculate_fitness(population, fitness_function)\n    sorted_population = [individual for _, individual in sorted(\n        zip(fitness_scores, population), reverse=True\n    )]\n    next_generation = sorted_population[:len(sorted_population) // 2] * 2  # Simplified reproduction\n    return next_generation\n\n# Ensuring consistent testing\nif __name__ == '__main__':\n    initial_population = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    evolved_population = evolve_population(initial_population)\n    print(f\"Evolved Population: {evolved_population}\")\n```\n",
                "Incorrect_Answers": [
                    "```python\ndef calculate_flight_speed(distance: float, time: float) -> float:\n    \"\"\"\n    Calculate the speed of a flight given distance and time.\n\n    Parameters:\n    distance (float): The distance traveled in kilometers.\n    time (float): The time taken in hours.\n\n    Returns:\n    float: The speed of the flight in kilometers per hour.\n    \"\"\"\n    try:\n        speed = distance / time  # Calculate speed\n    except ZeroDivisionError:\n        raise ValueError(\"Time must be greater than zero to calculate speed.\")\n    \n    return speed\n\ndef get_flight_data() -> dict:\n    \"\"\"\n    Retrieve flight data from an API.\n\n    Returns:\n    dict: A dictionary containing flight data with keys like 'distance' and 'time'.\n    \"\"\"\n    # Placeholder for API call to retrieve flight data\n    flight_data = {\n        'distance': 600.0,  # in kilometers\n        'time': 1.5  # in hours\n    }\n\n    return flight_data\n\ndef main():\n    \"\"\"\n    Main function to execute flight speed calculation.\n    \"\"\"\n    data = get_flight_data()\n    distance = data['distance']\n    time = data['time']\n\n    # Compute and display flight speed\n    speed = calculate_flight_speed(distance, time)\n    \n    # Output the result\n    print(f\"The speed of the flight is {speed} km/h.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n# This script calculates the total price after tax for a list of items\n\n# Importing necessary standard libraries\nimport math\nimport sys\n\n# Function to calculate tax based on income\ndef calculate_tax(income):\n    \"\"\"\n    Calculate the tax based on the provided income.\n    \n    Parameters:\n        income (float): The total income to calculate tax on.\n        \n    Returns:\n        float: The calculated tax amount.\n    \"\"\"\n    # Assuming a flat tax rate of 20%\n    tax_rate = 0.2\n    tax = income * tax_rate\n    return tax\n\n# Function to calculate the total price after tax for a list of items\ndef calculate_total_price(items):\n    \"\"\"\n    Calculate the total price after tax for the provided list of items.\n    \n    Parameters:\n        items (list of float): A list containing the price of each item.\n        \n    Returns:\n        float: The total price including tax.\n    \"\"\"\n    # Initialize total as 0\n    total_price = 0.0\n    \n    try:\n        for price in items:\n            total_price += price  # Adding each item price to total\n        \n        # Calculate total tax\n        total_tax = calculate_tax(total_price)\n        \n        # Add tax to total price\n        total_price += total_tax\n\n        # Use math.ceil for rounding up the total price\n        return math.ceil(total_price)\n    \n    except Exception as e:\n        # Print a meaningful error message\n        print(f\"An error occurred: {e}\", file=sys.stderr)\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    item_prices = [19.99, 9.99, 4.99, 12.49]\n    total = calculate_total_price(item_prices)\n    print(f\"The total price after tax is: {total}\")\n```",
                    "```python\ndef calculate_discounted_price(original_price, discount):\n    \"\"\"\n    Calculate the discounted price based on the original price and the discount percentage.\n\n    Parameters:\n    - original_price (float): The original price of the item.\n    - discount (float): The discount percentage to be applied.\n\n    Returns:\n    - float: The final price after applying the discount.\n    \"\"\"\n    try:\n        # Validate inputs are of appropriate type.\n        if not isinstance(original_price, (int, float)) or not isinstance(discount, (int, float)):\n            raise ValueError(\"Both original_price and discount should be int or float.\")\n\n        discount_rate = discount / 100\n        final_price = original_price * (1 - discount_rate)\n\n        # Ensure final price is not negative\n        return max(final_price, 0)\n    except Exception as e:\n        # Handle any unexpected errors gracefully\n        print(f\"An error occurred: {e}\")\n        return None\n\n\ndef bulk_discounted_prices(prices, discount):\n    \"\"\"\n    Apply discount to a list of prices and return the list of discounted prices.\n\n    Parameters:\n    - prices (list of float): A list of original prices.\n    - discount (float): The discount percentage to be applied to each price.\n\n    Returns:\n    - list of float: A list containing discounted prices.\n    \"\"\"\n    return [calculate_discounted_price(price, discount) for price in prices]\n\n\n# Example usage\noriginal_prices = [100.0, 250.0, 330.0]  # list of original prices\ndiscount_percentage = 20.0  # discount to apply to each price\n\n# Calculate discounted prices\ndiscounted_prices = bulk_discounted_prices(original_prices, discount_percentage)\n\n# Output discounted prices\nfor original, discounted in zip(original_prices, discounted_prices):\n    print(f\"Original: ${original:.2f} -> Discounted: ${discounted:.2f}\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef calculate_genetic_diversity(species_population):\n    \"\"\"\n    Calculate the genetic diversity index for a given population of a species.\n\n    Parameters:\n    - species_population (list of tuples): A list representing individual species,\n      where each tuple contains alleles for that individual.\n      Example: [('A', 'a'), ('A', 'A'), ('a', 'a'), ...]\n\n    Returns:\n    - float: The genetic diversity index, representing the probability that two\n      randomly selected alleles are different.\n    \"\"\"\n\n    # Error handling for unexpected inputs\n    if not species_population or not isinstance(species_population, list):\n        raise ValueError(\"species_population must be a non-empty list of tuples.\")\n\n    allele_counts = {}\n    total_alleles = 0\n\n    # Counting alleles in the population\n    for individual in species_population:\n        if not isinstance(individual, tuple) or len(individual) != 2:\n            raise ValueError(\"Each individual in the population must be a tuple of two alleles.\")\n        \n        for allele in individual:\n            allele_counts[allele] = allele_counts.get(allele, 0) + 1\n            total_alleles += 1\n\n    # Calculate genetic diversity index using allele frequencies\n    diversity_index = 0.0\n    for count in allele_counts.values():\n        frequency = count / total_alleles\n        diversity_index += frequency * (1 - frequency)\n\n    return diversity_index\n\n# Example use\nspecies_population_example = [('A', 'a'), ('A', 'A'), ('a', 'a'), ('A', 'a')]\ndiversity_index_example = calculate_genetic_diversity(species_population_example)\nprint(\"Genetic Diversity Index:\", diversity_index_example)\n```",
                "Incorrect_Answers": [
                    "```python\n# Malia's Funky Calc: It's all about that sum life\ndef drop_the_mic(num_list):\n    \"\"\"\n    Drop the sum like a mic for that killer impact.\n    Args:\n        num_list (list): Gotta bring your numbers, no free rides.\n    Returns:\n        int: The sum that's gonna blow your mind.\n    \"\"\"\n    try:\n        total = sum(num_list)  # Keepin' it fast like a sick beat\n        # Check if we've got a runaway success\n        assert total >= 0, \"Whoa, sum went negative! That's wack!\"\n    except TypeError:\n        print(\"Type Error: Gotta hit the right notes with numbers only!\")\n        return 0\n    except AssertionError as ae:\n        print(f\"Assertion Error: {ae}\")\n        return 0\n\n    return total\n\n# Test the groove\nnumbers = [5, 10, 15]\nprint(f\"The grand total is: {drop_the_mic(numbers)}\")  # And there you have it\n```",
                    "```python\nimport random\nimport time\n\ndef calculate_score(goals, assists):\n    \"\"\"\n    Calculate the total score for a player based on goals and assists.\n\n    Parameters:\n    goals (int): The number of goals scored by the player.\n    assists (int): The number of assists made by the player.\n\n    Returns:\n    int: Total score calculated as (2 * goals + assists).\n    \"\"\"\n    try:\n        return (2 * goals) + assists\n    except TypeError as e:\n        print(f\"Error calculating score: {e}\")\n        return 0\n\ndef main_game_loop():\n    \"\"\"\n    Main loop for simulating an underwater hockey game session.\n\n    Emulates scoring and gameplay events.\n    \"\"\"\n    player_scores = {}\n    \n    while True:\n        try:\n            player_name = input(\"Enter player name (or 'q' to quit): \")\n            if player_name.lower() == 'q':\n                break\n            \n            goals = int(input(\"Enter number of goals: \"))\n            assists = int(input(\"Enter number of assists: \"))\n\n            score = calculate_score(goals, assists)\n            player_scores[player_name] = score\n            \n            print(f\"{player_name} scored {score} points.\\n\")\n            \n        except ValueError:\n            print(\"Invalid input. Please enter valid numbers for goals and assists.\")\n        \n    summarize_scores(player_scores)\n\ndef summarize_scores(player_scores):\n    \"\"\"\n    Summarize and display the scores for all players.\n\n    Parameters:\n    player_scores (dict): Dictionary containing player names as keys and scores as values.\n    \"\"\"\n    print(\"\\nFinal Scores:\")\n    for player, score in player_scores.items():\n        print(f\"{player}: {score} points\")\n\nif __name__ == \"__main__\":\n    main_game_loop()\n```\n",
                    "```python\nimport requests\n\ndef fetch_aircraft_data(api_url):\n    \"\"\"\n    Fetch aircraft data from the provided API URL.\n    \n    :param api_url: str - The URL of the API endpoint.\n    :return: dict - The JSON data parsed into a dictionary.\n    :raises: requests.exceptions.RequestException if a request-related error occurs.\n    \"\"\"\n    try:\n        response = requests.get(api_url)\n        response.raise_for_status()  # Raise an error for bad HTTP status codes.\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return {}\n\ndef calculate_fuel_efficiency(distance, fuel_used):\n    \"\"\"\n    Calculate the fuel efficiency of an aircraft.\n    \n    :param distance: float - The distance traveled by the aircraft in kilometers.\n    :param fuel_used: float - The fuel used by the aircraft in liters.\n    :return: float - The fuel efficiency calculated as kilometers per liter.\n    \"\"\"\n    # Ensure we do not divide by zero\n    if fuel_used == 0:\n        raise ValueError(\"Fuel used cannot be zero.\")\n    \n    return distance / fuel_used\n\ndef display_aircraft_efficiency(api_url):\n    \"\"\"\n    Fetch aircraft data and display the fuel efficiency for each aircraft.\n\n    :param api_url: str - The URL of the API endpoint.\n    \"\"\"\n    aircraft_data = fetch_aircraft_data(api_url)\n\n    for aircraft in aircraft_data.get('aircrafts', []):\n        try:\n            # Calculate and display fuel efficiency\n            efficiency = calculate_fuel_efficiency(\n                distance=aircraft['distance'],\n                fuel_used=aircraft['fuel_used']\n            )\n            print(f\"{aircraft['name']} : {efficiency:.2f} km/l\")\n        except (KeyError, ValueError) as e:\n            # Handle missing keys or invalid values\n            print(f\"Error processing aircraft data: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    API_URL = \"https://api.example.com/aircrafts\"\n    display_aircraft_efficiency(API_URL)\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nimport typing\n\n# Constants\nMAX_POPULATION_SIZE = 10000\nMIN_FERTILITY_RATE = 0.02\nMUTATION_RATE = 0.001\n\ndef calculate_fitness(individual_genome: str, environment_factors: typing.List[float]) -> float:\n    \"\"\"\n    Calculate the fitness of an individual based on its genome and environmental factors.\n\n    Args:\n        individual_genome (str): The genetic sequence of the individual.\n        environment_factors (List[float]): The list of environmental factors affecting fitness.\n\n    Returns:\n        float: Computed fitness value.\n    \"\"\"\n    try:\n        genome_value = convert_genome_to_value(individual_genome)\n        environmental_impact = sum(environment_factors) / len(environment_factors)\n        fitness = genome_value * environmental_impact\n        return fitness\n    except ZeroDivisionError:\n        print(\"Warning: Division by zero encountered in environmental factors.\")\n        return 0.0\n\ndef convert_genome_to_value(genome: str) -> float:\n    \"\"\"\n    Convert a genome string into a numerical value for analysis.\n\n    Args:\n        genome (str): The genetic sequence of the individual.\n\n    Returns:\n        float: The computed numerical value representing the genome.\n    \"\"\"\n    if not genome:\n        raise ValueError(\"Genome string cannot be empty.\")\n    return sum(ord(char) for char in genome) / len(genome)\n\ndef manage_population_growth(current_population: int, average_fitness: float) -> int:\n    \"\"\"\n    Manage the population growth based on current population and average fitness.\n\n    Args:\n        current_population (int): The current size of the population.\n        average_fitness (float): The average fitness of the population.\n\n    Returns:\n        int: The adjusted size of the population.\n    \"\"\"\n    growth_factor = average_fitness * (1 - MUTATION_RATE)\n    estimated_population = current_population + int(MIN_FERTILITY_RATE * current_population * growth_factor)\n\n    if estimated_population > MAX_POPULATION_SIZE:\n        return MAX_POPULATION_SIZE\n    return estimated_population\n\ndef main():\n    \"\"\"\n    Main function to simulate a simple evolutionary model.\n    \"\"\"\n    environment_factors = [0.5, 1.2, 0.9]\n    initial_population = 5000\n    individual_genome = \"AGCT\"\n\n    average_fitness = calculate_fitness(individual_genome, environment_factors)\n    next_generation_population = manage_population_growth(initial_population, average_fitness)\n\n    print(f\"Initial Population: {initial_population}\")\n    print(f\"Average Fitness: {average_fitness:.2f}\")\n    print(f\"Next Generation Population: {next_generation_population}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\n# Financial Advisor Assistance Tool by Mei-Ling Tan\n\n# Import necessary modules\nimport sys\n\ndef get_user_input(prompt):\n    \"\"\"\n    Get and validate user input as a float.\n    \n    Parameters:\n    prompt (str): The message displayed to the user for input\n    \n    Returns:\n    float: Validated float input from the user\n    \"\"\"\n    while True:\n        try:\n            # Try to convert input to float\n            user_input = float(input(prompt))\n            return user_input\n        except ValueError:\n            # Handle invalid input\n            print(\"Invalid input. Please enter a numerical value.\")\n\ndef calculate_total_expenses(expenses_list):\n    \"\"\"\n    Calculate the total of all expenses in the list.\n    \n    Parameters:\n    expenses_list (list): A list of numerical expenses\n    \n    Returns:\n    float: Total sum of expenses\n    \"\"\"\n    return sum(expenses_list)\n\ndef suggest_activities(budget, expenses):\n    \"\"\"\n    Suggest family activities based on budget and expenses.\n    \n    Parameters:\n    budget (float): Total budget available\n    expenses (float): Total expenses calculated\n    \n    Returns:\n    str: Suggested activities message\n    \"\"\"\n    remaining_budget = budget - expenses\n    if remaining_budget > 200:\n        return \"Consider a family outing or short trip.\"\n    elif remaining_budget > 50:\n        return \"How about a nice dinner at home with family?\"\n    else:\n        return \"Engage in cost-free activities like a park visit or movie night at home.\"\n\ndef main():\n    \"\"\"\n    Main function to execute the financial advice tool.\n    \"\"\"\n    print(\"\\nWelcome to the Financial Advisor Assistance Tool by Mei-Ling Tan\")\n    \n    total_budget = get_user_input(\"Please enter your total budget: \")\n    number_of_expenses = int(get_user_input(\"Enter the number of expenses you plan to list: \"))\n    \n    expenses_list = []\n    for i in range(number_of_expenses):\n        expense = get_user_input(f\"Enter expense {i+1}: \")\n        expenses_list.append(expense)\n    \n    total_expenses = calculate_total_expenses(expenses_list)\n    \n    print(\"\\n--- Financial Summary ---\")\n    print(f\"Total Budget: ${total_budget}\")\n    print(f\"Total Expenses: ${total_expenses}\")\n    print(f\"Remaining Budget: ${total_budget - total_expenses}\")\n    \n    # Get suggestions based on remaining budget\n    activity_suggestion = suggest_activities(total_budget, total_expenses)\n    print(\"\\nSuggested Activities:\", activity_suggestion)\n\n# Execute main function\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\", file=sys.stderr)\n```",
                    "```python\nimport math\nfrom typing import List\n\ndef calculate_average_population(sizes: List[int]) -> float:\n    \"\"\"\n    Calculate the average population size from a list of population sizes.\n\n    Args:\n        sizes (List[int]): A list of integer values representing population sizes.\n\n    Returns:\n        float: The average population size.\n    \n    Raises:\n        ValueError: If the list of sizes is empty.\n    \"\"\"\n    try:\n        if not sizes:\n            raise ValueError(\"The sizes list cannot be empty.\")\n        total_population = sum(sizes)\n        average_population = total_population / len(sizes)\n        return average_population\n    except ValueError as e:\n        print(f\"An error occurred: {e}\")\n        return math.nan\n\ndef classify_species_variation(population_size: int) -> str:\n    \"\"\"\n    Determine the diversity level of a species based on its population size.\n\n    Args:\n        population_size (int): The size of the species population.\n\n    Returns:\n        str: A string indicating the diversity level: 'Low', 'Medium', or 'High'.\n    \"\"\"\n    if population_size < 100:\n        diversity_level = \"Low\"\n    elif 100 <= population_size < 1000:\n        diversity_level = \"Medium\"\n    else:\n        diversity_level = \"High\"\n    return diversity_level\n```\n",
                    "```python\n# Importing necessary libraries\nimport math\nfrom collections import namedtuple\n\n# Define a simple data structure to hold point coordinates\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points.\n\n    Parameters\n    ----------\n    point1 : Point\n        The first point with coordinates (x, y).\n    point2 : Point\n        The second point with coordinates (x, y).\n\n    Returns\n    -------\n    float\n        The Euclidean distance between the two points.\n    \"\"\"\n    # Destructure point coordinates for readability\n    x1, y1 = point1.x, point1.y\n    x2, y2 = point2.x, point2.y\n\n    # Calculate the distance\n    try:\n        distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    except Exception as e:\n        print(f\"Error calculating distance: {e}\")\n        return None\n\n    return distance\n\ndef points_within_radius(center, points, radius):\n    \"\"\"\n    Find points within a specified radius from the center point.\n\n    Parameters\n    ----------\n    center : Point\n        The center point with coordinates (x, y).\n    points : list\n        A list of Point instances to check.\n    radius : float\n        The radius within which points should be.\n\n    Returns\n    -------\n    list\n        A list of Point instances within the given radius.\n    \"\"\"\n    # Use list comprehension for concise data selection\n    return [point for point in points if calculate_distance(center, point) <= radius]\n\n# Example usage\ncenter_point = Point(x=0, y=0)\nall_points = [Point(x=1, y=1), Point(x=3, y=3), Point(x=0, y=4)]\nradius_limit = 2.5\n\n# Find points within the specified radius\nclose_points = points_within_radius(center_point, all_points, radius_limit)\n\n# Output results\nprint(f\"Points within {radius_limit} units from {center_point}: {close_points}\")\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# Import necessary standard libraries\nimport math\nfrom typing import List\n\n# Import third-party libraries\nimport numpy as np\n\n# Local application/library specific imports can be placed here.\n\ndef calculate_fitness(individual_traits: List[float]) -> float:\n    \"\"\"\n    Calculate the fitness of an individual based on their traits.\n\n    The fitness function is used to determine how well-suited an individual is \n    to their environment based on specified traits.\n\n    :param individual_traits: A list of traits represented as floats.\n    :return: Fitness score as a float.\n    \"\"\"\n    try:\n        if not individual_traits:\n            raise ValueError(\"Individual traits list cannot be empty.\")\n\n        # Example fitness calculation using geometric mean\n        product = np.prod(individual_traits)\n        fitness_score = product ** (1.0 / len(individual_traits))\n        \n        return fitness_score\n    except (TypeError, ValueError) as e:\n        print(f\"Error calculating fitness: {e}\")\n        return 0.0\n\ndef main():\n    \"\"\"\n    Main function to execute the fitness calculation.\n\n    Demonstrates the use of the calculate_fitness function with a sample \n    trait list and outputs the result.\n    \"\"\"\n    sample_traits = [1.2, 1.8, 2.5, 2.0]\n    fitness = calculate_fitness(sample_traits)\n    print(f\"Calculated fitness: {fitness}\")\n\n# Ensure main is called if this module is executed directly\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\n# Import necessary modules at the top of the file\nimport sys\n\n\ndef calculate_total_expenses(expenses_list):\n    \"\"\"\n    Calculate the total expenses from a list of expenses.\n\n    Parameters:\n    expenses_list (list): A list of individual expenses as floats.\n\n    Returns:\n    float: Total of all expenses in the list.\n    \"\"\"\n    try:\n        total = sum(expenses_list)\n        return total\n    except TypeError:\n        print(\"Error: Ensure all items in the expenses list are numbers.\", file=sys.stderr)\n        return 0.0\n\n\ndef suggest_activities(total_budget, expenses_list):\n    \"\"\"\n    Suggest family activities based on the remaining budget.\n\n    Parameters:\n    total_budget (float): The family's total budget for activities.\n    expenses_list (list): A list of expenses already accounted for.\n\n    Returns:\n    list: Suggested activities within the remaining budget.\n    \"\"\"\n    remaining_budget = total_budget - calculate_total_expenses(expenses_list)\n    activities = []\n\n    if remaining_budget >= 50:\n        activities.append(\"Visit a local museum\")\n    if remaining_budget >= 20:\n        activities.append(\"Picnic at the park\")\n    if remaining_budget >= 10:\n        activities.append(\"Home movie night with popcorn\")\n    if remaining_budget < 10:\n        activities.append(\"Family board game session\")\n\n    return activities\n\n\nif __name__ == \"__main__\":\n    # Example usage with clear variable naming and function calls\n    family_expenses = [100.0, 50.75, 23.50, 10.99]\n    total_family_budget = 250.0\n\n    print(\"Total expenses: $\", calculate_total_expenses(family_expenses))\n    available_activities = suggest_activities(total_family_budget, family_expenses)\n    print(\"Suggested activities within budget:\", available_activities)\n```",
                    "```python\n# Drop the mic and set the stage for some bold moves\ndef drop_the_mic(beats):\n    \"\"\"\n    Hype up the beats with that phat base.\n    This function slays the ordinary with lyrical prowess.\n    \"\"\"\n    try:\n        # Break it down, element by element\n        amplified_beats = [b * 2 for b in beats]\n        total_slam = sum(amplified_beats)\n        # Hit them with the total impact\n        return total_slam\n    except Exception as e:\n        # If it all goes sideways, let them know with style\n        raise RuntimeError(f\"Yo, sound check failed: {str(e)}\")\n\n# Chaotic import order kills flow, let's keep it poppin'\nimport math\nimport random\n\ndef shake_and_bake(flow_list):\n    \"\"\"\n    Keep the wheels turnin' in this lyrical miracle.\n    Shuffle, simmer, and serve up some gold.\n    \"\"\"\n    # Mix-up and marinate\n    random.shuffle(flow_list)\n    crucial_points = [math.pow(point, 2) for point in flow_list]\n    return crucial_points\n\n# Keep it snappy, keep it real\nif __name__ == \"__main__\":\n    beats = [5, 10, 15]   # These beats will not be defeated\n    print(drop_the_mic(beats))\n\n    moods = [1, 2, 3, 4]  # Mood swing like it's the 90s\n    print(shake_and_bake(moods))\n```",
                    "```python\ndef calculate_adaptive_potential(species_population, mutation_rate, selection_pressure):\n    \"\"\"\n    Calculates the adaptive potential of a species based on its population size, mutation rate,\n    and the selection pressure exerted by the environment.\n\n    Args:\n        species_population (int): The size of the species population.\n        mutation_rate (float): The rate at which mutations occur in the species.\n        selection_pressure (float): The environmental pressure acting on the species.\n\n    Returns:\n        float: The calculated adaptive potential of the species.\n    \"\"\"\n    try:\n        if species_population <= 0:\n            raise ValueError(\"Population size must be greater than zero.\")\n        if not (0 < mutation_rate < 1):\n            raise ValueError(\"Mutation rate must be between 0 and 1.\")\n        if selection_pressure < 0:\n            raise ValueError(\"Selection pressure must be non-negative.\")\n\n        genetic_variability = species_population * mutation_rate\n        adaptive_potential = genetic_variability / selection_pressure\n\n        return adaptive_potential\n\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return None\n\n\ndef main():\n    # Example call to the calculate_adaptive_potential function\n    species_population = 1000\n    mutation_rate = 0.01\n    selection_pressure = 0.5\n\n    adaptive_potential = calculate_adaptive_potential(\n        species_population, mutation_rate, selection_pressure)\n\n    if adaptive_potential is not None:\n        print(f\"The adaptive potential of the species is: {adaptive_potential:.2f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List\n\ndef calculate_adaptive_trait_fitness(population_size: int, genetic_variations: List[float]) -> float:\n    \"\"\"\n    Calculate the overall fitness of a population based on its genetic variations.\n\n    Parameters:\n    population_size (int): The total number of individuals in the population.\n    genetic_variations (List[float]): A list of genetic variation indices for the population.\n\n    Returns:\n    float: The calculated fitness value for the population.\n    \"\"\"\n\n    try:\n        if population_size <= 0:\n            raise ValueError(\"Population size must be a positive integer.\")\n        \n        total_variation = sum(genetic_variations)\n        if total_variation == 0:\n            raise ValueError(\"Total genetic variation must not be zero to calculate fitness.\")\n\n        # Example fitness calculation\n        fitness = (total_variation / population_size) * 100\n        return fitness\n    \n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return 0.0\n\n# Example usage\npopulation_size = 100\ngenetic_variations = [0.2, 0.3, 0.5, 0.4, 0.1]\n\nadaptive_trait_fitness = calculate_adaptive_trait_fitness(population_size, genetic_variations)\nprint(f\"Adaptive Trait Fitness: {adaptive_trait_fitness:.2f}\")\n```",
                "Incorrect_Answers": [
                    "```python\n# Function to calculate the fitness of a species \n# based on genetic traits and environmental factors\n\ndef calculate_fitness(genetic_traits, environmental_factors):\n    \"\"\"\n    Calculate the fitness score of a species using its genetic traits \n    and relevant environmental factors.\n\n    Parameters:\n    genetic_traits (dict): A dictionary containing genetic attributes.\n    environmental_factors (dict): A dictionary of environmental conditions.\n\n    Returns:\n    float: A fitness score representing the species' adaptability.\n    \"\"\"\n    fitness_score = 0.0\n    \n    try:\n        for trait, value in genetic_traits.items():\n            if trait in environmental_factors:\n                fitness_score += value * environmental_factors[trait]\n        \n        # Ensure fitness score is within a reasonable range\n        fitness_score = max(0, min(fitness_score, 100))\n    \n    except Exception as e:\n        print(f\"An error occurred in calculating fitness: {e}\")\n    \n    return fitness_score\n\n# Sample data illustrating the usage\ngenetic_traits = {\n    \"agility\": 0.8,\n    \"strength\": 0.6,\n    \"intelligence\": 0.9\n}\n\nenvironmental_factors = {\n    \"agility\": 1.2,\n    \"strength\": 1.0,\n    \"intelligence\": 0.5\n}\n\nfitness = calculate_fitness(genetic_traits, environmental_factors)\nprint(f\"Calculated fitness score: {fitness}\")\n```\n",
                    "```python\n# This function's gonna blow your mind, calculate the mean and flaunt it with style\ndef drop_the_mean_bars(data):\n    \"\"\"Spit the mean value of data like a powerful verse:\n    \n    We're taking an array and finding the mean,\n    Just like a rapper climbing to the scene.\n    \"\"\"\n    \n    if not data:\n        raise ValueError(\"Hey, the list's as empty as a stage without fans!\")\n\n    try:\n        # Keeping the flow tight with built-in sum() and len() for that slick speed\n        total = sum(data)\n        count = len(data)\n        # Lay down the beat with some pure mathematics\n        mean = total / count\n    except Exception as e:\n        # Don't hold back, let them know the error\n        raise RuntimeError(f\"Oh snap, something went down: {e}\")\n\n    # Feel the power of the calculated mean\n    return mean\n\n\ndef main_event():\n    \"\"\"The main event's about to start, hold onto your seats!\"\"\"\n\n    data_set = [23, 47, 12, 89, 34, 55]\n    try:\n        # Dropping the mean bars here, metaphorically striking the stage\n        result = drop_the_mean_bars(data_set)\n        print(f\"The mean value hits at: {result}\")\n    except RuntimeError as error_lyrics:\n        print(f\"We got a problem: {error_lyrics}\")\n\n\n# Starting the main event like announcing a rap battle\nif __name__ == \"__main__\":\n    main_event()\n```",
                    "```python\ndef calculate_premium(user_data):\n    \"\"\"\n    Calculate insurance premium based on user's historical data.\n\n    :param user_data: A dictionary containing user's historical data\n    :return: Calculated premium as a float\n    \"\"\"\n    try:\n        # Extract necessary data fields\n        age = user_data.get('age')\n        driving_experience = user_data.get('driving_experience')\n        past_claims = user_data.get('past_claims')\n\n        # Validate data types and values\n        if not (isinstance(age, int) and isinstance(driving_experience, int) and isinstance(past_claims, int)):\n            raise ValueError(\"Invalid data types for age, driving experience, or past claims.\")\n\n        # A simple risk evaluation based on user data\n        risk_factor = evaluate_risk(age, driving_experience, past_claims)\n\n        # Calculate premium using risk factor\n        premium = base_premium * risk_factor\n\n        return premium\n\n    except Exception as e:\n        print(f\"An error occurred during premium calculation: {e}\")\n        return None\n\ndef evaluate_risk(age, driving_experience, past_claims):\n    \"\"\"\n    Evaluate risk based on user's age, driving experience, and past claims.\n\n    :param age: The age of the user as an integer\n    :param driving_experience: The number of years the user has been driving\n    :param past_claims: The number of past insurance claims made by the user\n    :return: Risk factor as a float\n    \"\"\"\n    # Calculate age factor\n    age_factor = 1 if age < 25 else 0.8\n\n    # Calculate experience factor\n    experience_factor = 0.7 if driving_experience > 5 else 0.9\n\n    # Calculate claims factor\n    claims_factor = 1 + (past_claims * 0.1)\n\n    # Calculate overall risk factor\n    risk_factor = age_factor * experience_factor * claims_factor\n\n    return risk_factor\n\n# Constants\nbase_premium = 500.0\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            }
        ]
    }
}