{
    "Original Persona": "A renowned evolutionary biologist who firmly believes in the separation of science and religion",
    "Expanded Persona": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.",
    "Topic": "coding",
    "Original Sample": "```python\nclass Solution1:\n    def exist(self, b, w):\n        def search(b,i,j,w,pos):\n            if pos==len(w):return True\n            if i<0 or j<0 or i>=len(b) or j>=len(b[0]) or w[pos]!=b[i][j] or v[i][j]:return False\n            v[i][j]=True\n            if search(b,i+1,j,w,pos+1) or search(b,i-1,j,w,pos+1) or search(b,i,j+1,w,pos+1) or search(b,i,j-1,w,pos+1):return True\n            v[i][j]=False\n            return False\n\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if w[0]==b[i][j] and search(b,w,i,j,0):return True\n        return False\n\nclass Solution2:\n    def exist(self, b, w):\n        def search(b,i,j,w,index):\n            if index==len(w)-1:return True\n            temp=b[i][j]\n            b[i][j]=' '\n            if(i>0 and b[i-1][j]==w[index+1] and search(b,i-1,j,w,index+1)==True):return True\n            if(i<len(b)-1 and b[i+1][j]==w[index+1] and search(b,i+1,j,w,index+1)==True):return True\n            if(j>0 and b[i][j-1]==w[index+1] and search(b,i,j-1,w,index+1)==True):return True\n            if(j<len(b[0])-1 and b[i][j+1]==w[index+1] and search(b,i,j+1,w,index+1)==True):return True\n            b[i][j]=temp\n            return False\n\n        row=len(b)\n        col=len(b[0])\n\n        for i in range(row):\n            for j in range(col):\n                if b[i][j]==w[0] and search(b,i,j,w,0)==True:return True\n        return False\n\n\nclass Solution3:\n    def __init__(self):self.directions=[0,1,0,-1,0]\n\n    def exist(self, b, w):\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if b[i][j]==w[0]:\n                    v[i][j]=True\n                    if self.existByDfs(b,i,j,w[1::],v,m,n):return True\n                    v[i][j]=False\n        return False\n\n    def existByDfs(self,b,startI,startJ,w,v,m,n):\n        if w==\"\":return True\n        for i in range(len(self.directions)-1):\n            nextX=startI+self.directions[i]\n            nextY=startJ+self.directions[i+1]\n            if nextX>=0 and nextX<m and nextY>=0 and nextY<n and not v[nextX][nextY] and b[nextX][nextY]==w[0]:\n                v[nextX][nextY]=True\n                if self.existByDfs(b,nextX,nextY,w[1::],v,m,n):return True\n                v[nextX][nextY]=False\n        return False\n```",
    "Coding and Formatting Styles": "{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}",
    "Updated Coding Sample": "```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            \n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \n                word[position] != board[i][j] or visited[i][j]):\n                return False\n            \n            # Mark current cell as visited\n            visited[i][j] = True\n            \n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            \n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
    "Conversation": [
        "[Original_Code]: ```python\nclass Solution1:\n    def exist(self, b, w):\n        def search(b,i,j,w,pos):\n            if pos==len(w):return True\n            if i<0 or j<0 or i>=len(b) or j>=len(b[0]) or w[pos]!=b[i][j] or v[i][j]:return False\n            v[i][j]=True\n            if search(b,i+1,j,w,pos+1) or search(b,i-1,j,w,pos+1) or search(b,i,j+1,w,pos+1) or search(b,i,j-1,w,pos+1):return True\n            v[i][j]=False\n            return False\n\n        m=len(b)\n        n=len(b[0])\n        v=[[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if w[0]==b[i][j] and search(b,w,i,j,0):return True\n        return False\n```",
        "[Side_Note]: [Coding Styles] Dislikes Long functions that tackle multiple responsibilities, leading to convoluted logic.",
        "User: I need help to refactor this code to improve clarity and organization. I dislike long functions that tackle multiple responsibilities as they lead to convoluted logic.",
        "Assistant: To address that, we can break down the main functionalities into smaller, more manageable functions. Let's start with defining the search function more clearly and implementing good practices. Here\u2019s a modified version of your code.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            if position == len(word): return True\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[position] != board[i][j] or visited[i][j]): return False\n            visited[i][j] = True\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            visited[i][j] = False\n            return False\n\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: I appreciate the breakdown, but I see some issues with formatting. I dislike that the conditions in the search function aren\u2019t properly spaced, and I prefer more meaningful variable names related to biology.",
        "[Side_Note]: [Formatting Styles] Likes Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.",
        "[Side_Note]: [Coding Styles] Likes Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.",
        "User: Can we update that for better readability? Changing 'b' to 'board' and 'w' to 'word' will make it clearer.",
        "Assistant: Absolutely, I\u2019ll apply proper spacing, consistent variable naming, and improve the comments throughout the code. Here\u2019s the updated version.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \n                word[position] != board[i][j] or visited[i][j]):\n                return False\n            # Mark current cell as visited\n            visited[i][j] = True\n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: This looks much better! However, I still see that line lengths might exceed 79 characters. Let's keep everything within that limit for better readability.",
        "[Side_Note]: [Formatting Styles] Dislikes Excessively long lines of code that exceed 79 characters, making it hard to read.",
        "User: Can you do that?",
        "Assistant: Sure, I'll ensure that no line exceeds 79 characters. Here\u2019s the final version with all adjustments made.",
        "Assistant: ```python\nclass Solution:\n    def exist(self, board, word):\n        def search(board, i, j, word, position):\n            # Check if the entire word has been matched\n            if position == len(word): \n                return True\n            # Out of bounds or character mismatch or already visited\n            if (i < 0 or j < 0 or i >= len(board) or\n                j >= len(board[0]) or word[position] != board[i][j] or\n                visited[i][j]):\n                return False\n            # Mark current cell as visited\n            visited[i][j] = True\n            # Explore all four possible directions\n            if (search(board, i + 1, j, word, position + 1) or\n                search(board, i - 1, j, word, position + 1) or\n                search(board, i, j + 1, word, position + 1) or\n                search(board, i, j - 1, word, position + 1)):\n                return True\n            # Backtrack\n            visited[i][j] = False\n            return False\n\n        # Initialize board dimensions and visited array\n        rows = len(board)\n        cols = len(board[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        # Search for the first character of the word in the board\n        for i in range(rows):\n            for j in range(cols):\n                if word[0] == board[i][j] and search(board, i, j, word, 0):\n                    return True\n        return False\n```",
        "User: This perfectly aligns with my coding and formatting preferences. Thank you for your assistance!"
    ],
    "Q&A": {
        "Conversation": [
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# Import necessary libraries for data analysis\nimport math\nimport statistics\n\ndef calculate_genetic_diversity(populations):\n    \"\"\"\n    Calculate genetic diversity of a list of populations using Shannon Index.\n    \n    Parameters:\n    populations (list of tuples): A list where each tuple represents a species population\n                                  as (species_name, population_size).\n    \n    Returns:\n    float: The calculated Shannon diversity index for the given populations.\n    \n    Example:\n    >>> calculate_genetic_diversity([('species_a', 50), ('species_b', 30), ('species_c', 20)])\n    1.0296530140645737\n    \"\"\"\n    try:\n        total_population = sum(size for species, size in populations)\n        if total_population == 0:\n            raise ValueError(\"Total population must be greater than zero.\")\n\n        diversity_index = 0.0\n        for species, size in populations:\n            proportion = size / total_population\n            diversity_index -= proportion * math.log(proportion)\n\n        return diversity_index\n    \n    except Exception as error:\n        print(f\"An error occurred: {error}\")\n        return None\n\ndef normalize_population_sizes(population_sizes):\n    \"\"\"\n    Normalize the sizes of populations to a range between 0 and 1.\n    \n    Parameters:\n    population_sizes (list of int): List of population sizes to be normalized.\n    \n    Returns:\n    list of float: Normalized population sizes between 0 and 1.\n    \n    Example:\n    >>> normalize_population_sizes([50, 30, 20])\n    [0.5, 0.3, 0.2]\n    \"\"\"\n    try:\n        total = sum(population_sizes)\n        if total == 0:\n            raise ValueError(\"Sum of population sizes must be greater than zero.\")\n        \n        return [size / total for size in population_sizes]\n\n    except Exception as error:\n        print(f\"An error occurred: {error}\")\n        return []\n\n# Example usage of the functions\nif __name__ == \"__main__\":\n    populations = [\n        ('species_a', 50),\n        ('species_b', 30),\n        ('species_c', 20)\n    ]\n    \n    diversity_index = calculate_genetic_diversity(populations)\n    print(f\"Shannon diversity index: {diversity_index}\")\n\n    population_sizes = [50, 30, 20]\n    normalized_sizes = normalize_population_sizes(population_sizes)\n    print(f\"Normalized population sizes: {normalized_sizes}\")\n```",
                "Incorrect_Answers": [
                    "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyze a collection of documents related to the Eastern Wu period.\n\n    Parameters:\n    documents (list): A list of strings where each string is a document related to Eastern Wu.\n\n    Returns:\n    dict: A dictionary containing analysis results such as counts of specific historical references.\n    \"\"\"\n    analysis_results = {\n        'total_documents': len(documents),\n        'historical_references': 0,\n        'error_documents': []\n    }\n\n    for document in documents:\n        try:\n            historical_references = count_historical_references(document)\n            analysis_results['historical_references'] += historical_references\n        except Exception as e:\n            # Log error and continue with next document\n            error_message = f\"Error processing document: {str(e)}\"\n            analysis_results['error_documents'].append(error_message)\n            continue\n\n    return analysis_results\n\n\ndef count_historical_references(document):\n    \"\"\"\n    Count historical references specific to the Eastern Wu period within a document.\n\n    Parameters:\n    document (str): A string containing the document text.\n\n    Returns:\n    int: The number of historical references found.\n    \"\"\"\n    # Dummy implementation for illustration, actual logic would involve complex parsing\n    historical_keywords = ['Sun Quan', 'Battle of Red Cliffs', 'Three Kingdoms']\n    count = 0\n    for keyword in historical_keywords:\n        count += document.count(keyword)\n    return count\n\n\n# Example usage\nif __name__ == \"__main__\":\n    documents = [\n        \"The Eastern Wu, led by Sun Quan, reached its height...\",\n        \"The Battle of Red Cliffs was a turning point in the Three Kingdoms period...\"\n    ]\n\n    results = analyze_eastern_wu_documents(documents)\n    print(\"Analysis Results:\", results)\n```",
                    "```python\nclass Player:\n    \"\"\"\n    A class to represent a football player.\n    \"\"\"\n    \n    def __init__(self, name: str, position: str):\n        \"\"\"\n        Initialize a new player with a name and position.\n        \n        :param name: Player's name\n        :param position: Player's position on the field\n        \"\"\"\n        self.name = name\n        self.position = position\n\n    def get_stats(self, games_played: int, total_yards: float) -> float:\n        \"\"\"\n        Calculate average yards per game.\n        \n        :param games_played: Total number of games played\n        :param total_yards: Total yards gained\n        :return: Average yards per game\n        \"\"\"\n        try:\n            avg_yards = total_yards / games_played\n        except ZeroDivisionError:\n            avg_yards = 0.0\n        \n        return avg_yards\n\ndef main():\n    \"\"\"\n    Main function to create a player and calculate their statistics.\n    \"\"\"\n    # Organizing the main logic of creating a player and calculating statistics\n    player_name = \"Alex Rivers\"\n    player_position = \"Quarterback\"\n    \n    # Create a new Player instance\n    alex = Player(name=player_name, position=player_position)\n    \n    # Define game data\n    total_games = 16\n    total_yards_gained = 4250.5\n    \n    # Calculate average yards per game\n    average_yards = alex.get_stats(games_played=total_games, total_yards=total_yards_gained)\n    \n    # Display player information and calculated statistics\n    print(f\"Player: {alex.name}, Position: {alex.position}\")\n    print(f\"Average Yards per Game: {average_yards:.2f}\")\n\nif __name__ == \"__main__\":\n    # Execute the main function\n    main()\n```",
                    "```python\nimport json\nfrom datetime import date\n\ndef fetch_user_data(user_id):\n    \"\"\"Fetch user data for a given user ID.\"\"\"\n    # Simulate API request\n    response = '{\"id\": 1, \"name\": \"Alex\", \"birth_year\": 1986}'\n    return parse_json(response)\n\ndef parse_json(response):\n    \"\"\"Parse JSON response and return a dictionary.\"\"\"\n    try:\n        data = json.loads(response)\n        return data\n    except json.JSONDecodeError as e:\n        print(f\"Error parsing JSON: {e}\")\n        return {}\n\ndef calculate_total(price, tax_rate):\n    \"\"\"Calculate the total price including tax.\"\"\"\n    total = price + (price * tax_rate)\n    return total\n\ndef get_user_age(user_data):\n    \"\"\"Calculate the age of the user based on their birth year.\"\"\"\n    current_year = date.today().year\n    try:\n        age = current_year - user_data['birth_year']\n        return age\n    except KeyError:\n        print(\"Birth year not available in user data.\")\n        return None\n\nif __name__ == \"__main__\":\n    user_data = fetch_user_data(1)\n    user_age = get_user_age(user_data)\n    print(f\"User age: {user_age}\")\n    \n    price = 100.0\n    tax_rate = 0.07\n    total_price = calculate_total(price, tax_rate)\n    print(f\"Total price: {total_price:.2f}\")\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\n# Import statements organized as per PEP 8 guidelines\nimport math\nfrom typing import List  # Third-party imports\nfrom datetime import datetime  # Standard library imports\n\n# Local imports\n# from .custom_module import CustomFunction\n\ndef calculate_adaptive_potential(\n        genetic_variability: float,\n        selection_pressure: float,\n        environmental_stability: float\n    ) -> float:\n    \"\"\"\n    Calculate the adaptive potential of a species based on genetic variability,\n    selection pressure, and environmental stability.\n\n    Args:\n        genetic_variability (float): Measure of genetic diversity within the species.\n        selection_pressure (float): Strength of the selection forces acting on the species.\n        environmental_stability (float): Degree of predictability in the environment.\n\n    Returns:\n        float: The calculated adaptive potential.\n    \"\"\"\n    try:\n        if genetic_variability < 0 or selection_pressure < 0 or environmental_stability < 0:\n            raise ValueError(\"Inputs must be non-negative\")\n\n        # Calculate fitness component factors\n        genetic_factor = genetic_variability * 0.5\n        selection_factor = math.exp(-selection_pressure)\n        environmental_factor = (1 - environmental_stability) ** 2\n\n        # Calculate total adaptive potential\n        adaptive_potential = genetic_factor + selection_factor + environmental_factor\n        return adaptive_potential\n\n    except TypeError as error:\n        raise ValueError(\"All inputs must be numeric\") from error\n\ndef simulate_species_adaptation(\n        generations: int, \n        initial_population: int\n    ) -> List[float]:\n    \"\"\"\n    Simulate the adaptation of a species over a specified number of generations.\n\n    Args:\n        generations (int): Number of generations to simulate.\n        initial_population (int): Initial size of the population.\n\n    Returns:\n        List[float]: List containing the population size at each generation.\n    \"\"\"\n    population_sizes = []\n    current_population = initial_population\n\n    for generation in range(1, generations + 1):\n        # Example values matching the logic of adaptive potential calculation\n        variability = 0.8\n        pressure = 0.2\n        stability = 0.1\n\n        adaptive_potential = calculate_adaptive_potential(variability, pressure, stability)\n\n        # Assume growth rate is proportional to adaptive potential\n        growth_rate = adaptive_potential * 0.1\n        current_population = int(current_population * (1 + growth_rate))\n        population_sizes.append(current_population)\n\n    return population_sizes\n```\n",
                "Incorrect_Answers": [
                    "```python\nfrom typing import List\n\ndef filter_extremophiles(organisms: List[dict]) -> List[dict]:\n    \"\"\"\n    Filters a list of organisms and returns only those classified as extremophiles.\n\n    Parameters:\n    organisms (List[dict]): A list of dictionaries, where each dictionary represents an organism\n                            and contains a key 'is_extremophile' marking its classification.\n\n    Returns:\n    List[dict]: A list of dictionaries containing only the extremophiles.\n\n    Raises:\n    ValueError: If an organism entry doesn't contain the 'is_extremophile' key.\n    \"\"\"\n    extremophiles = []\n    for organism in organisms:\n        try:\n            if organism['is_extremophile']:\n                extremophiles.append(organism)\n        except KeyError:\n            raise ValueError(\"Organism entry missing 'is_extremophile' key.\")\n\n    return extremophiles\n\ndef map_to_metabolic_types(extremophiles: List[dict]) -> dict:\n    \"\"\"\n    Maps extremophiles to their respective metabolic types.\n\n    Parameters:\n    extremophiles (List[dict]): A list of extremophile dictionaries, each containing\n                                'name' and 'metabolic_type' keys.\n\n    Returns:\n    dict: A dictionary with metabolic types as keys and a list of extremophile names as values.\n\n    Example:\n    {\n        'chemoautotroph': ['Organism1', 'Organism2'],\n        'photoautotroph': ['Organism3']\n    }\n    \"\"\"\n    metabolic_mapping = {}\n    for organism in extremophiles:\n        metabolic_type = organism['metabolic_type']\n\n        # Using a setdefault to streamline mapping initialization\n        metabolic_mapping.setdefault(metabolic_type, []).append(organism['name'])\n\n    return metabolic_mapping\n\ndef main():\n    \"\"\"\n    Main function to demonstrate filtering and mapping of extremophiles.\n\n    Utilizes the `filter_extremophiles` and `map_to_metabolic_types` on a sample dataset.\n    \"\"\"\n    sample_organisms = [\n        {'name': 'Halobacterium', 'is_extremophile': True, 'metabolic_type': 'chemoautotroph'},\n        {'name': 'Deinococcus', 'is_extremophile': False, 'metabolic_type': 'photoautotroph'},\n        {'name': 'Tardigrade', 'is_extremophile': True, 'metabolic_type': 'photoautotroph'},\n    ]\n\n    # Filter the extremophiles from the sample dataset\n    extremophiles = filter_extremophiles(sample_organisms)\n    \n    # Map the filtered extremophiles to their metabolic types\n    metabolic_mapping = map_to_metabolic_types(extremophiles)\n    \n    print(metabolic_mapping)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n\"\"\"\nModule for Wildflower Conservation Analytics\n\nThis module provides functionality to assess the impact of urban\ndevelopment on wildflower species and proposes conservation\nstrategies based on collected data.\n\nFunctions:\n- assess_biodiversity_impact: Calculate the impact on biodiversity\n  using various ecological metrics.\n- identify_endangered_species: Identify species that are at risk \n  due to urban expansion.\n- propose_conservation_strategies: Suggest strategies to mitigate \n  negative impacts on wildflower populations.\n\"\"\"\n\nfrom typing import List, Tuple\n\n# Standard library imports\nimport logging\n\n# Third-party imports\nimport numpy as np\n\n# Local imports\nimport data_processing\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef assess_biodiversity_impact(\n        data: np.ndarray) -> Tuple[float, List[str]]:\n    \"\"\"\n    Calculate the impact on biodiversity using ecological metrics.\n\n    Parameters:\n    data (np.ndarray): An array containing biodiversity data.\n\n    Returns:\n    Tuple[float, List[str]]: A tuple containing the biodiversity index\n    score and a list of impacted species.\n    \"\"\"\n    try:\n        biodiversity_index = np.mean(data)\n        impacted_species = [\"Species A\", \"Species B\"]\n        logging.info(\"Biodiversity impact assessed successfully.\")\n        return biodiversity_index, impacted_species\n    except Exception as error:\n        logging.error(\"Error in assessing biodiversity impact: %s\", error)\n        raise\n\n\ndef identify_endangered_species(\n        species_list: List[str], threshold: float = 0.1) -> List[str]:\n    \"\"\"\n    Identify species at risk due to urban expansion.\n\n    Parameters:\n    species_list (List[str]): A list of species names.\n    threshold (float): Threshold for endangerment classification.\n\n    Returns:\n    List[str]: A list of endangered species.\n    \"\"\"\n    try:\n        endangered_species = [\n            species for species in species_list if np.random.rand() < threshold]\n        logging.info(\"Endangered species identified: %s\", endangered_species)\n        return endangered_species\n    except Exception as error:\n        logging.error(\"Error in identifying endangered species: %s\", error)\n        raise\n\n\ndef propose_conservation_strategies(\n        endangered_species: List[str]) -> None:\n    \"\"\"\n    Suggest strategies to mitigate negative impacts on wildflower populations.\n\n    Parameters:\n    endangered_species (List[str]): A list of endangered species.\n\n    Returns:\n    None\n    \"\"\"\n    try:\n        if not endangered_species:\n            logging.info(\"No endangered species found.\")\n            return\n\n        for species in endangered_species:\n            logging.info(\"Proposing conservation strategies for: %s\", species)\n            # Implement specific conservation strategies\n            # Placeholder for strategy implementation\n            print(f\"Conservation proposal for {species}\")\n    except Exception as error:\n        logging.error(\"Error in proposing conservation strategies: %s\", error)\n        raise\n```\n",
                    "```python\ndef calculate_net_income(income, deductions):\n    \"\"\"\n    Calculate the net income after applying the given deductions.\n\n    Parameters:\n    income (float): The gross income before deductions.\n    deductions (float): The total amount of deductions to be applied.\n\n    Returns:\n    float: The net income after deductions.\n    \"\"\"\n    try:\n        # Ensure inputs are valid numbers\n        if not isinstance(income, (int, float)) or not isinstance(deductions, (int, float)):\n            raise ValueError(\"Income and deductions must be numbers.\")\n\n        # Calculate the net income\n        net_income = income - deductions\n\n        return net_income\n    except Exception as e:\n        print(f\"An error occurred when calculating net income: {e}\")\n\ndef print_family_expenses(expenses):\n    \"\"\"\n    Print out the family expenses for better financial planning.\n\n    Parameters:\n    expenses (dict): A dictionary where keys are expense categories and values are amounts.\n\n    Returns:\n    None\n    \"\"\"\n    try:\n        # Check if expenses is a dictionary\n        if not isinstance(expenses, dict):\n            raise ValueError(\"Expenses must be a dictionary.\")\n\n        # Print each expense\n        for category, amount in expenses.items():\n            print(f\"{category}: ${amount}\")\n    except Exception as e:\n        print(f\"An error occurred when printing expenses: {e}\")\n\n# Example Usage\nuser_income = 5000.00  # Monthly income in dollars\nuser_deductions = 1200.00  # Monthly deductions\nnet_income = calculate_net_income(user_income, user_deductions)\nprint(f\"Net Income: ${net_income}\")\n\nfamily_expenses = {\n    \"Rent\": 1500.00,\n    \"Utilities\": 300.00,\n    \"Groceries\": 600.00\n}\nprint_family_expenses(family_expenses)\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom math import sqrt\nfrom collections import namedtuple\n\n# Define a data structure to represent a species' genome\nGenome = namedtuple('Genome', ['gene1', 'gene2', 'gene3'])\n\ndef calculate_fitness(genome):\n    \"\"\"\n    Calculate the fitness of a species based on its genome.\n\n    Fitness is determined by a simple model where the sum of genome attributes\n    indicates the species' adaptability to the environment.\n\n    :param genome: A named tuple representing the genome of the species.\n    :return: A float representing the fitness score.\n    \"\"\"\n    try:\n        gene_sum = genome.gene1 + genome.gene2 + genome.gene3\n        fitness_score = sqrt(gene_sum)\n        return fitness_score\n    except TypeError:\n        raise ValueError(\"Genome attributes must be numbers.\")\n\ndef main():\n    \"\"\"\n    Main function to create a genome and calculate its fitness.\n    \"\"\"\n    species_genome = Genome(gene1=12.0, gene2=15.5, gene3=10.2)\n    \n    try:\n        fitness = calculate_fitness(species_genome)\n        print(f\"The fitness score of the species is: {fitness}\")\n    except ValueError as e:\n        print(f\"Error calculating fitness: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\nclass Team:\n    \"\"\"\n    Team class represents a football team with methods to calculate \n    team efficiency stats such as average speed and total points.\n    \"\"\"\n\n    def __init__(self, name, players):\n        \"\"\"\n        Initializes the Team with a name and a list of player statistics.\n        \n        :param name: str - The name of the team.\n        :param players: list of dict - Player statistics including 'name', 'yards', and 'games'.\n        \"\"\"\n        self.name = name\n        self.players = players\n\n    def average_yards_per_game(self):\n        \"\"\"\n        Calculates the average yards per game for the team.\n\n        :return: float - Average yards per game across all players.\n        \"\"\"\n        total_yards = 0\n        total_games = 0\n\n        for player in self.players:\n            # Accumulating total yards and games played\n            total_yards += player.get('yards', 0)\n            total_games += player.get('games', 0)\n        \n        # Prevent division by zero\n        if total_games == 0:\n            return 0.0\n\n        return total_yards / total_games\n\ndef calculate_average_speed(total_distance, total_time):\n    \"\"\"\n    Calculate the average speed given distance and time.\n    \n    :param total_distance: float - Total distance covered.\n    :param total_time: float - Time taken to cover the distance.\n    :return: float - Average speed or zero if time is zero.\n    \"\"\"\n    try:\n        return total_distance / total_time\n    except ZeroDivisionError:\n        return 0.0\n\n# Example usage\nplayers = [\n    {'name': 'Alex', 'yards': 560, 'games': 8},\n    {'name': 'Jordan', 'yards': 480, 'games': 8}\n]\n\nteam = Team(name='Thunderbirds', players=players)\nprint(\"Average Yards per Game:\", team.average_yards_per_game())\nprint(\"Average Speed:\", calculate_average_speed(100, 10))\n```",
                    "```python\n# Importing necessary modules for underwater hockey scoring system.\nimport math  # Standard library import\nimport numpy as np  # Third-party import for advanced numerical operations\nimport local_utils  # Local import, e.g., helper functions for specific game logistics\n\ndef calculate_area_of_play(length: float, width: float) -> float:\n    \"\"\"\n    Calculates the area of the play field for underwater hockey.\n\n    Parameters:\n    length (float): The length of the play area in meters.\n    width (float): The width of the play area in meters.\n\n    Returns:\n    float: The area of the play field in square meters.\n    \"\"\"\n    return length * width\n\ndef calculate_distance(p1: tuple, p2: tuple) -> float:\n    \"\"\"\n    Calculates the distance between two players on the field.\n    \n    Parameters:\n    p1 (tuple): The (x, y) position of player 1.\n    p2 (tuple): The (x, y) position of player 2.\n    \n    Returns:\n    float: The distance between player 1 and player 2.\n    \"\"\"\n    dx = p1[0] - p2[0]\n    dy = p1[1] - p2[1]\n    return math.sqrt(dx ** 2 + dy ** 2)\n\ndef record_score(player: str, score: int, scores: dict) -> None:\n    \"\"\"\n    Adds a player's score to the game record.\n\n    Parameters:\n    player (str): The name of the player.\n    score (int): The score made by the player.\n    scores (dict): The dictionary holding current game scores.\n\n    Returns:\n    None\n    \"\"\"\n    try:\n        scores[player] += score\n    except KeyError:\n        # If the player is not already in the scores dictionary, initialize their score\n        scores[player] = score\n\ndef main():\n    \"\"\"\n    Main function to simulate a simple underwater hockey game.\n    \"\"\"\n    # Initialize variables with descriptive names for clarity\n    play_area_length = 15.0  # length of the field in meters\n    play_area_width = 10.0   # width of the field in meters\n    game_scores = {}\n\n    # Calculate and output the play area\n    area = calculate_area_of_play(play_area_length, play_area_width)\n    print(f\"The play area is {area:.2f} square meters.\")\n\n    # Record some example scores\n    record_score('Arjun', 3, game_scores)\n    record_score('Alex', 2, game_scores)\n\n    # Output the game scores\n    for player, score in game_scores.items():\n        print(f\"{player}: {score} goals\")\n\nif __name__ == '__main__':\n    main()\n```",
                    "```python\nimport numpy as np\n\ndef calculate_dose(weight, concentration):\n    \"\"\"\n    Calculate the medication dose based on weight and drug concentration.\n\n    Parameters:\n    weight (float): The weight of the patient in kilograms.\n    concentration (float): The concentration of the drug in mg/mL.\n\n    Returns:\n    float: The dose in milligrams.\n    \"\"\"\n    try:\n        if weight <= 0 or concentration <= 0:\n            raise ValueError(\"Weight and concentration must be positive numbers.\")\n        dose = weight * concentration\n        return dose\n    except Exception as e:\n        print(f\"Error calculating dose: {e}\")\n        return None\n\n\ndef prepare_solution(concentration, volume):\n    \"\"\"\n    Prepare a solution with a given concentration and volume.\n\n    Parameters:\n    concentration (float): The concentration of the solution in mg/mL.\n    volume (float): The volume of the solution in mL.\n\n    Returns:\n    float: The total amount of active ingredient in mg.\n    \"\"\"\n    try:\n        active_ingredient = concentration * volume\n        return active_ingredient\n    except Exception as e:\n        print(f\"Error preparing solution: {e}\")\n        return None\n\n\ndef main():\n    # Example usage\n    weight = 70.0  # kg\n    concentration = 2.5  # mg/mL\n\n    dose = calculate_dose(weight, concentration)\n    if dose:\n        print(f\"The calculated dose is: {dose} mg\")\n\n    volume = 100.0  # mL\n    active_ingredient = prepare_solution(concentration, volume)\n    if active_ingredient:\n        print(f\"The active ingredient amount is: {active_ingredient} mg\")\n\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List, Tuple\n\ndef calculate_adaptive_value(traits: List[float]) -> float:\n    \"\"\"\n    Calculate adaptive value based on given traits.\n\n    The adaptive value represents the fitness of an organism based on its traits.\n    The function uses a hypothetical model that evaluates trait contribution to \n    overall fitness.\n\n    Parameters:\n    traits (List[float]): A list of numerical values representing different traits.\n\n    Returns:\n    float: The calculated adaptive value.\n    \"\"\"\n    try:\n        # Weighted sum of traits as a simplistic model for adaptive value\n        adaptive_value = sum(trait ** 2 for trait in traits) / len(traits)\n        return adaptive_value\n    except ZeroDivisionError:\n        raise ValueError(\"The 'traits' list must not be empty.\")\n\ndef diversify_population(population_traits: List[List[float]]) -> List[Tuple[float, List[float]]]:\n    \"\"\"\n    Diversify a population by calculating adaptive values for each individual.\n\n    This function processes trait data for a population and returns a sorted list \n    of individuals by their adaptive values.\n\n    Parameters:\n    population_traits (List[List[float]]): A list of trait lists for every individual \n                                            in the population.\n\n    Returns:\n    List[Tuple[float, List[float]]]: A list of tuples where each tuple contains the \n                                     adaptive value and the associated traits.\n    \"\"\"\n    diversified_population = []\n    for traits in population_traits:\n        try:\n            adaptive_value = calculate_adaptive_value(traits)\n            diversified_population.append((adaptive_value, traits))\n        except ValueError as e:\n            print(f\"Error processing traits {traits}: {e}\")\n\n    # Sort population by adaptive value in descending order\n    diversified_population.sort(key=lambda x: x[0], reverse=True)\n    return diversified_population\n\n# Example usage:\npopulation = [\n    [0.5, 1.2, 0.3],\n    [1.5, 1.0, 2.1],\n    [0.2, 0.8, 0.5]\n]\n\ndiversified_population = diversify_population(population)\nfor value, traits in diversified_population:\n    print(f\"Adaptive Value: {value:.2f}, Traits: {traits}\")\n```",
                "Incorrect_Answers": [
                    "```python\n\"\"\"\nThis module provides basic mathematical operations.\n\"\"\"\n\n# Import standard library\nimport math\n\ndef calculate_sum(a, b):\n    \"\"\"\n    Calculate the sum of two numbers.\n\n    Args:\n        a (float): The first number.\n        b (float): The second number.\n\n    Returns:\n        float: The sum of a and b.\n    \"\"\"\n    return a + b\n\ndef calculate_square_root(value):\n    \"\"\"\n    Calculate the square root of a number.\n\n    Args:\n        value (float): The number to find the square root of.\n\n    Returns:\n        float: The square root of the number, or Error if negative.\n    \"\"\"\n    try:\n        return math.sqrt(value)\n    except ValueError:\n        return 'Error'\n\ndef main():\n    \"\"\"\n    Main function to execute example calculations.\n    \"\"\"\n    # Example calculations\n    first_number = 10\n    second_number = 20\n\n    # Calculate sum\n    total = calculate_sum(first_number, second_number)\n    print(f\"The sum is: {total}\")\n\n    # Calculate square root\n    result = calculate_square_root(total)\n    print(f\"The square root is: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\ndef analyze_eastern_wu_documents(documents):\n    \"\"\"\n    Analyzes a collection of documents from the Eastern Wu period.\n\n    Args:\n        documents (list): A list of documents represented as strings\n        from the Eastern Wu period.\n\n    Returns:\n        dict: A summary of findings including key historical themes\n        and socio-political insights.\n    \"\"\"\n    summary_of_findings = {}\n\n    for document in documents:\n        try:\n            parsed_data = parse_document(document)\n            research_summary = summarize_research(parsed_data)\n            update_findings(summary_of_findings, research_summary)\n        except Exception as e:\n            print(f\"Error processing document: {e}\")\n    \n    return summary_of_findings\n\n\ndef parse_document(document):\n    \"\"\"\n    Parses a given document and extracts essential information.\n\n    Args:\n        document (str): A document from the Eastern Wu period.\n\n    Returns:\n        dict: Parsed information such as main topics and key figures.\n    \"\"\"\n    # Implement parsing logic here\n    pass\n\n\ndef summarize_research(parsed_data):\n    \"\"\"\n    Summarizes research from parsed data to extract socio-political insights.\n\n    Args:\n        parsed_data (dict): Information extracted from a document.\n\n    Returns:\n        dict: Summary of historical themes and socio-political structures.\n    \"\"\"\n    # Implement summary logic here\n    pass\n\n\ndef update_findings(summary_of_findings, research_summary):\n    \"\"\"\n    Updates the existing findings with new research summaries.\n\n    Args:\n        summary_of_findings (dict): Current summary of findings.\n        research_summary (dict): New research data to be added.\n\n    Returns:\n        None\n    \"\"\"\n    # Implement update logic here\n    pass\n\n# Example usage:\n# documents = [\"Document string 1\", \"Document string 2\"]\n# findings = analyze_eastern_wu_documents(documents)\n```",
                    "```python\n# Import required libraries\nimport requests\n\ndef fetch_aviation_data(api_url):\n    \"\"\"\n    Fetch aviation-related data from the given API URL.\n\n    Parameters:\n    api_url (str): The URL of the API endpoint to retrieve data from.\n\n    Returns:\n    dict: The JSON response from the API containing aviation data.\n    \"\"\"\n    try:\n        response = requests.get(api_url)\n        response.raise_for_status()  # Raises an HTTPError for bad responses\n        # Retrieve aviation data in JSON format\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        # Handle exceptions related to network requests and log the error\n        print(f\"An error occurred: {e}\")\n        return {}\n\ndef calculate_flight_duration(distance_km, speed_kmph):\n    \"\"\"\n    Calculate the duration of a flight given distance and speed.\n\n    Parameters:\n    distance_km (float): The distance of the flight in kilometers.\n    speed_kmph (float): The average speed of the aircraft in kilometers per hour.\n\n    Returns:\n    float: The duration of the flight in hours.\n    \"\"\"\n    try:\n        # Compute flight duration\n        return distance_km / speed_kmph\n    except ZeroDivisionError:\n        # Handle division by zero if speed is zero\n        print(\"Speed cannot be zero for duration calculation.\")\n        return float('inf')\n\ndef main():\n    aviation_api = \"https://api.example.com/aviation/data\"\n    # Fetch and print aviation data\n    aviation_data = fetch_aviation_data(aviation_api)\n    print(\"Aviation Data Retrieved:\", aviation_data)\n\n    # Sample flight data\n    distance_km = 1500.0\n    speed_kmph = 750.0\n    \n    # Calculate and print flight duration\n    flight_duration = calculate_flight_duration(distance_km, speed_kmph)\n    print(f\"Flight Duration: {flight_duration} hours\")\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List\n\ndef calculate_growth_rate(initial_population: int, growth_factor: float, time_periods: int) -> List[int]:\n    \"\"\"\n    Calculate population growth over time based on an exponential model.\n\n    :param initial_population: The starting number of individuals in the population.\n    :param growth_factor: The growth factor per time period (e.g., 1.1 for 10% growth per period).\n    :param time_periods: The number of time periods over which the population grows.\n    :return: A list representing the population size at each time period.\n    \"\"\"\n    try:\n        population_sizes = []\n        \n        for time in range(time_periods + 1):\n            population = initial_population * math.pow(growth_factor, time)\n            population_sizes.append(int(population))\n        \n        return population_sizes\n\n    except (TypeError, ValueError) as error:\n        print(f\"An error occurred: {error}\")\n        return []\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the calculate_growth_rate function.\n    \"\"\"\n    initial_population = 100\n    growth_factor = 1.2\n    time_periods = 5\n    \n    try:\n        growth = calculate_growth_rate(initial_population, growth_factor, time_periods)\n        print(f\"Population growth over {time_periods} periods: {growth}\")\n    except Exception as general_error:\n        print(f\"An unexpected error occurred: {general_error}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\nimport datetime\nfrom typing import List, Dict\n\ndef calculate_premium(age: int, health_factors: List[str]) -> float:\n    \"\"\"\n    Calculate the insurance premium based on customer age and health factors.\n\n    Args:\n        age (int): The age of the customer.\n        health_factors (List[str]): A list of health factors affecting the premium.\n\n    Returns:\n        float: The calculated insurance premium.\n    \"\"\"\n    # Verify input parameters\n    if age < 0:\n        raise ValueError(\"Age cannot be negative.\")\n    elif not health_factors:\n        print(\"Warning: Health factors list is empty.\")\n\n    # Base premium rate\n    base_rate = 500.0\n\n    # Adjust premium based on age\n    age_factor = 1.2 if age > 50 else 1.0\n\n    # Calculate health factor impact\n    health_impact = len(health_factors) * 0.1\n\n    # Final premium calculation\n    premium = base_rate * age_factor * (1 + health_impact)\n\n    return premium\n\ndef evaluate_risk(premiums: List[float]) -> Dict[str, float]:\n    \"\"\"\n    Evaluate the risk based on calculated premiums.\n\n    Args:\n        premiums (List[float]): A list of calculated premiums.\n\n    Returns:\n        Dict[str, float]: A dictionary with minimum, maximum, and average premium values.\n    \"\"\"\n    if not premiums:\n        raise ValueError(\"Premiums list cannot be empty.\")\n\n    # Compute risk metrics\n    min_premium = min(premiums)\n    max_premium = max(premiums)\n    avg_premium = sum(premiums) / len(premiums)\n\n    return {\n        'minimum': min_premium,\n        'maximum': max_premium,\n        'average': avg_premium\n    }\n\ndef main() -> None:\n    \"\"\"\n    Main function to execute the premium calculation and risk evaluation.\n    \"\"\"\n    ages = [29, 55, 70]\n    healths = [[\"smoker\"], [\"diabetes\", \"hypertension\"], []]\n    premiums = []\n\n    for age, health in zip(ages, healths):\n        try:\n            premium = calculate_premium(age, health)\n            premiums.append(premium)\n        except ValueError as e:\n            print(f\"Error calculating premium: {e}\")\n\n    risk_evaluation = evaluate_risk(premiums)\n    print(f\"Risk Evaluation: {risk_evaluation}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport numpy as np\n\n# Load and transform data efficiently\ndef load_data(file_path):\n    \"\"\"\n    Load data from a file and convert it into a numpy array.\n\n    :param file_path: The path to the data file.\n    :return: A numpy array of the loaded data.\n    \"\"\"\n    try:\n        with open(file_path, 'r') as file:\n            data = np.loadtxt(file)\n            return data\n    except FileNotFoundError:\n        raise Exception(f\"The file at {file_path} was not found.\")\n\ndef calculate_dose(weight, concentration):\n    \"\"\"\n    Calculate the dose based on weight and drug concentration.\n\n    :param weight: The weight of the patient in kilograms.\n    :param concentration: The drug concentration in mg/kg.\n    :return: The calculated dose in milligrams.\n    \"\"\"\n    try:\n        dose = weight * concentration\n        return dose\n    except TypeError:\n        raise Exception(\"Invalid input: both weight and concentration must be numbers.\")\n\ndef prepare_solution(concentration, volume):\n    \"\"\"\n    Prepare a drug solution of a specified concentration and volume.\n\n    :param concentration: The target concentration of the solution in mg/mL.\n    :param volume: The volume of the solution needed in mL.\n    :return: The total amount of drug needed in mg.\n    \"\"\"\n    drug_needed = concentration * volume  # calculate total drug\n    return drug_needed\n\ndef main():\n    \"\"\"\n    Main function to execute the data loading and dosage calculation process.\n    \"\"\"\n    # Example usage\n    file_path = 'data/patient_data.txt'\n    try:\n        data = load_data(file_path)\n\n        # Calculate an example dose\n        weight = 70  # kg\n        concentration = 1.5  # mg/kg\n        dose = calculate_dose(weight, concentration)\n        print(f\"The calculated dose is: {dose} mg\")\n\n        # Prepare an example drug solution\n        concentration = 0.25  # mg/mL\n        volume = 100  # mL\n        drug_needed = prepare_solution(concentration, volume)\n        print(f\"The drug needed for the solution is: {drug_needed} mg\")\n    except Exception as e:\n        print(str(e))\n\nif __name__ == '__main__':\n    main()\n```",
                    "```python\nimport requests\n\ndef fetch_aircraft_data(api_url):\n    \"\"\"\n    Fetches aircraft data from the specified API.\n\n    Parameters:\n    api_url (str): The URL of the aircraft data API.\n\n    Returns:\n    dict: A dictionary containing the aircraft data if successful, None otherwise.\n    \"\"\"\n    try:\n        response = requests.get(api_url)\n        response.raise_for_status()  # Check for HTTP errors\n        data = response.json()  # Parse JSON response\n        return data\n    except requests.exceptions.RequestException as error:\n        # Log the exception or handle it as needed\n        print(f\"Error fetching aircraft data: {error}\")\n        return None\n\ndef calculate_flight_time(distance, speed):\n    \"\"\"\n    Calculates flight time given distance and speed.\n\n    Parameters:\n    distance (float): The distance traveled in nautical miles.\n    speed (float): The speed of the aircraft in knots.\n\n    Returns:\n    float: The flight time in hours.\n    \"\"\"\n    try:\n        if speed == 0:\n            raise ValueError(\"Speed cannot be zero.\")\n        flight_time = distance / speed  # Calculate flight time\n        return flight_time\n    except ValueError as error:\n        print(f\"Error calculating flight time: {error}\")\n        return None\n\ndef main():\n    \"\"\"\n    Main function to demonstrate fetching of aircraft data\n    and calculating flight times using hardcoded sample data.\n    \"\"\"\n    aircraft_api_url = \"https://api.example.com/aircraft\"\n    aircraft_data = fetch_aircraft_data(aircraft_api_url)\n\n    if aircraft_data:\n        # Sample data\n        distance = 500.0  # Distance in nautical miles\n        speed = 250.0  # Speed in knots\n\n        flight_time = calculate_flight_time(distance, speed)\n\n        if flight_time is not None:\n            print(f\"Flight time: {flight_time:.2f} hours\")\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List, Tuple\n\nclass SpeciesAnalyzer:\n    \"\"\"\n    A class used to analyze species populations and their evolutionary fitness.\n\n    Methods\n    -------\n    calculate_average_population_growth(populations: List[int]) -> float:\n        Calculates and returns the average growth rate of species populations.\n\n    calculate_fitness(species_population: int, growth_rate: float) -> float:\n        Calculates the fitness of a species based on its population and growth rate.\n    \"\"\"\n\n    def calculate_average_population_growth(self, populations: List[int]) -> float:\n        \"\"\"\n        Calculate the average population growth rate given a list of population sizes.\n        \n        Parameters\n        ----------\n        populations : List[int]\n            A list of integer population sizes over a series of generations.\n        \n        Returns\n        -------\n        float\n            The calculated average growth rate.\n        \"\"\"\n        if len(populations) < 2:\n            raise ValueError(\"At least two population data points are required to calculate growth rate.\")\n\n        growth_rates = [\n            (populations[i+1] - populations[i]) / populations[i]\n            for i in range(len(populations) - 1)\n        ]\n\n        return sum(growth_rates) / len(growth_rates)\n\n    def calculate_fitness(self, species_population: int, growth_rate: float) -> float:\n        \"\"\"\n        Calculate the evolutionary fitness of a species based on its population and growth rate.\n        \n        Parameters\n        ----------\n        species_population : int\n            Current population of the species.\n\n        growth_rate : float\n            Growth rate of the species population.\n        \n        Returns\n        -------\n        float\n            The calculated fitness score of the species.\n        \"\"\"\n        if species_population <= 0:\n            raise ValueError(\"Species population must be greater than zero.\")\n\n        fitness = growth_rate * math.log(species_population) if species_population > 0 else 0.0\n        return fitness\n\ndef main():\n    # Example usage of the SpeciesAnalyzer\n    analyzer = SpeciesAnalyzer()\n    \n    populations = [100, 150, 225, 337]\n    try:\n        average_growth = analyzer.calculate_average_population_growth(populations)\n        print(\"Average Growth Rate:\", average_growth)\n        \n        current_population = populations[-1]\n        fitness = analyzer.calculate_fitness(current_population, average_growth)\n        print(\"Species Fitness:\", fitness)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\nimport mido\nfrom mido import MidiFile, MidiTrack, Message\n\ndef load_midi(file_path):\n    \"\"\"\n    Load a MIDI file and return the MIDI object.\n\n    :param file_path: str - Path to the MIDI file.\n    :return: MidiFile - Loaded MIDI file object.\n    :raises: IOError - If file can't be loaded.\n    \"\"\"\n    try:\n        midi = MidiFile(file_path)\n        return midi\n    except IOError as e:\n        print(\"Error loading MIDI file:\", e)\n        raise\n\ndef play_midi_file(midi):\n    \"\"\"\n    Play a given MIDI file using mido's backend.\n\n    :param midi: MidiFile - MIDI file object to be played.\n    :return: None\n    \"\"\"\n    for msg in midi.play():\n        # Add logic here to send the message to a MIDI output device.\n        pass\n\ndef stop_midi_file():\n    \"\"\"\n    Stop MIDI playback.\n\n    :return: None\n    \"\"\"\n    # Implementation to stop the MIDI playback.\n    pass\n\ndef process_midi_file(file_path):\n    \"\"\"\n    Load and play MIDI file specified by the file_path.\n\n    :param file_path: str - Path to the MIDI file.\n    :return: None\n    \"\"\"\n    midi = load_midi(file_path)\n    play_midi_file(midi)\n\nif __name__ == \"__main__\":\n    file_path = 'path/to/your/midi/file.mid'\n    try:\n        process_midi_file(file_path)\n    except Exception as e:\n        print(\"An error occurred:\", e)\n```\n",
                    "```python\n# Importing necessary libraries\nimport math\nfrom typing import List\n\n# Defining a class to encapsulate population dynamics in an evolutionary model\nclass PopulationDynamics:\n    \"\"\"Class to model and simulate population dynamics and genetic adaptation.\"\"\"\n    \n    def __init__(self, initial_population: int, growth_rate: float):\n        \"\"\"\n        Initialize the population with initial size and growth rate.\n        \n        :param initial_population: The starting number of individuals in the population.\n        :param growth_rate: The rate at which the population grows per unit time.\n        \"\"\"\n        self.species_population = initial_population\n        self.growth_rate = growth_rate\n\n    def calculate_growth(self, time_period: int) -> int:\n        \"\"\"\n        Calculate the expected population size after a given time period.\n        \n        :param time_period: The number of time units for which the calculation is done.\n        :return: The predicted population size after time_period.\n        \"\"\"\n        try:\n            final_population = self.species_population * math.exp(self.growth_rate * time_period)\n            return int(final_population)\n        except OverflowError:\n            print(\"Error: The computation resulted in a number that is too large.\")\n            return -1\n\n# Function to evaluate the fitness of a population based on a simple model\ndef calculate_fitness(population_size: int, carrying_capacity: int) -> float:\n    \"\"\"\n    Calculate the relative fitness of a population compared to its environment's carrying capacity.\n    \n    :param population_size: The current size of the population.\n    :param carrying_capacity: The maximum sustainable population size for the environment.\n    :return: A fitness value between 0 and 1 indicating the population's adaptability.\n    \"\"\"\n    if carrying_capacity <= 0:\n        raise ValueError(\"Carrying capacity must be a positive, non-zero integer.\")\n    \n    fitness = population_size / carrying_capacity\n    return min(max(fitness, 0.0), 1.0)\n\n# Example usage of PopulationDynamics class\ndef simulate_population_growth() -> None:\n    \"\"\"\n    Simulate the growth of a population over a period with given parameters.\n    \"\"\"\n    try:\n        population_model = PopulationDynamics(initial_population=100, growth_rate=0.05)\n        time_periods = [i for i in range(1, 6)]  # Time periods from 1 to 5\n\n        for period in time_periods:\n            predicted_population = population_model.calculate_growth(time_period=period)\n            if predicted_population != -1:\n                fitness = calculate_fitness(population_size=predicted_population, carrying_capacity=500)\n                print(f\"After {period} units of time: Population = {predicted_population}, Fitness = {fitness:.2f}\")\n\n    except ValueError as e:\n        print(f\"Invalid parameters: {e}\")\n\n# Running the simulation\nsimulate_population_growth()\n```\n",
                    "```python\nimport numpy as np\n\ndef calculate_dosage(weight_kg, drug_concentration_mg_per_ml):\n    \"\"\"Calculate the dose based on weight and drug concentration.\n    \n    Args:\n        weight_kg (float): The weight of the patient in kilograms.\n        drug_concentration_mg_per_ml (float): The concentration of the drug\n                                               in milligrams per milliliter.\n    \n    Returns:\n        float: The calculated dose in milligrams.\n    \n    Raises:\n        ValueError: If the weight_kg or drug_concentration_mg_per_ml is\n                    less than or equal to zero.\n    \"\"\"\n    if weight_kg <= 0:\n        raise ValueError(\"The weight must be greater than zero.\")\n    \n    if drug_concentration_mg_per_ml <= 0:\n        raise ValueError(\"The drug concentration must be greater than zero.\")\n    \n    dose_mg = weight_kg * drug_concentration_mg_per_ml\n    return dose_mg\n\ndef prepare_solution(concentration, volume):\n    \"\"\"Prepare a solution based on the given concentration and volume.\n    \n    Args:\n        concentration (float): Concentration of the solution in mg/ml.\n        volume (float): Volume of the solution required in liters.\n    \n    Returns:\n        float: Mass of the solute needed in grams.\n    \n    Raises:\n        ValueError: If concentration or volume are zero or negative.\n    \"\"\"\n    if concentration <= 0 or volume <= 0:\n        raise ValueError(\"Concentration and volume must be greater than zero.\")\n    \n    mass_grams = concentration * volume * 1000  # Conversion from mg/ml to g\n    return mass_grams\n\n# Example usage\ntry:\n    weight = 70.0  # kg\n    drug_conc = 0.5  # mg/ml\n    dose = calculate_dosage(weight, drug_conc)\n    print(f\"Dose: {dose} mg\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    conc = 10  # mg/ml\n    vol = 1.5  # liters\n    solute_mass = prepare_solution(conc, vol)\n    print(f\"Solute mass: {solute_mass} grams\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom collections import defaultdict\n\n# Constants for evolution threshold\nEVOLUTION_THRESHOLD = 1.5\n\ndef calculate_population_variance(population_sizes):\n    \"\"\"\n    Calculate the variance of given population sizes to assess evolutionary adaptation.\n\n    Args:\n        population_sizes (list of int): A list of population sizes for different species.\n\n    Returns:\n        float: The calculated variance of the population sizes.\n    \"\"\"\n    n = len(population_sizes)\n    if n == 0:\n        raise ValueError(\"Population sizes list should not be empty.\")\n    \n    mean_population = sum(population_sizes) / n\n    variance = sum((size - mean_population) ** 2 for size in population_sizes) / n\n    \n    return variance\n\ndef is_population_evolving(population_sizes):\n    \"\"\"\n    Determine if the population is evolving based on variance.\n\n    Args:\n        population_sizes (list of int): A list of population sizes for different species.\n\n    Returns:\n        bool: True if population variance exceeds the evolution threshold, False otherwise.\n    \"\"\"\n    try:\n        variance = calculate_population_variance(population_sizes)\n        return variance > EVOLUTION_THRESHOLD\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return False\n\ndef group_species_by_habitat(species_habitat_data):\n    \"\"\"\n    Organize species by their habitat.\n\n    Args:\n        species_habitat_data (list of tuples): A list containing tuples of species and their habitats.\n\n    Returns:\n        defaultdict: A dictionary-like object categorizing species by habitat.\n    \"\"\"\n    habitat_groups = defaultdict(list)\n    for species, habitat in species_habitat_data:\n        habitat_groups[habitat].append(species)\n    \n    return habitat_groups\n\n# Example usage\npopulation_sizes = [120, 150, 90, 200, 300]\nprint(\"Is the population evolving?\", is_population_evolving(population_sizes))\n\nspecies_habitat_data = [\n    (\"frog\", \"wetlands\"),\n    (\"eagle\", \"mountains\"),\n    (\"salmon\", \"rivers\"),\n    (\"turtle\", \"wetlands\"),\n    (\"bear\", \"forests\")\n]\nhabitats = group_species_by_habitat(species_habitat_data)\nprint(\"Species grouped by habitat:\", habitats)\n```",
                "Incorrect_Answers": [
                    "```python\ndef calculate_genetic_similarity(species_one_genome, species_two_genome):\n    \"\"\"\n    Calculate the genetic similarity between two species based on their genomes.\n\n    Args:\n        species_one_genome (str): Genome sequence of the first species.\n        species_two_genome (str): Genome sequence of the second species.\n\n    Returns:\n        float: Genetic similarity as a percentage between 0 and 100.\n    \n    Raises:\n        ValueError: If genome sequences have inconsistent lengths or invalid characters.\n    \"\"\"\n\n    if len(species_one_genome) != len(species_two_genome):\n        raise ValueError(\"Genome sequences must be of the same length.\")\n\n    matches = 0\n    total_bases = len(species_one_genome)\n\n    for i, base in enumerate(species_one_genome):\n        if base not in 'ATCG' or species_two_genome[i] not in 'ATCG':\n            raise ValueError(\"Invalid characters in genome sequences.\")\n        if base == species_two_genome[i]:\n            matches += 1\n\n    similarity_percentage = (matches / total_bases) * 100\n\n    return similarity_percentage\n\n\n# Example usage\ntry:\n    similarity = calculate_genetic_similarity(\"AATTGCCG\", \"AATCGCCT\")\n    print(f\"Genetic similarity: {similarity:.2f}%\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n```",
                    "```python\nimport numpy as np\n\ndef calculate_dose(weight, drug_concentration):\n    \"\"\"\n    Calculate the appropriate dose based on weight and drug concentration.\n    \n    Parameters:\n    weight (float): The weight of the patient in kilograms.\n    drug_concentration (float): The concentration of the drug in mg/mL.\n    \n    Returns:\n    float: The calculated dose in mg.\n    \n    Raises:\n    ValueError: If input values are non-positive.\n    \"\"\"\n    if weight <= 0 or drug_concentration <= 0:\n        raise ValueError(\"Weight and drug concentration must be positive values.\")\n\n    dose = weight * drug_concentration  # dosage calculation\n    return dose\n\ndef prepare_solution(concentration, volume):\n    \"\"\"\n    Prepare the solution with the specified concentration and volume.\n    \n    Parameters:\n    concentration (float): The concentration of the solution in mg/mL.\n    volume (float): The volume of the solution in mL.\n    \n    Returns:\n    np.ndarray: A numpy array representing the prepared solution.\n    \n    Raises:\n    ValueError: If concentration or volume is non-positive.\n    \"\"\"\n    if concentration <= 0 or volume <= 0:\n        raise ValueError(\"Concentration and volume must be positive values.\")\n\n    solution = np.zeros(volume)  # initialize solution\n    for i in range(int(volume)):\n        solution[i] = concentration  # fill each mL with the specified concentration\n    \n    return solution\n\n# Example usage\ntry:\n    weight = 70.0  # patient's weight in kg\n    drug_concentration = 0.5  # drug concentration in mg/mL\n    dose = calculate_dose(weight, drug_concentration)\n    print(f\"The calculated dose is {dose} mg.\")\nexcept ValueError as e:\n    print(f\"Error: {str(e)}\")\n```",
                    "```python\n# Import necessary libraries at the top\nfrom datetime import datetime\n\ndef calculate_expenses(expenses):\n    \"\"\"\n    Calculate the total of the expenses.\n\n    Parameters:\n    expenses (list of float): List containing the expense values.\n\n    Returns:\n    float: The total of all the expenses.\n    \"\"\"\n    try:\n        # Use built-in sum function for optimization\n        total_expenses = sum(expenses)\n    except TypeError:\n        raise ValueError(\"All entries in expenses must be numbers.\")\n    return total_expenses\n\ndef suggest_family_activities(budget):\n    \"\"\"\n    Suggest activities based on the given budget.\n\n    Parameters:\n    budget (float): The amount available to spend on activities.\n\n    Returns:\n    list of str: Suggested activities that fit within the budget.\n    \"\"\"\n    # List of activities and their costs\n    activities = {\n        'Picnic at the park': 20.0,\n        'Movie night at home': 15.0,\n        'Visit to a free museum': 0.0,\n        'Hiking trip': 5.0\n    }\n    \n    # Filter and suggest activities within budget\n    return [activity for activity, cost in activities.items() if cost <= budget]\n\ndef main():\n    \"\"\"\n    Main function to execute financial planning for a family budget.\n    \"\"\"\n    budget = 50.0  # Total budget available\n    # Sample expenses list\n    expenses = [30.0, 10.0, 5.0]\n\n    # Calculate and display total expenses\n    total = calculate_expenses(expenses)\n    print(f\"Total expenses for the month: ${total:.2f}\")\n\n    # Suggest activities within the remaining budget\n    remaining_budget = budget - total\n    print(f\"Remaining budget: ${remaining_budget:.2f}\")\n    activities = suggest_family_activities(remaining_budget)\n    print(\"Suggested family activities:\")\n    for activity in activities:\n        print(f\"- {activity}\")\n\n# Ensure consistent entry point for the script\nif __name__ == \"__main__\":\n    main()\n```\n"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nimport math\nfrom typing import List, Tuple\n\ndef calculate_genetic_diversity(population: List[str]) -> float:\n    \"\"\"\n    Calculates the genetic diversity of a population by analyzing\n    the variety of genetic sequences present.\n\n    Parameters:\n        population (List[str]): A list of genetic sequences represented as strings.\n\n    Returns:\n        float: A measure of genetic diversity, with higher values representing\n               a more diverse population.\n    \"\"\"\n    try:\n        unique_sequences = set(population)\n        diversity_index = len(unique_sequences) / len(population)\n        return diversity_index\n    except ZeroDivisionError as e:\n        raise ValueError(\"Population cannot be empty\") from e\n\ndef optimize_population_sample(population: List[str], target_diversity: float) -> List[str]:\n    \"\"\"\n    Optimizes a sample from an existing population to achieve a target genetic\n    diversity by selecting the most diverse sequences.\n\n    Parameters:\n        population (List[str]): A list of genetic sequences represented as strings.\n        target_diversity (float): The desired diversity index to achieve in the sample.\n\n    Returns:\n        List[str]: A list of genetic sequences that meets the target diversity index.\n    \"\"\"\n    current_diversity = calculate_genetic_diversity(population)\n    if current_diversity >= target_diversity:\n        return population\n\n    sampled_population = []\n    available_sequences = list(set(population))\n\n    while calculate_genetic_diversity(sampled_population) < target_diversity and available_sequences:\n        sequence = available_sequences.pop()\n        sampled_population.append(sequence)\n\n        print(f\"Sampled: {sequence}, Current diversity: {calculate_genetic_diversity(sampled_population)}\")\n\n    if calculate_genetic_diversity(sampled_population) < target_diversity:\n        raise ValueError(\"Unable to achieve target diversity with available sequences\")\n\n    return sampled_population\n\ndef main():\n    \"\"\"\n    Main function to execute genetic diversity analysis and sample optimization.\n    Prepares a test scenario and demonstrates the functionality.\n    \"\"\"\n    population_data = [\n        \"ATCG\", \"GTCA\", \"CAGT\", \"TTAA\", \n        \"GGTT\", \"CCGG\", \"ATCG\", \"GTCA\"\n    ]\n    target_diversity = 0.6\n\n    diversity_index = calculate_genetic_diversity(population_data)\n    print(f\"Initial Genetic Diversity: {diversity_index}\")\n\n    optimized_sample = optimize_population_sample(population_data, target_diversity)\n    print(f\"Optimized Sample: {optimized_sample}\")\n    print(f\"Final Genetic Diversity: {calculate_genetic_diversity(optimized_sample)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\nfrom math import sqrt\nfrom statistics import mean\n\n\ndef calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points.\n    \n    :param point1: Tuple[float, float] - The first point (x1, y1).\n    :param point2: Tuple[float, float] - The second point (x2, y2).\n    :return: float - The Euclidean distance between the two points.\n    \"\"\"\n    try:\n        x1, y1 = point1\n        x2, y2 = point2\n        distance = sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    except TypeError as e:\n        raise ValueError(\"Both point1 and point2 must be tuples with two float numbers each.\") from e\n    return distance\n\n\ndef average_distances(points):\n    \"\"\"\n    Calculate the average distance from a list of points to the origin (0, 0).\n\n    :param points: List[Tuple[float, float]] - A list of points, each a tuple of coordinates (x, y).\n    :return: float - The average distance of all points from the origin.\n    \"\"\"\n    distances = [calculate_distance((0, 0), point) for point in points]\n    return mean(distances)\n\n\n# Example points\npoints_list = [(1.0, 2.0), (3.0, 4.0), (5.0, 12.0)]\n\n# Calculate and print the average distance\naverage_distance = average_distances(points_list)\nprint(f\"The average distance from the origin is: {average_distance:.2f}\")\n```\n",
                    "```python\ndef calculate_tax(income):\n    \"\"\"\n    Calculate the tax based on income using a given tax rate.\n\n    Args:\n    income (float): The income of the user in dollars.\n\n    Returns:\n    float: The calculated tax for the income.\n    \"\"\"\n    try:\n        tax_rate = 0.15  # A constant tax rate\n        tax = income * tax_rate\n        return tax\n    except TypeError as e:\n        print(f\"Error: {e}. Please provide a numeric value for income.\")\n\ndef calculate_net_income(income):\n    \"\"\"\n    Calculate the net income after tax.\n\n    Args:\n    income (float): The income of the user in dollars.\n\n    Returns:\n    float: The net income after tax deduction.\n    \"\"\"\n    try:\n        tax = calculate_tax(income)\n        net_income = income - tax\n        return net_income\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    user_income = 50000.0  # Example income\n    print(\"Calculating net income for the user...\")\n    net_income = calculate_net_income(user_income)\n    print(f\"Net income after tax: ${net_income:.2f}\")\n```",
                    "```python\nimport os\nimport sys\nfrom typing import List\n\ndef read_documents(document_paths: List[str]) -> List[str]:\n    \"\"\"\n    Reads text from a list of document paths and returns the content as a list of strings.\n\n    Args:\n        document_paths (List[str]): A list of file paths to read.\n\n    Returns:\n        List[str]: A list containing the content of each document as a single string.\n    \"\"\"\n    documents_content = []\n    for path in document_paths:\n        try:\n            with open(path, 'r', encoding='utf-8') as file:\n                documents_content.append(file.read())\n        except IOError as e:\n            print(f\"An error occurred while opening the file {path}: {e}\", file=sys.stderr)\n    return documents_content\n\n\ndef analyze_eastern_wu_documents(documents: List[str]) -> List[str]:\n    \"\"\"\n    Analyzes a list of document strings for references to the Eastern Wu period\n    and performs text analysis.\n\n    Args:\n        documents (List[str]): A list of strings representing document contents.\n\n    Returns:\n        List[str]: A list of analyzed results, such as summaries or key findings.\n    \"\"\"\n    analysis_results = []\n    for document in documents:\n        try:\n            # Placeholder: An actual analysis algorithm would be implemented here\n            summary = f\"Summary of document related to Eastern Wu: {document[:75]}\"\n            analysis_results.append(summary)\n        except Exception as e:\n            print(f\"An error occurred during analysis: {e}\", file=sys.stderr)\n    return analysis_results\n\n\ndef main():\n    \"\"\"\n    Main function to orchestrate the reading and analysis of documents related to Eastern Wu period.\n    \"\"\"\n    document_paths = ['document1.txt', 'document2.txt']  # Sample document paths\n    documents = read_documents(document_paths)\n    \n    if documents:\n        analysis_results = analyze_eastern_wu_documents(documents)\n        for result in analysis_results:\n            print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\nfrom typing import List\n\ndef calculate_adaptation_index(environment_factors: List[float], genetic_traits: List[float]) -> float:\n    \"\"\"\n    Calculate the adaptation index of a species based on its genetic traits\n    and environmental factors.\n\n    Args:\n        environment_factors (List[float]): A list of environmental factors affecting the species.\n        genetic_traits (List[float]): A list of genetic trait values of the species.\n\n    Returns:\n        float: An adaptation index indicative of how well the species is adapted\n               to the current environment.\n    \"\"\"\n    if len(environment_factors) != len(genetic_traits):\n        raise ValueError(\"The length of environment_factors and genetic_traits must be equal.\")\n\n    adaptation_index = sum(env * trait for env, trait in zip(environment_factors, genetic_traits)) / len(environment_factors)\n\n    return adaptation_index\n\ndef main():\n    try:\n        environment_factors = [0.8, 0.5, 0.9, 0.3]  # Example environment factors\n        genetic_traits = [0.7, 0.6, 0.8, 0.4]  # Example genetic traits\n        \n        index = calculate_adaptation_index(environment_factors, genetic_traits)\n        print(f\"Adaptation Index: {index}\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                "Incorrect_Answers": [
                    "```python\n# Import necessary libraries in an organized manner\nfrom typing import List, Optional\n\n# Define a function to analyze extremophile characteristics\ndef analyze_extremophiles(organisms: List[dict]) -> List[str]:\n    \"\"\"\n    Analyze a list of organisms to identify those that are extremophiles.\n\n    Args:\n        organisms (List[dict]): A list of dictionaries where each dictionary\n                                contains details of an organism.\n\n    Returns:\n        List[str]: A list of names of organisms identified as extremophiles.\n    \"\"\"\n    # List comprehension for filtering extremophiles with detailed inline comments\n    return [organism['name'] for organism in organisms \n            if organism.get('is_extremophile', False)]\n\ndef parse_organism_data(data: str) -> Optional[List[dict]]:\n    \"\"\"\n    Parse a string data input to a list of organism dictionaries.\n\n    Args:\n        data (str): A string representation of the organism data.\n\n    Returns:\n        Optional[List[dict]]: Parsed list of organism data dictionaries or None if parsing fails.\n    \"\"\"\n    try:\n        # Assume `data` is a JSON string; using a try-except block to handle parsing errors\n        import json\n        return json.loads(data)\n    except json.JSONDecodeError:\n        print(\"Error: Unable to decode the data. Please check if it is valid JSON format.\")\n        return None\n\n# Main function encapsulating the workflow\ndef main(data_source: str):\n    \"\"\"\n    Main function to process organism data and identify extremophiles.\n\n    Args:\n        data_source (str): A string representing the file path or URL to the data source.\n\n    Returns:\n        None\n    \"\"\"\n    # Detailed docstring explaining function usage\n    with open(data_source, 'r') as file:\n        data = file.read()\n    \n    # Parse data and identify extremophiles\n    organisms = parse_organism_data(data)\n    if organisms is None:\n        return\n    \n    extremophiles = analyze_extremophiles(organisms)\n    \n    # Output results with detailed explanation\n    print(f\"Identified extremophiles: {extremophiles}\")\n\n# Execute the program using self-descriptive variables\nif __name__ == \"__main__\":\n    data_file_path = \"organisms_data.json\"  # Ensure the data file path is correct\n    main(data_file_path)\n```",
                    "```python\nimport math\nfrom datetime import datetime\nimport requests\n\n# Constants\nTEAM_ID = 123\nAPI_URL = \"https://api.sportsdata.io/v3/football/stats\"\n\ndef fetch_team_data(team_id):\n    \"\"\"\n    Fetches team data from an external API based on the provided team ID.\n\n    Args:\n        team_id (int): The ID of the team to fetch data for.\n\n    Returns:\n        dict: The JSON response containing team data.\n    \"\"\"\n    try:\n        response = requests.get(f\"{API_URL}/teams/{team_id}\")\n        response.raise_for_status()\n        return response.json()\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return {}\n\ndef calculate_win_percentage(wins, total_games):\n    \"\"\"\n    Calculates the win percentage of the team.\n\n    Args:\n        wins (int): The number of games won.\n        total_games (int): The total number of games played.\n\n    Returns:\n        float: The win percentage of the team.\n    \"\"\"\n    try:\n        return (wins / total_games) * 100\n    except ZeroDivisionError:\n        return 0.0\n\ndef main():\n    \"\"\"\n    Main function to calculate and print the team's win percentage.\n    \"\"\"\n    team_data = fetch_team_data(TEAM_ID)\n    team_stats = team_data.get('stats', {})\n\n    wins = team_stats.get('wins', 0)\n    total_games = team_stats.get('total_games', 0)\n\n    # Calculate the win percentage based on total games\n    win_percentage = calculate_win_percentage(wins, total_games)\n    print(f\"Win percentage: {win_percentage:.2f}%\")\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport math\n\n# This jam calculates the circle's area, where 'r' is the radius, ya feel me?\n# Drop the big truths below\ud83d\udc47\ndef circle_area(radius):\n    try:\n        area = math.pi * (radius ** 2)\n        return area\n    except TypeError:\n        print(\"Yo! Radius needs to be a number, not your mixtape!\")\n\n# This function is all about that Pythagorean theorem hustle.\ndef hypotenuse_groove(a, b):\n    try:\n        return math.sqrt(a**2 + b**2)\n    except TypeError:\n        print(\"Numbers only! Can't square a word, can you?\")\n\n# Rock those pairwise sums, fast and smooth like a freestyle.\ndef dope_sum(numbers):\n    try:\n        return sum(numbers)\n    except TypeError:\n        print(\"Gotta be a list of numbers, fam!\")\n\n# Quick shoutout to the max finder, living large and taking charge.\ndef max_bop(*args):\n    if not args:\n        return \"No numbers, no max! A silent track ain't no track.\"\n    return max(args)\n\n# Versatile error management, catching issues like they're disses\ndef handle_the_situation():\n    try:\n        with open('some_nonline_extreme.txt', 'r') as f:\n            content = f.read()\n    except FileNotFoundError:\n        print(\"File's gone AWOL. Check your source, player!\")\n    except Exception as e:\n        print(f\"An unexpected glitch: {str(e)}\")\n\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            },
            {
                "Question": "Which of the following writing samples best aligns with the writer's persona above?",
                "Correct_Answer": "```python\ndef analyze_species_adaptation(species_data):\n    \"\"\"\n    Analyze genetic adaptation in a given dataset of species.\n    \n    Parameters:\n        species_data (list): A list of dictionaries containing genetic data for various species.\n        \n    Returns:\n        dict: A dictionary summarizing the analysis of genetic adaptations.\n    \"\"\"\n\n    adaptation_summary = {}\n\n    try:\n        for species in species_data:\n            species_name = species.get('name')\n            genetic_traits = species.get('genetic_traits', [])\n\n            fitness_score = calculate_fitness(genetic_traits)\n            adaptation_summary[species_name] = {\"fitness_score\": fitness_score}\n\n    except Exception as e:\n        print(f\"Error processing species data: {e}\")\n    \n    return adaptation_summary\n\ndef calculate_fitness(genetic_traits):\n    \"\"\"\n    Calculate the fitness score of a species based on its genetic traits.\n    \n    Parameters:\n        genetic_traits (list): A list of genetic traits of a species.\n        \n    Returns:\n        float: A calculated fitness score.\n    \"\"\"\n\n    # Assuming the fitness score is an average of the trait values\n    if not genetic_traits:\n        return 0.0\n    \n    total_score = sum(genetic_traits)\n    fitness_score = total_score / len(genetic_traits)\n    \n    return fitness_score\n\n# Usage example\nspecies_data_example = [\n    {\"name\": \"Species A\", \"genetic_traits\": [1.5, 2.0, 3.1]},\n    {\"name\": \"Species B\", \"genetic_traits\": [2.2, 2.8, 1.9]}\n]\n\nif __name__ == \"__main__\":\n    summary = analyze_species_adaptation(species_data_example)\n    print(summary)\n```\n",
                "Incorrect_Answers": [
                    "```python\nimport requests\n\ndef get_flight_data(api_url):\n    \"\"\"\n    Retrieve flight data from the given API URL.\n    \n    Parameters:\n        api_url (str): The URL of the aviation data API.\n        \n    Returns:\n        dict: The JSON response containing flight data.\n    \n    Raises:\n        requests.exceptions.RequestException: If an error occurs during the API request.\n    \"\"\"\n    try:\n        response = requests.get(api_url)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        # Log the exception details for debugging\n        print(f\"Failed to retrieve data: {e}\")\n        return None\n\ndef calculate_speed(distance, time):\n    \"\"\"\n    Calculate the speed given distance and time.\n    \n    Parameters:\n        distance (float): The distance traveled.\n        time (float): The time taken to travel the distance.\n        \n    Returns:\n        float: The calculated speed.\n    \n    Raises:\n        ValueError: If time is zero, as division by zero is not allowed.\n    \"\"\"\n    if time == 0:\n        raise ValueError(\"Time cannot be zero.\")\n    \n    # Compute speed, ensuring to avoid division by zero.\n    speed = distance / time\n    return speed\n\ndef main():\n    # Example main function to use the module\n    api_url = \"https://api.aviationdata.com/flights\"\n    flight_data = get_flight_data(api_url)\n    \n    if flight_data:\n        # Example usage of calculate_speed\n        distance = 500  # in kilometers\n        time = 1.5  # in hours\n        try:\n            flight_speed = calculate_speed(distance, time)\n            print(f\"The calculated speed is {flight_speed} km/h\")\n        except ValueError as e:\n            print(e)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\n# Import standard library modules\nimport random\nimport logging\n\n# Import third-party libraries\n\n\n# Initialize logging\nlogging.basicConfig(level=logging.INFO)\n\ndef get_random_player_move():\n    \"\"\"Return a random move choice for a player.\"\"\"\n    moves = ['pass', 'shoot', 'defend']\n    return random.choice(moves)\n\ndef calculate_score(player_move, opponent_move):\n    \"\"\"\n    Calculate the score based on player and opponent moves.\n    \n    Parameters:\n    player_move (str): The move chosen by the player.\n    opponent_move (str): The move chosen by the opponent.\n    \n    Returns:\n    int: The score gained or lost based on the move comparison.\n    \"\"\"\n    score = 0\n    if player_move == 'shoot' and opponent_move == 'defend':\n        score -= 1\n    elif player_move == 'shoot' and opponent_move != 'defend':\n        score += 2\n    elif player_move == 'pass':\n        score += 1\n    else:\n        score += 0\n    return score\n\ndef main():\n    \"\"\"\n    Run the main game loop.\n    \n    The player competes against a random opponent move.\n    Scores are updated based on move outcomes.\n    \"\"\"\n    player_score = 0\n    try:\n        player_move = input(\"Enter your move (pass/shoot/defend): \").strip().lower()\n        opponent_move = get_random_player_move()\n        \n        if player_move not in ['pass', 'shoot', 'defend']:\n            raise ValueError(\"Invalid move. Please choose from pass, shoot, or defend.\")\n        \n        logging.info(f\"Player Move: {player_move}, Opponent Move: {opponent_move}\")\n        score_change = calculate_score(player_move, opponent_move)\n        player_score += score_change\n        logging.info(f\"Score Change: {score_change}, Total Score: {player_score}\")\n\n    except ValueError as ve:\n        logging.error(ve)\n\nif __name__ == \"__main__\":\n    main()\n```",
                    "```python\nimport mido\nfrom mido import MidiFile\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef load_midi(file_path):\n    \"\"\"\n    Loads a MIDI file from a specified path.\n\n    :param file_path: String path to the MIDI file.\n    :return: A MidiFile object if successful, None if an error occurs.\n    \"\"\"\n    try:\n        midi_file = MidiFile(file_path)\n        logging.info(f\"MIDI file '{file_path}' loaded successfully.\")\n        return midi_file\n    except IOError as e:\n        logging.error(f\"Error loading MIDI file: {e}\")\n        return None\n\ndef play_midi_file(midi_file):\n    \"\"\"\n    Plays the provided MIDI file using the mido library.\n\n    :param midi_file: A MidiFile object to be played.\n    \"\"\"\n    for message in midi_file.play():\n        # Placeholder for sending MIDI message to an audio output\n        logging.info(f\"Playing message: {message}\")\n\ndef stop_midi_playback():\n    \"\"\"\n    Stops the current MIDI file playback.\n    \"\"\"\n    # Placeholder for stopping playback\n    logging.info(\"MIDI playback stopped.\")\n\ndef main():\n    \"\"\"\n    Main function to load and play a MIDI file.\n    \"\"\"\n    midi_file_path = 'path/to/traditional_music.mid'\n\n    # Load the MIDI file\n    midi_file = load_midi(midi_file_path)\n\n    if midi_file:\n        # Play the MIDI file\n        play_midi_file(midi_file)\n        # Example call to stop playback (extend as necessary)\n        stop_midi_playback()\n\n# Execute the main function\nif __name__ == \"__main__\":\n    main()\n```"
                ],
                "Type": "discriminating_new_writing_samples_aligned_with_users_preferences",
                "Topic": "coding",
                "Where": "END OF TEXT",
                "Reference": "Her name is Dr. Isabella Martinez, a renowned evolutionary biologist known for her groundbreaking research in genetic adaptation and the diversification of species. Born in 1988, Isabella grew up in a multicultural neighborhood that sparked her early interest in the natural world and the complex web of life that connects us all. As a proud Hispanic woman, she has often drawn on her heritage to inspire her approach to science, blending rigorous analytical methods with a deep appreciation for diverse perspectives. Isabella firmly believes in the separation of science and religion, advocating for empirical evidence as the cornerstone of scientific discovery while respecting individuals' spiritual beliefs. Beyond the lab, she is passionate about mentoring young women in STEM, striving to create inclusive opportunities for the next generation of scientists.\n\nWriting and Formatting Styles:\n\n{\n   \"[Coding Styles] Likes\": {\"1\": \"Meaningful variable names, e.g., 'species_population' instead of 'sp' to improve clarity.\", \"2\": \"Modular code design with functions that have single responsibilities, e.g., 'def calculate_fitness()'.\", \"3\": \"Extensive comments explaining complex algorithms or biological models.\", \"4\": \"Error handling using exceptions to gracefully manage unexpected inputs, e.g., 'try...except'.\", \"5\": \"Performance optimization through algorithm efficiency, preferring O(n log n) over O(n^2) when applicable.\"},\n   \"[Coding Styles] Dislikes\": {\"1\": \"Abbreviated variable names that hinder understanding, e.g., 'p1' instead of 'population_one'.\", \"2\": \"Long functions that tackle multiple responsibilities, leading to convoluted logic.\", \"3\": \"Avoiding error handling entirely, leading to potential crashes.\", \"4\": \"Over-optimization that sacrifices code readability for performance without clear benefit.\", \"5\": \"Code without comments or documentation, leaving the logic obscure.\"},\n   \"[Formatting Styles] Likes\": {\"1\": \"Consistent indentation using 4 spaces to maintain clean structure.\", \"2\": \"Limit lines to a maximum of 79 characters for readability.\", \"3\": \"Spacing around operators to enhance clarity, e.g., 'a + b' instead of 'a+b'.\", \"4\": \"Docstrings for all public modules, functions, and classes, explaining their purpose and usage.\", \"5\": \"Organized imports as per PEP 8 guidelines, e.g., standard library imports first, then third-party, followed by local imports.\"},\n   \"[Formatting Styles] Dislikes\": {\"1\": \"Inconsistent or mixed use of tabs and spaces, creating formatting issues.\", \"2\": \"Excessively long lines of code that exceed 79 characters, making it hard to read.\", \"3\": \"Lack of space around operators and commas, impacting readability.\", \"4\": \"Docstrings that are incomplete or missing altogether, leading to confusion about functionality.\", \"5\": \"Disorganized imports that make it hard to identify dependencies quickly.\"}\n}"
            }
        ]
    }
}